<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.52
     from ../texi/nana.texi on 6 November 1998 -->

<TITLE>GNU Nana: improved support for assertions and logging in C and C++ - Introduction</TITLE>
</HEAD>
<BODY>
Go to the first, previous, <A HREF="nana_2.html">next</A>, <A HREF="nana_42.html">last</A> section, <A HREF="nana_toc.html">table of contents</A>.
<P><HR><P>

<P>
Copyright (C) 1996, 1997, P.J.Maker

</P>
<P>
Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

</P>



<H1><A NAME="SEC1" HREF="nana_toc.html#TOC1">Introduction</A></H1>

<P>
Nana is a library that provides support for assertion checking
and logging in a space and time efficient manner. The aim is to put
common good practise<A NAME="DOCF1" HREF="nana_foot.html#FOOT1">(1)</A> into a library that can be reused rather than
writing this stuff every time you begin a new project.

</P>
<P>
In addition assertion checking and logging code can be implemented using
a debugger rather than as inline code with a large saving in code space.

</P>
<P>
Nana aims to solve the following problems:

</P>

<OL>
<LI>Avoid the two executables problem (one with asserts in and another

without any).

The code space and time costs of having assertion checking and detailed
logging code in a program can be high. Normally people construct two
versions of the program, one with checking code for testing and one
without checking code for production use.

With nana one version of the executable can be
built for both testing and release since debugger based checking has 
negligible space and time impact.

<LI>Configurable: the nana library is designed to be reconfigured by

the user according to their needs. For example we can:

<UL>
<LI>Modify the behaviour on assertion failure, e.g. to attempt

a system restart rather than just shutting down.
<LI>Selectively enable and disable assertion checking and

logging both at compile and run time.
<LI>Send the logging information off to various locations, e.g.


<UL>
<LI>Users terminal

<LI>A file for later checking.

<LI>Another process, e.g. a plotting program or a

program that verifies that the system is behaving itself.
<LI>A circular buffer in memory.

This is an old embedded systems trick and is very useful
for production systems. The time cost of logging into 
memory is not large and when your production system in
the field has problems you can then see what was happening 
in the minutes before its unfortunate demise rather than
asking some user what was happening before it died.
</UL>

</UL>

<LI>Time and space efficient.

For example the GNU <SAMP>`assert.h'</SAMP> implementation uses 53 bytes for 
<SAMP>`assert(i&#62;=0)'</SAMP> on a i386. The nana version using the i386 <SAMP>`stp'</SAMP>
instruction on assert fail uses 10 bytes. If your willing to accept the
time penalty this can be reduced to 0 or 1 byte by using debugger based
assertions.

<LI>Support for formal methods.


<UL>
<LI>Before and after state (e.g. x,x' in the Z notation).

Specifications are often written in terms of the state of
variables before and after an operation. For example the
<SAMP>`isempty'</SAMP> operation on a stack should leave the stack
unchanged. To verify this in nana we could use:
      

<PRE>
bool isempty(){ /* true iff stack is empty */
  DS($s = s); /* copy s into $s in the debugger */
  ...; /* code to do the operation */
  DI($s == s); /* verify that s hasn't been changed */
}
</PRE>

        
These <SAMP>`$..'</SAMP> variables are called convenience variables 
and are implemented by gdb. They have a global scope and are 
dynamically typed and initialised automatically to 0.

In addition a C only version of before and after state is provided.
For example:


<PRE>
bool isempty() { /* true iff stack is empty */
  ID(int olds); /* declare variable to hold old value */
  IS(olds = s); /* copy s into $s in the debugger */
  ...; /* code to do the operation */
  I(olds == s); /* verify that s hasn't been changed */
}
</PRE>

<LI>Support for Predicate Calculus.

Nana provides some support for universal (forall) and
existential  (exists one or more) quantification. For example to specify
that the string v contains only lower case letters we could use:


<PRE>
  I(A(char *p = v, *p != '\0', p++, islower(*p)));
</PRE>

These macros can be nested and used as normal boolean values in
control constructs as well as assertions. Unfortunately they
depend on the GNU CC statement value extensions and so are not 
portable. The following macros are defined in <SAMP>`Q.h'</SAMP>:

<DL COMPACT>

<DT><CODE>A</CODE>
<DD>
<A NAME="IDX1"></A>
For all values the expression must be true.
<DT><CODE>E</CODE>
<DD>
<A NAME="IDX2"></A>
There exists one or more values for which the expression is
true.
<DT><CODE>E1</CODE>
<DD>
<A NAME="IDX3"></A>
There exists a single value for which the expression is true.
<DT><CODE>C</CODE>
<DD>
<A NAME="IDX4"></A>
Returns the number of times the expression is true.
<DT><CODE>S</CODE>
<DD>
<A NAME="IDX5"></A>
Returns the sum of the expressions.
<DT><CODE>P</CODE>
<DD>
<A NAME="IDX6"></A>
Returns the product of the expressions.
</DL>

<LI>Verifying timing.

As well as using nana to verify timings with assertions using a
hardware supported timer you can also a simulator (e.g. the
PSIM power pc simulator by Cagney) with gdb. These simulators can
model time and provide a register called <SAMP>`$cycles'</SAMP> which
represents the current cycle count of the program. This can be 
used to check that timing constraints are being meet.


<PRE>
void process_events() {
  for(;;){ 
    DS($start = $cycles); 
    switch(get_event()){
      case TOO_HOT:
        ...;
        DI($start - $cycles &#60;= 120);
        break;
      case TOO_COLD:
        ...;
        DI($start - $cycles &#60;= 240);
        break;
    }
  }
}
</PRE>

</UL>

</OL>

<P>
The intended audience for Nana includes:

</P>

<UL>
<LI>Software Engineers.

<LI>Formal methods community.

<LI>Real time programmers.

<LI>System testers.

<LI>People teaching programming.

</UL>

<P><HR><P>
Go to the first, previous, <A HREF="nana_2.html">next</A>, <A HREF="nana_42.html">last</A> section, <A HREF="nana_toc.html">table of contents</A>.
</BODY>
</HTML>
