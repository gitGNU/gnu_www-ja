<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.52
     from ../texi/nana.texi on 6 November 1998 -->

<TITLE>GNU Nana: improved support for assertions and logging in C and C++ - DI.h</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="nana_1.html">first</A>, <A HREF="nana_19.html">previous</A>, <A HREF="nana_21.html">next</A>, <A HREF="nana_42.html">last</A> section, <A HREF="nana_toc.html">table of contents</A>.
<P><HR><P>


<H2><A NAME="SEC20" HREF="nana_toc.html#TOC20">DI.h: debugger based invariant checking</A></H2>
<P>
This implements the debugger based invariant checking code.
The first two macros are the normal
user interface; the remainder are used for configuring the behaviour on
failure, etc. Note that these macros have no effect unless you run your 
program under the debugger and read in the commands generated by the
<SAMP>`nana'</SAMP> command.

</P>
<P>
<DL>
<DT><U>Macro:</U> void <B>DI</B> <I>(bool <VAR>exprn</VAR>)</I>
<DD><A NAME="IDX59"></A>
The <VAR>exprn</VAR> should always be true if the program is working. 
If it is true then nothing happens otherwise the code given by
<SAMP>`DI_DEFAULT_HANDLER'</SAMP> will be called which by default prints 
a message and dies just like <SAMP>`assert.h'</SAMP>.  

</P>
<P>
The checking using <VAR>DI</VAR> can be enabled and disabled by using the
<VAR>DI_LEVEL</VAR> and <VAR>DI_DEFAULT_GUARD</VAR> macros. See the definitions
below for these macros for further details.

</P>
<P>
Note that <VAR>exprn</VAR> should have no side-effects<A NAME="DOCF6" HREF="nana_foot.html#FOOT6">(6)</A> since 
disabling the checking shouldn't change your programs behaviour.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> void <B>DN</B> <I>(bool <VAR>exprn</VAR>)</I>
<DD><A NAME="IDX60"></A>
The opposite of <SAMP>`DI'</SAMP>, i.e. the expression must never ever be true if
the program is working properly. It is equivelant to <CODE>I(!(e))</CODE> and
exists as piece of syntactic sugar which is helpful for complicated
boolean expressions.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> int <B>DI_LEVEL</B>
<DD><A NAME="IDX61"></A>
The <SAMP>`DI_LEVEL'</SAMP> macro is used to globally enable and disable
checking, in particular it can take on one of three values:

</P>
<DL COMPACT>

<DT><CODE>0</CODE>
<DD>
<A NAME="IDX62"></A>
Disable all checking. Regardless of anything else no code will be
generated for <CODE>DI</CODE>, <CODE>DN</CODE>, etc.
<DT><CODE>1</CODE>
<DD>
<A NAME="IDX63"></A>
Enable checking only if the corresponding guard condition is true. The
guard condition can be used to enable and disable checking at compile
and run time.
<DT><CODE>2</CODE>
<DD>
<A NAME="IDX64"></A>
Enable all checking regardless of guard conditions, etc.
</DL>

<P>
<CODE>DI_LEVEL</CODE> defaults to <CODE>1</CODE>. 
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> bool <B>DI_DEFAULT_GUARD</B>
<DD><A NAME="IDX65"></A>
The <CODE>DI_DEFAULT_GUARD</CODE> is used to selectively enable or disable
checking at compile or run time. 

</P>
<P>
<CODE>DI_DEFAULT_GUARD</CODE> defaults to <CODE>TRUE</CODE>, i.e. always enabled.

</P>
<P>
A user would typically define <CODE>DI_DEFAULT_GUARD</CODE> to be global or local
variable which is used to turn checking on or off at run--time. For
example:

</P>

<PRE>
#define DI_DEFAULT_GUARD (i_guard)

extern int i_guard;
</PRE>

</DL>

<P>
<DL>
<DT><U>Macro:</U> text <B>DI_DEFAULT_PARAMS</B>
<DD><A NAME="IDX66"></A>
This is passed off to the <CODE>DI_DEFAULT_HANDLER</CODE> and defaults to
nothing, it is just some text and is intended to pass failure codes
(e.g. <CODE>IEH303</CODE>) or requests (e.g. <CODE>HW_DEAD</CODE>) information off
to the handler.

</P>
<P>
<CODE>DI_DEFAULT_PARAMS</CODE> defaults to nothing.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> void <B>DI_DEFAULT_HANDLER</B> <I>(char *<VAR>exprn</VAR>, char *<VAR>file</VAR>, int <VAR>line</VAR>, <VAR>param</VAR>)</I>
<DD><A NAME="IDX67"></A>

</P>
<P>
When an error is detected the <CODE>DI_DEFAULT_HANDLER</CODE> will be called to
handle the error. The arguments are:

</P>
<DL COMPACT>

<DT><CODE>exprn</CODE>
<DD>
<A NAME="IDX68"></A>
A string representation of the expression that has failed, e.g. <CODE>"I(i&#62;=0)"</CODE>.
<DT><CODE>file</CODE>
<DD>
<A NAME="IDX69"></A>
The file that this error occurred in, i.e. <CODE>__FILE__</CODE>.
<DT><CODE>line</CODE>
<DD>
<A NAME="IDX70"></A>
The line number for the error, i.e. <CODE>__LINE__</CODE>.
<DT><CODE>param</CODE>
<DD>
<A NAME="IDX71"></A>
An optional parameter which can be passed across which defaults to
<CODE>DI_DEFAULT_PARAMS</CODE>. This can be used to pass failure codes or other
information from the checking code to the handler.
</DL>
</DL>

<P>
<DL>
<DT><U>Macro:</U> void <B>DI_MAKE_VALID_BREAKPOINT</B> <I>(exprn <VAR>e</VAR>)</I>
<DD><A NAME="IDX72"></A>
This macro is used to ensure that a breakpoint can be set at the
location we are checking using <CODE>DI</CODE>, etc. It defaults to
<CODE>asm("nop")</CODE> and can be redefined by the user.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> void <B>DI</B> <I>(bool <VAR>e</VAR>)</I>
<DD><A NAME="IDX73"></A>
<DT><U>Macro:</U> void <B>DIG</B> <I>(bool <VAR>e</VAR>, bool <VAR>g</VAR>)</I>
<DD><A NAME="IDX74"></A>
<DT><U>Macro:</U> void <B>DIH</B> <I>(bool <VAR>e</VAR>, Macro <VAR>h</VAR>)</I>
<DD><A NAME="IDX75"></A>
<DT><U>Macro:</U> void <B>DIP</B> <I>(bool <VAR>e</VAR>, Text <VAR>p</VAR>)</I>
<DD><A NAME="IDX76"></A>
<DT><U>Macro:</U> void <B>DIGH</B> <I>(bool <VAR>e</VAR>, bool <VAR>g</VAR>, Macro <VAR>h</VAR>)</I>
<DD><A NAME="IDX77"></A>
<DT><U>Macro:</U> void <B>DIGP</B> <I>(bool <VAR>e</VAR>, bool <VAR>g</VAR>, Text <VAR>p</VAR>)</I>
<DD><A NAME="IDX78"></A>
<DT><U>Macro:</U> void <B>DIHP</B> <I>(bool <VAR>e</VAR>, Macro <VAR>h</VAR>, Text <VAR>p</VAR>)</I>
<DD><A NAME="IDX79"></A>
<DT><U>Macro:</U> void <B>DIGHP</B> <I>(bool <VAR>e</VAR>, bool <VAR>g</VAR>, Macro <VAR>h</VAR>, Text <VAR>p</VAR>)</I>
<DD><A NAME="IDX80"></A>
<DT><U>Macro:</U> void <B>DN</B> <I>(bool <VAR>e</VAR>)</I>
<DD><A NAME="IDX81"></A>
<DT><U>Macro:</U> void <B>DNG</B> <I>(bool <VAR>e</VAR>, bool <VAR>g</VAR>)</I>
<DD><A NAME="IDX82"></A>
<DT><U>Macro:</U> void <B>DNH</B> <I>(bool <VAR>e</VAR>, Macro <VAR>h</VAR>)</I>
<DD><A NAME="IDX83"></A>
<DT><U>Macro:</U> void <B>DNP</B> <I>(bool <VAR>e</VAR>, Text <VAR>p</VAR>)</I>
<DD><A NAME="IDX84"></A>
<DT><U>Macro:</U> void <B>DNGH</B> <I>(bool <VAR>e</VAR>, bool <VAR>g</VAR>, Macro <VAR>h</VAR>)</I>
<DD><A NAME="IDX85"></A>
<DT><U>Macro:</U> void <B>DNGP</B> <I>(bool <VAR>e</VAR>, bool <VAR>g</VAR>, Text <VAR>p</VAR>)</I>
<DD><A NAME="IDX86"></A>
<DT><U>Macro:</U> void <B>DNHP</B> <I>(bool <VAR>e</VAR>, Macro <VAR>h</VAR>, Text <VAR>p</VAR>)</I>
<DD><A NAME="IDX87"></A>
<DT><U>Macro:</U> void <B>DNGHP</B> <I>(bool <VAR>e</VAR>, bool <VAR>g</VAR>, Macro <VAR>h</VAR>, Text <VAR>p</VAR>)</I>
<DD><A NAME="IDX88"></A>

</P>
<P>
All of these macros are used to individually override the
default values defined above. Normally these macros
would be used in a system wide header file to define macros appropriate 
for the application.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> void <B>DS</B> <I>(<VAR>e</VAR>)</I>
<DD><A NAME="IDX89"></A>
<DT><U>Macro:</U> void <B>DSG</B> <I>(<VAR>e</VAR>, <VAR>g</VAR>)</I>
<DD><A NAME="IDX90"></A>
These macros are used to assign values to convenience variables in the
debugger. Convenience variables are dynamically typed, global in scope
and initialised to 0. They start with a single <CODE>$</CODE> and can be used be
used for saving the state of program or for counting events. The
<SAMP>`DS'</SAMP> macro executes <VAR>e</VAR> under the same rules as <CODE>DI</CODE>.
The <SAMP>`DSG'</SAMP> macro executes <VAR>e</VAR> only if the the expression
<VAR>g</VAR> is true.

</P>
<P>
Note that <SAMP>`DS'</SAMP> and <SAMP>`DSG'</SAMP> can also be used for modifying
C variables and calling functions.
</DL>

</P>
<P><HR><P>
Go to the <A HREF="nana_1.html">first</A>, <A HREF="nana_19.html">previous</A>, <A HREF="nana_21.html">next</A>, <A HREF="nana_42.html">last</A> section, <A HREF="nana_toc.html">table of contents</A>.
</BODY>
</HTML>
