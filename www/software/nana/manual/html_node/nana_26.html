<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.52
     from ../texi/nana.texi on 6 November 1998 -->

<TITLE>GNU Nana: improved support for assertions and logging in C and C++ - Q.h</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="nana_1.html">first</A>, <A HREF="nana_25.html">previous</A>, <A HREF="nana_27.html">next</A>, <A HREF="nana_42.html">last</A> section, <A HREF="nana_toc.html">table of contents</A>.
<P><HR><P>


<H2><A NAME="SEC26" HREF="nana_toc.html#TOC26">Q.h: support for quantifiers</A></H2>
<P>
<SAMP>`Q.h'</SAMP> provides support for the quantifiers of predicate logic.  For
example to check that all elements in a data structure have some
property we would use universal (forall, upside down A) quantification.
To check that one or more values in a data structure have some property
we would use existential (exists, back the front E) quantification.  For
example:

</P>

<PRE>
  /* all values in a[] must be between 0 and 10 */
  I(A(int i = 0, i &#60; n_array, i++, 0 &#60;= a[i] &#38;&#38; a[i] &#60;= 10));

  /* there exists a value in linked list l which is smaller than 10 */
  I(E(node *p = l, p != NULL, p = p-&#62;next, p-&#62;data &#60;= 10));
</PRE>

<P>
The first three arguments to <SAMP>`A'</SAMP> and <SAMP>`E'</SAMP> are similar 
to a C <SAMP>`for'</SAMP> loop which iterates over the values we wish to
check. The final argument is the expression that must be true.

</P>
<P>
The only minor difference from the C <SAMP>`for'</SAMP> loop is that variables
may be declared at the start of the loop, even if you are using C rather
than C++ which already supports this.<A NAME="DOCF8" HREF="nana_foot.html#FOOT8">(8)</A>

</P>
<P>
The <SAMP>`Q.h'</SAMP> macros can also be nested and used anywhere a boolean 
value is required. For example:

</P>

<PRE>
  if(A(int i = 0, i &#60; MAXX, i++,
       A(int j = 0, j &#60; MAXY, j++,
         m[i][j] == (i == j ? 1 : 0)))) { 
        /* identity matrix, i.e. all 0's except for 1's on */
        /* the diagonal */
        ...
  } else {
        /* not an identity matrix */
        ...
  }
</PRE>

<P>
The results from these 
macros can also be combined using boolean operations, e.g.

</P>

<PRE>
  /* the values in a[i]  are either ALL positive or ALL negative */
  I(A(int i = 0, i &#60; MAX, i++, a[i] &#62;= 0)
    ||
    A(int i = 0, i &#60; MAX, i++, a[i] &#60; 0));
</PRE>

<P>
<STRONG>Portability:</STRONG> note the macros in this file require the GNU
CC/C++ statement expression extension of GCC to work. If your not using GNU CC
then for now you are out of luck. At some time in the future we may
implement a method which will work for standard C++, standard C is a bit of
a challenge.

</P>
<P>
<STRONG>Portability:</STRONG> unfortunately these macros do not for the 
<SAMP>`DI'</SAMP> and <SAMP>`DL'</SAMP> macros since the statement expression extension has 
not been implemented in GDB.

</P>
<P>
<DL>
<DT><U>Macro:</U> bool <B>A</B> <I>(<VAR>init</VAR>,<VAR>condition</VAR>,<VAR>next</VAR>,<VAR>exprn</VAR>)</I>
<DD><A NAME="IDX155"></A>
For all values generated by
 <SAMP>`for(<VAR>int</VAR>;<VAR>condition</VAR>;<VAR>next</VAR>)'</SAMP> the <VAR>exprn</VAR> must be
true. 

<PRE>
  I(A(int i = 0, i &#60; MAX, i++, a[i] &#62;= 0)); /* all a[i] are +ve */
</PRE>

</DL>

<P>
<DL>
<DT><U>Macro:</U> bool <B>E</B> <I>(<VAR>init</VAR>,<VAR>condition</VAR>,<VAR>next</VAR>,<VAR>exprn</VAR>)</I>
<DD><A NAME="IDX156"></A>
There exists at least one value for <VAR>exprn</VAR> generated by
 <SAMP>`for (<VAR>int</VAR>;<VAR>condition</VAR>;<VAR>next</VAR>)'</SAMP> which is true.

</P>

<PRE>
  /* one or more a[i] &#62;= 0 */
  I(E(int i = 0, i &#60; MAX, i++, a[i] &#62;= 0));
</PRE>

</DL>

<P>
<DL>
<DT><U>Macro:</U> long <B>C</B> <I>(<VAR>init</VAR>,<VAR>condition</VAR>,<VAR>next</VAR>,<VAR>exprn</VAR>)</I>
<DD><A NAME="IDX157"></A>
Returns the number of times the <VAR>exprn</VAR> is true over the values
generated by <SAMP>`for(<VAR>int</VAR>;<VAR>condition</VAR>;<VAR>next</VAR>)'</SAMP>.

</P>

<PRE>
  /* 3 elements of a[] are +ve */
  I(C(int i = 0, i &#60; MAX, i++, a[i] &#62;= 0) == 3); 
</PRE>

</DL>

<P>
<DL>
<DT><U>Macro:</U> bool <B>E1</B> <I>(<VAR>init</VAR>,<VAR>condition</VAR>,<VAR>next</VAR>,<VAR>exprn</VAR>)</I>
<DD><A NAME="IDX158"></A>
There exists only one value generated by 
 <SAMP>`for(<VAR>int</VAR>;<VAR>condition</VAR>;<VAR>next</VAR>)'</SAMP> for which the <VAR>exprn</VAR>
is true.

</P>

<PRE>
  /* a single elements of a[] is +ve */
  I(E1(int i = 0, i &#60; MAX, i++, a[i] &#62;= 0)); 
</PRE>

</DL>

<P>
<DL>
<DT><U>Macro:</U> typeof(<VAR>exprn</VAR>) <B>S</B> <I>(<VAR>init</VAR>,<VAR>condition</VAR>,<VAR>next</VAR>,<VAR>exprn</VAR>)</I>
<DD><A NAME="IDX159"></A>
Sum the values generated by <VAR>exprn</VAR> for all values given by
 <SAMP>`for(<VAR>int</VAR>;<VAR>condition</VAR>;<VAR>next</VAR>)'</SAMP>. The type of the value
returned  is given by the type of the <VAR>exprn</VAR>.<A NAME="DOCF9" HREF="nana_foot.html#FOOT9">(9)</A>

</P>

<PRE>
  /* sum of a[] is 10 */
  I(S(int i = 0, i &#60; MAX, i++, a[i]) == 10);

  /* sum of all +ve numbers in a[] is 10 */
  I(S(int i = 0, i &#60; MAX, i++, a[i] &#62;= 0 ? a[i] : 0) == 10);
</PRE>

</DL>

<P>
<DL>
<DT><U>Macro:</U> typeof(<VAR>exprn</VAR>) <B>P</B> <I>(<VAR>init</VAR>,<VAR>condition</VAR>,<VAR>next</VAR>,<VAR>exprn</VAR>)</I>
<DD><A NAME="IDX160"></A>
Returns the product of the 
values generated by <VAR>exprn</VAR> for all values given by
 <SAMP>`for(<VAR>int</VAR>;<VAR>condition</VAR>;<VAR>next</VAR>)'</SAMP>.
The type returned is the type of the expression.

</P>

<PRE>
  /* product of all the values in a[] is 10 */
  I(P(int i = 0, i &#60; MAX, i++, a[i]) == 10); 

  /* a = x^y i.e. x*x..*x y times */
  I(P(int i = 0, i &#60; y, i++, x) == a);
</PRE>

</DL>

<P><HR><P>
Go to the <A HREF="nana_1.html">first</A>, <A HREF="nana_25.html">previous</A>, <A HREF="nana_27.html">next</A>, <A HREF="nana_42.html">last</A> section, <A HREF="nana_toc.html">table of contents</A>.
</BODY>
</HTML>
