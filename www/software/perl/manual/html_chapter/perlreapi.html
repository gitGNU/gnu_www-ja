<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by Texinfo 5.1+dev, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Perl pod documentation: perlreapi</title>

<meta name="description" content="Perl pod documentation: perlreapi">
<meta name="keywords" content="Perl pod documentation: perlreapi">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2any">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="index.html#Top" rel="start" title="Top">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="index.html#Top" rel="up" title="Top">
<link href="perlrebackslash.html#perlrebackslash" rel="next" title="perlrebackslash">
<link href="perlre.html#perlre-SEE-ALSO" rel="prev" title="perlre SEE ALSO">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.indentedblock {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smallindentedblock {margin-left: 3.2em; font-size: smaller}
div.smalllisp {margin-left: 3.2em}
kbd {font-style:oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nocodebreak {white-space:nowrap}
span.nolinebreak {white-space:nowrap}
span.roman {font-family:serif; font-weight:normal}
span.sansserif {font-family:sans-serif; font-weight:normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">
<a name="perlreapi"></a>
<div class="header">
<p>
Next: <a href="perlrebackslash.html#perlrebackslash" accesskey="n" rel="next">perlrebackslash</a>, Previous: <a href="perlre.html#perlre" accesskey="p" rel="prev">perlre</a>, Up: <a href="index.html#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="perlreapi-1"></a>
<h2 class="chapter">59 perlreapi</h2>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#perlreapi-NAME" accesskey="1">perlreapi NAME</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#perlreapi-DESCRIPTION" accesskey="2">perlreapi DESCRIPTION</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#perlreapi-Callbacks" accesskey="3">perlreapi Callbacks</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#perlreapi-The-REGEXP-structure" accesskey="4">perlreapi The REGEXP structure</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#perlreapi-HISTORY" accesskey="5">perlreapi HISTORY</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#perlreapi-AUTHORS" accesskey="6">perlreapi AUTHORS</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#perlreapi-LICENSE" accesskey="7">perlreapi LICENSE</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="perlreapi-NAME"></a>
<div class="header">
<p>
Next: <a href="#perlreapi-DESCRIPTION" accesskey="n" rel="next">perlreapi DESCRIPTION</a>, Up: <a href="#perlreapi" accesskey="u" rel="up">perlreapi</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="NAME-58"></a>
<h3 class="section">59.1 NAME</h3>

<p>perlreapi - Perl regular expression plugin interface
</p>
<hr>
<a name="perlreapi-DESCRIPTION"></a>
<div class="header">
<p>
Next: <a href="#perlreapi-Callbacks" accesskey="n" rel="next">perlreapi Callbacks</a>, Previous: <a href="#perlreapi-NAME" accesskey="p" rel="prev">perlreapi NAME</a>, Up: <a href="#perlreapi" accesskey="u" rel="up">perlreapi</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="DESCRIPTION-57"></a>
<h3 class="section">59.2 DESCRIPTION</h3>

<p>As of Perl 5.9.5 there is a new interface for plugging and using
regular expression engines other than the default one.
</p>
<p>Each engine is supposed to provide access to a constant structure of the
following format:
</p>
<pre class="verbatim">    typedef struct regexp_engine {
        REGEXP* (*comp) (pTHX_
                         const SV * const pattern, const U32 flags);
        I32     (*exec) (pTHX_
                         REGEXP * const rx,
                         char* stringarg,
                         char* strend, char* strbeg,
                         I32 minend, SV* screamer,
                         void* data, U32 flags);
        char*   (*intuit) (pTHX_
                           REGEXP * const rx, SV *sv,
                           char *strpos, char *strend, U32 flags,
                           struct re_scream_pos_data_s *data);
        SV*     (*checkstr) (pTHX_ REGEXP * const rx);
        void    (*free) (pTHX_ REGEXP * const rx);
        void    (*numbered_buff_FETCH) (pTHX_
                                        REGEXP * const rx,
                                        const I32 paren,
                                        SV * const sv);
        void    (*numbered_buff_STORE) (pTHX_
                                        REGEXP * const rx,
                                        const I32 paren,
                                        SV const * const value);
        I32     (*numbered_buff_LENGTH) (pTHX_
                                         REGEXP * const rx,
                                         const SV * const sv,
                                         const I32 paren);
        SV*     (*named_buff) (pTHX_
                               REGEXP * const rx,
                               SV * const key,
                               SV * const value,
                               U32 flags);
        SV*     (*named_buff_iter) (pTHX_
                                    REGEXP * const rx,
                                    const SV * const lastkey,
                                    const U32 flags);
        SV*     (*qr_package)(pTHX_ REGEXP * const rx);
    #ifdef USE_ITHREADS
        void*   (*dupe) (pTHX_ REGEXP * const rx, CLONE_PARAMS *param);
    #endif
        REGEXP* (*op_comp) (...);
</pre>
<p>When a regexp is compiled, its <code>engine</code> field is then set to point at
the appropriate structure, so that when it needs to be used Perl can find
the right routines to do so.
</p>
<p>In order to install a new regexp handler, <code>$^H{regcomp}</code> is set
to an integer which (when casted appropriately) resolves to one of these
structures.  When compiling, the <code>comp</code> method is executed, and the
resulting <code>regexp</code> structure&rsquo;s engine field is expected to point back at
the same structure.
</p>
<p>The pTHX_ symbol in the definition is a macro used by Perl under threading
to provide an extra argument to the routine holding a pointer back to
the interpreter that is executing the regexp. So under threading all
routines get an extra argument.
</p>
<hr>
<a name="perlreapi-Callbacks"></a>
<div class="header">
<p>
Next: <a href="#perlreapi-The-REGEXP-structure" accesskey="n" rel="next">perlreapi The REGEXP structure</a>, Previous: <a href="#perlreapi-DESCRIPTION" accesskey="p" rel="prev">perlreapi DESCRIPTION</a>, Up: <a href="#perlreapi" accesskey="u" rel="up">perlreapi</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Callbacks-1"></a>
<h3 class="section">59.3 Callbacks</h3>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#perlreapi-comp" accesskey="1">perlreapi comp</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#perlreapi-exec" accesskey="2">perlreapi exec</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#perlreapi-intuit" accesskey="3">perlreapi intuit</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#perlreapi-checkstr" accesskey="4">perlreapi checkstr</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#perlreapi-free" accesskey="5">perlreapi free</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#perlreapi-Numbered-capture-callbacks" accesskey="6">perlreapi Numbered capture callbacks</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#perlreapi-Named-capture-callbacks" accesskey="7">perlreapi Named capture callbacks</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#perlreapi-qr_005fpackage" accesskey="8">perlreapi qr_package</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#perlreapi-dupe" accesskey="9">perlreapi dupe</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#perlreapi-op_005fcomp">perlreapi op_comp</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="perlreapi-comp"></a>
<div class="header">
<p>
Next: <a href="#perlreapi-exec" accesskey="n" rel="next">perlreapi exec</a>, Up: <a href="#perlreapi-Callbacks" accesskey="u" rel="up">perlreapi Callbacks</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="comp"></a>
<h4 class="subsection">59.3.1 comp</h4>

<pre class="verbatim">    REGEXP* comp(pTHX_ const SV * const pattern, const U32 flags);
</pre>
<p>Compile the pattern stored in <code>pattern</code> using the given <code>flags</code> and
return a pointer to a prepared <code>REGEXP</code> structure that can perform
the match.  See <a href="#perlreapi-The-REGEXP-structure">The REGEXP structure</a> below for an explanation of
the individual fields in the REGEXP struct.
</p>
<p>The <code>pattern</code> parameter is the scalar that was used as the
pattern.  Previous versions of Perl would pass two <code>char*</code> indicating
the start and end of the stringified pattern; the following snippet can
be used to get the old parameters:
</p>
<pre class="verbatim">    STRLEN plen;
    char*  exp = SvPV(pattern, plen);
    char* xend = exp + plen;
</pre>
<p>Since any scalar can be passed as a pattern, it&rsquo;s possible to implement
an engine that does something with an array (<code>&quot;ook&quot; =~ [ qw/ eek
hlagh / ]</code>) or with the non-stringified form of a compiled regular
expression (<code>&quot;ook&quot; =~ qr/eek/</code>).  Perl&rsquo;s own engine will always
stringify everything using the snippet above, but that doesn&rsquo;t mean
other engines have to.
</p>
<p>The <code>flags</code> parameter is a bitfield which indicates which of the
<code>msixp</code> flags the regex was compiled with.  It also contains
additional info, such as if <code>use locale</code> is in effect.
</p>
<p>The <code>eogc</code> flags are stripped out before being passed to the comp
routine.  The regex engine does not need to know if any of these
are set, as those flags should only affect what Perl does with the
pattern and its match variables, not how it gets compiled and
executed.
</p>
<p>By the time the comp callback is called, some of these flags have
already had effect (noted below where applicable).  However most of
their effect occurs after the comp callback has run, in routines that
read the <code>rx-&gt;extflags</code> field which it populates.
</p>
<p>In general the flags should be preserved in <code>rx-&gt;extflags</code> after
compilation, although the regex engine might want to add or delete
some of them to invoke or disable some special behavior in Perl.  The
flags along with any special behavior they cause are documented below:
</p>
<p>The pattern modifiers:
</p>
<dl compact="compact">
<dt><code>/m</code> - RXf_PMf_MULTILINE</dt>
<dd><a name="perlreapi-_002fm-_002d-RXf_005fPMf_005fMULTILINE"></a>
<p>If this is in <code>rx-&gt;extflags</code> it will be passed to
<code>Perl_fbm_instr</code> by <code>pp_split</code> which will treat the subject string
as a multi-line string.
</p>
</dd>
<dt><code>/s</code> - RXf_PMf_SINGLELINE</dt>
<dd><a name="perlreapi-_002fs-_002d-RXf_005fPMf_005fSINGLELINE"></a>
</dd>
<dt><code>/i</code> - RXf_PMf_FOLD</dt>
<dd><a name="perlreapi-_002fi-_002d-RXf_005fPMf_005fFOLD"></a>
</dd>
<dt><code>/x</code> - RXf_PMf_EXTENDED</dt>
<dd><a name="perlreapi-_002fx-_002d-RXf_005fPMf_005fEXTENDED"></a>
<p>If present on a regex, <code>&quot;#&quot;</code> comments will be handled differently by the
tokenizer in some cases.
</p>
<p>TODO: Document those cases.
</p>
</dd>
<dt><code>/p</code> - RXf_PMf_KEEPCOPY</dt>
<dd><a name="perlreapi-_002fp-_002d-RXf_005fPMf_005fKEEPCOPY"></a>
<p>TODO: Document this
</p>
</dd>
<dt>Character set</dt>
<dd><a name="perlreapi-Character-set"></a>
<p>The character set semantics are determined by an enum that is contained
in this field.  This is still experimental and subject to change, but
the current interface returns the rules by use of the in-line function
<code>get_regex_charset(const U32 flags)</code>.  The only currently documented
value returned from it is REGEX_LOCALE_CHARSET, which is set if
<code>use locale</code> is in effect. If present in <code>rx-&gt;extflags</code>,
<code>split</code> will use the locale dependent definition of whitespace
when RXf_SKIPWHITE or RXf_WHITE is in effect.  ASCII whitespace
is defined as per <a href="../perlapi/isSPACE.html#isSPACE">(perlapi)isSPACE</a>, and by the internal
macros <code>is_utf8_space</code> under UTF-8, and <code>isSPACE_LC</code> under <code>use
locale</code>.
</p>
</dd>
</dl>

<p>Additional flags:
</p>
<dl compact="compact">
<dt>RXf_SPLIT</dt>
<dd><a name="perlreapi-RXf_005fSPLIT"></a>
<p>This flag was removed in perl 5.18.0.  <code>split ' '</code> is now special-cased
solely in the parser.  RXf_SPLIT is still #defined, so you can test for it.
This is how it used to work:
</p>
<p>If <code>split</code> is invoked as <code>split ' '</code> or with no arguments (which
really means <code>split(' ', $_)</code>, see <a href="perlfunc.html#perlfunc-split">split</a>), Perl will
set this flag.  The regex engine can then check for it and set the
SKIPWHITE and WHITE extflags.  To do this, the Perl engine does:
</p>
<pre class="verbatim">    if (flags &amp; RXf_SPLIT &amp;&amp; r-&gt;prelen == 1 &amp;&amp; r-&gt;precomp[0] == ' ')
        r-&gt;extflags |= (RXf_SKIPWHITE|RXf_WHITE);
</pre>
</dd>
</dl>

<p>These flags can be set during compilation to enable optimizations in
the <code>split</code> operator.
</p>
<dl compact="compact">
<dt>RXf_SKIPWHITE</dt>
<dd><a name="perlreapi-RXf_005fSKIPWHITE"></a>
<p>This flag was removed in perl 5.18.0.  It is still #defined, so you can
set it, but doing so will have no effect.  This is how it used to work:
</p>
<p>If the flag is present in <code>rx-&gt;extflags</code> <code>split</code> will delete
whitespace from the start of the subject string before it&rsquo;s operated
on.  What is considered whitespace depends on if the subject is a
UTF-8 string and if the <code>RXf_PMf_LOCALE</code> flag is set.
</p>
<p>If RXf_WHITE is set in addition to this flag, <code>split</code> will behave like
<code>split &quot; &quot;</code> under the Perl engine.
</p>
</dd>
<dt>RXf_START_ONLY</dt>
<dd><a name="perlreapi-RXf_005fSTART_005fONLY"></a>
<p>Tells the split operator to split the target string on newlines
(<code>\n</code>) without invoking the regex engine.
</p>
<p>Perl&rsquo;s engine sets this if the pattern is <code>/^/</code> (<code>plen == 1 &amp;&amp; *exp
== '^'</code>), even under <code>/^/s</code>; see <a href="perlfunc.html#perlfunc-NAME">split</a>.  Of course a
different regex engine might want to use the same optimizations
with a different syntax.
</p>
</dd>
<dt>RXf_WHITE</dt>
<dd><a name="perlreapi-RXf_005fWHITE"></a>
<p>Tells the split operator to split the target string on whitespace
without invoking the regex engine.  The definition of whitespace varies
depending on if the target string is a UTF-8 string and on
if RXf_PMf_LOCALE is set.
</p>
<p>Perl&rsquo;s engine sets this flag if the pattern is <code>\s+</code>.
</p>
</dd>
<dt>RXf_NULL</dt>
<dd><a name="perlreapi-RXf_005fNULL"></a>
<p>Tells the split operator to split the target string on
characters.  The definition of character varies depending on if
the target string is a UTF-8 string.
</p>
<p>Perl&rsquo;s engine sets this flag on empty patterns, this optimization
makes <code>split //</code> much faster than it would otherwise be.  It&rsquo;s even
faster than <code>unpack</code>.
</p>
</dd>
<dt>RXf_NO_INPLACE_SUBST</dt>
<dd><a name="perlreapi-RXf_005fNO_005fINPLACE_005fSUBST"></a>
<p>Added in perl 5.18.0, this flag indicates that a regular expression might
perform an operation that would interfere with inplace substituion. For
instance it might contain lookbehind, or assign to non-magical variables
(such as $REGMARK and $REGERROR) during matching.  <code>s///</code> will skip
certain optimisations when this is set.
</p>
</dd>
</dl>

<hr>
<a name="perlreapi-exec"></a>
<div class="header">
<p>
Next: <a href="#perlreapi-intuit" accesskey="n" rel="next">perlreapi intuit</a>, Previous: <a href="#perlreapi-comp" accesskey="p" rel="prev">perlreapi comp</a>, Up: <a href="#perlreapi-Callbacks" accesskey="u" rel="up">perlreapi Callbacks</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="exec"></a>
<h4 class="subsection">59.3.2 exec</h4>

<pre class="verbatim">    I32 exec(pTHX_ REGEXP * const rx,
             char *stringarg, char* strend, char* strbeg,
             I32 minend, SV* screamer,
             void* data, U32 flags);
</pre>
<p>Execute a regexp. The arguments are
</p>
<dl compact="compact">
<dt>rx</dt>
<dd><a name="perlreapi-rx"></a>
<p>The regular expression to execute.
</p>
</dd>
<dt>screamer</dt>
<dd><a name="perlreapi-screamer"></a>
<p>This strangely-named arg is the SV to be matched against.  Note that the
actual char array to be matched against is supplied by the arguments
described below; the SV is just used to determine UTF8ness, <code>pos()</code> etc.
</p>
</dd>
<dt>strbeg</dt>
<dd><a name="perlreapi-strbeg"></a>
<p>Pointer to the physical start of the string.
</p>
</dd>
<dt>strend</dt>
<dd><a name="perlreapi-strend"></a>
<p>Pointer to the character following the physical end of the string (i.e.
the <code>\0</code>).
</p>
</dd>
<dt>stringarg</dt>
<dd><a name="perlreapi-stringarg"></a>
<p>Pointer to the position in the string where matching should start; it might
not be equal to <code>strbeg</code> (for example in a later iteration of <code>/.../g</code>).
</p>
</dd>
<dt>minend</dt>
<dd><a name="perlreapi-minend"></a>
<p>Minimum length of string (measured in bytes from <code>stringarg</code>) that must
match; if the engine reaches the end of the match but hasn&rsquo;t reached this
position in the string, it should fail.
</p>
</dd>
<dt>data</dt>
<dd><a name="perlreapi-data"></a>
<p>Optimisation data; subject to change.
</p>
</dd>
<dt>flags</dt>
<dd><a name="perlreapi-flags"></a>
<p>Optimisation flags; subject to change.
</p>
</dd>
</dl>

<hr>
<a name="perlreapi-intuit"></a>
<div class="header">
<p>
Next: <a href="#perlreapi-checkstr" accesskey="n" rel="next">perlreapi checkstr</a>, Previous: <a href="#perlreapi-exec" accesskey="p" rel="prev">perlreapi exec</a>, Up: <a href="#perlreapi-Callbacks" accesskey="u" rel="up">perlreapi Callbacks</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="intuit"></a>
<h4 class="subsection">59.3.3 intuit</h4>

<pre class="verbatim">    char* intuit(pTHX_ REGEXP * const rx,
                  SV *sv, char *strpos, char *strend,
                  const U32 flags, struct re_scream_pos_data_s *data);
</pre>
<p>Find the start position where a regex match should be attempted,
or possibly if the regex engine should not be run because the
pattern can&rsquo;t match.  This is called, as appropriate, by the core,
depending on the values of the <code>extflags</code> member of the <code>regexp</code>
structure.
</p>
<hr>
<a name="perlreapi-checkstr"></a>
<div class="header">
<p>
Next: <a href="#perlreapi-free" accesskey="n" rel="next">perlreapi free</a>, Previous: <a href="#perlreapi-intuit" accesskey="p" rel="prev">perlreapi intuit</a>, Up: <a href="#perlreapi-Callbacks" accesskey="u" rel="up">perlreapi Callbacks</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="checkstr"></a>
<h4 class="subsection">59.3.4 checkstr</h4>

<pre class="verbatim">    SV* checkstr(pTHX_ REGEXP * const rx);
</pre>
<p>Return a SV containing a string that must appear in the pattern. Used
by <code>split</code> for optimising matches.
</p>
<hr>
<a name="perlreapi-free"></a>
<div class="header">
<p>
Next: <a href="#perlreapi-Numbered-capture-callbacks" accesskey="n" rel="next">perlreapi Numbered capture callbacks</a>, Previous: <a href="#perlreapi-checkstr" accesskey="p" rel="prev">perlreapi checkstr</a>, Up: <a href="#perlreapi-Callbacks" accesskey="u" rel="up">perlreapi Callbacks</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="free"></a>
<h4 class="subsection">59.3.5 free</h4>

<pre class="verbatim">    void free(pTHX_ REGEXP * const rx);
</pre>
<p>Called by Perl when it is freeing a regexp pattern so that the engine
can release any resources pointed to by the <code>pprivate</code> member of the
<code>regexp</code> structure.  This is only responsible for freeing private data;
Perl will handle releasing anything else contained in the <code>regexp</code> structure.
</p>
<hr>
<a name="perlreapi-Numbered-capture-callbacks"></a>
<div class="header">
<p>
Next: <a href="#perlreapi-Named-capture-callbacks" accesskey="n" rel="next">perlreapi Named capture callbacks</a>, Previous: <a href="#perlreapi-free" accesskey="p" rel="prev">perlreapi free</a>, Up: <a href="#perlreapi-Callbacks" accesskey="u" rel="up">perlreapi Callbacks</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Numbered-capture-callbacks"></a>
<h4 class="subsection">59.3.6 Numbered capture callbacks</h4>

<p>Called to get/set the value of <code>$`</code>, <code>$'</code>, <code>$&amp;</code> and their named
equivalents, ${^PREMATCH}, ${^POSTMATCH} and $^{MATCH}, as well as the
numbered capture groups (<code>$1</code>, <code>$2</code>, ...).
</p>
<p>The <code>paren</code> parameter will be <code>1</code> for <code>$1</code>, <code>2</code> for <code>$2</code> and so
forth, and have these symbolic values for the special variables:
</p>
<pre class="verbatim">    ${^PREMATCH}  RX_BUFF_IDX_CARET_PREMATCH
    ${^POSTMATCH} RX_BUFF_IDX_CARET_POSTMATCH
    ${^MATCH}     RX_BUFF_IDX_CARET_FULLMATCH
    $`            RX_BUFF_IDX_PREMATCH
    $'            RX_BUFF_IDX_POSTMATCH
    $&amp;            RX_BUFF_IDX_FULLMATCH
</pre>
<p>Note that in Perl 5.17.3 and earlier, the last three constants were also
used for the caret variants of the variables.
</p>
<p>The names have been chosen by analogy with <a href="../Tie-Scalar/index.html">(Tie-Scalar)</a> methods
names with an additional <strong>LENGTH</strong> callback for efficiency.  However
named capture variables are currently not tied internally but
implemented via magic.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#perlreapi-numbered_005fbuff_005fFETCH" accesskey="1">perlreapi numbered_buff_FETCH</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#perlreapi-numbered_005fbuff_005fSTORE" accesskey="2">perlreapi numbered_buff_STORE</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#perlreapi-numbered_005fbuff_005fLENGTH" accesskey="3">perlreapi numbered_buff_LENGTH</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="perlreapi-numbered_005fbuff_005fFETCH"></a>
<div class="header">
<p>
Next: <a href="#perlreapi-numbered_005fbuff_005fSTORE" accesskey="n" rel="next">perlreapi numbered_buff_STORE</a>, Up: <a href="#perlreapi-Numbered-capture-callbacks" accesskey="u" rel="up">perlreapi Numbered capture callbacks</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="numbered_005fbuff_005fFETCH"></a>
<h4 class="subsubsection">59.3.6.1 numbered_buff_FETCH</h4>

<pre class="verbatim">    void numbered_buff_FETCH(pTHX_ REGEXP * const rx, const I32 paren,
                             SV * const sv);
</pre>
<p>Fetch a specified numbered capture.  <code>sv</code> should be set to the scalar
to return, the scalar is passed as an argument rather than being
returned from the function because when it&rsquo;s called Perl already has a
scalar to store the value, creating another one would be
redundant.  The scalar can be set with <code>sv_setsv</code>, <code>sv_setpvn</code> and
friends, see <a href="../perlapi/index.html">(perlapi)</a>.
</p>
<p>This callback is where Perl untaints its own capture variables under
taint mode (see <a href="perlsec.html#perlsec-NAME">perlsec NAME</a>).  See the <code>Perl_reg_numbered_buff_fetch</code>
function in <samp>regcomp.c</samp> for how to untaint capture variables if
that&rsquo;s something you&rsquo;d like your engine to do as well.
</p>
<hr>
<a name="perlreapi-numbered_005fbuff_005fSTORE"></a>
<div class="header">
<p>
Next: <a href="#perlreapi-numbered_005fbuff_005fLENGTH" accesskey="n" rel="next">perlreapi numbered_buff_LENGTH</a>, Previous: <a href="#perlreapi-numbered_005fbuff_005fFETCH" accesskey="p" rel="prev">perlreapi numbered_buff_FETCH</a>, Up: <a href="#perlreapi-Numbered-capture-callbacks" accesskey="u" rel="up">perlreapi Numbered capture callbacks</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="numbered_005fbuff_005fSTORE"></a>
<h4 class="subsubsection">59.3.6.2 numbered_buff_STORE</h4>

<pre class="verbatim">    void    (*numbered_buff_STORE) (pTHX_
                                    REGEXP * const rx,
                                    const I32 paren,
                                    SV const * const value);
</pre>
<p>Set the value of a numbered capture variable.  <code>value</code> is the scalar
that is to be used as the new value.  It&rsquo;s up to the engine to make
sure this is used as the new value (or reject it).
</p>
<p>Example:
</p>
<pre class="verbatim">    if (&quot;ook&quot; =~ /(o*)/) {
        # 'paren' will be '1' and 'value' will be 'ee'
        $1 =~ tr/o/e/;
    }
</pre>
<p>Perl&rsquo;s own engine will croak on any attempt to modify the capture
variables, to do this in another engine use the following callback
(copied from <code>Perl_reg_numbered_buff_store</code>):
</p>
<pre class="verbatim">    void
    Example_reg_numbered_buff_store(pTHX_
                                    REGEXP * const rx,
                                    const I32 paren,
                                    SV const * const value)
    {
        PERL_UNUSED_ARG(rx);
        PERL_UNUSED_ARG(paren);
        PERL_UNUSED_ARG(value);

        if (!PL_localizing)
            Perl_croak(aTHX_ PL_no_modify);
    }
</pre>
<p>Actually Perl will not <em>always</em> croak in a statement that looks
like it would modify a numbered capture variable.  This is because the
STORE callback will not be called if Perl can determine that it
doesn&rsquo;t have to modify the value.  This is exactly how tied variables
behave in the same situation:
</p>
<pre class="verbatim">    package CaptureVar;
    use base 'Tie::Scalar';

    sub TIESCALAR { bless [] }
    sub FETCH { undef }
    sub STORE { die &quot;This doesn't get called&quot; }

    package main;

    tie my $sv =&gt; &quot;CaptureVar&quot;;
    $sv =~ y/a/b/;
</pre>
<p>Because <code>$sv</code> is <code>undef</code> when the <code>y///</code> operator is applied to it,
the transliteration won&rsquo;t actually execute and the program won&rsquo;t
<code>die</code>.  This is different to how 5.8 and earlier versions behaved
since the capture variables were READONLY variables then; now they&rsquo;ll
just die when assigned to in the default engine.
</p>
<hr>
<a name="perlreapi-numbered_005fbuff_005fLENGTH"></a>
<div class="header">
<p>
Previous: <a href="#perlreapi-numbered_005fbuff_005fSTORE" accesskey="p" rel="prev">perlreapi numbered_buff_STORE</a>, Up: <a href="#perlreapi-Numbered-capture-callbacks" accesskey="u" rel="up">perlreapi Numbered capture callbacks</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="numbered_005fbuff_005fLENGTH"></a>
<h4 class="subsubsection">59.3.6.3 numbered_buff_LENGTH</h4>

<pre class="verbatim">    I32 numbered_buff_LENGTH (pTHX_
                              REGEXP * const rx,
                              const SV * const sv,
                              const I32 paren);
</pre>
<p>Get the <code>length</code> of a capture variable.  There&rsquo;s a special callback
for this so that Perl doesn&rsquo;t have to do a FETCH and run <code>length</code> on
the result, since the length is (in Perl&rsquo;s case) known from an offset
stored in <code>rx-&gt;offs</code>, this is much more efficient:
</p>
<pre class="verbatim">    I32 s1  = rx-&gt;offs[paren].start;
    I32 s2  = rx-&gt;offs[paren].end;
    I32 len = t1 - s1;
</pre>
<p>This is a little bit more complex in the case of UTF-8, see what
<code>Perl_reg_numbered_buff_length</code> does with
<a href="../perlapi/is_005futf8_005fstring_005floclen.html#is_005futf8_005fstring_005floclen">(perlapi)is_utf8_string_loclen</a>.
</p>
<hr>
<a name="perlreapi-Named-capture-callbacks"></a>
<div class="header">
<p>
Next: <a href="#perlreapi-qr_005fpackage" accesskey="n" rel="next">perlreapi qr_package</a>, Previous: <a href="#perlreapi-Numbered-capture-callbacks" accesskey="p" rel="prev">perlreapi Numbered capture callbacks</a>, Up: <a href="#perlreapi-Callbacks" accesskey="u" rel="up">perlreapi Callbacks</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Named-capture-callbacks"></a>
<h4 class="subsection">59.3.7 Named capture callbacks</h4>

<p>Called to get/set the value of <code>%+</code> and <code>%-</code>, as well as by some
utility functions in <a href="../re/index.html">(re)</a>.
</p>
<p>There are two callbacks, <code>named_buff</code> is called in all the cases the
FETCH, STORE, DELETE, CLEAR, EXISTS and SCALAR <a href="../Tie-Hash/index.html">(Tie-Hash)</a> callbacks
would be on changes to <code>%+</code> and <code>%-</code> and <code>named_buff_iter</code> in the
same cases as FIRSTKEY and NEXTKEY.
</p>
<p>The <code>flags</code> parameter can be used to determine which of these
operations the callbacks should respond to.  The following flags are
currently defined:
</p>
<p>Which <a href="../Tie-Hash/index.html">(Tie-Hash)</a> operation is being performed from the Perl level on
<code>%+</code> or <code>%+</code>, if any:
</p>
<pre class="verbatim">    RXapif_FETCH
    RXapif_STORE
    RXapif_DELETE
    RXapif_CLEAR
    RXapif_EXISTS
    RXapif_SCALAR
    RXapif_FIRSTKEY
    RXapif_NEXTKEY
</pre>
<p>If <code>%+</code> or <code>%-</code> is being operated on, if any.
</p>
<pre class="verbatim">    RXapif_ONE /* %+ */
    RXapif_ALL /* %- */
</pre>
<p>If this is being called as <code>re::regname</code>, <code>re::regnames</code> or
<code>re::regnames_count</code>, if any.  The first two will be combined with
<code>RXapif_ONE</code> or <code>RXapif_ALL</code>.
</p>
<pre class="verbatim">    RXapif_REGNAME
    RXapif_REGNAMES
    RXapif_REGNAMES_COUNT
</pre>
<p>Internally <code>%+</code> and <code>%-</code> are implemented with a real tied interface
via <a href="../Tie-Hash-NamedCapture/index.html">(Tie-Hash-NamedCapture)</a>.  The methods in that package will call
back into these functions.  However the usage of
<a href="../Tie-Hash-NamedCapture/index.html">(Tie-Hash-NamedCapture)</a> for this purpose might change in future
releases.  For instance this might be implemented by magic instead
(would need an extension to mgvtbl).
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#perlreapi-named_005fbuff" accesskey="1">perlreapi named_buff</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#perlreapi-named_005fbuff_005fiter" accesskey="2">perlreapi named_buff_iter</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="perlreapi-named_005fbuff"></a>
<div class="header">
<p>
Next: <a href="#perlreapi-named_005fbuff_005fiter" accesskey="n" rel="next">perlreapi named_buff_iter</a>, Up: <a href="#perlreapi-Named-capture-callbacks" accesskey="u" rel="up">perlreapi Named capture callbacks</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="named_005fbuff"></a>
<h4 class="subsubsection">59.3.7.1 named_buff</h4>

<pre class="verbatim">    SV*     (*named_buff) (pTHX_ REGEXP * const rx, SV * const key,
                           SV * const value, U32 flags);
</pre>
<hr>
<a name="perlreapi-named_005fbuff_005fiter"></a>
<div class="header">
<p>
Previous: <a href="#perlreapi-named_005fbuff" accesskey="p" rel="prev">perlreapi named_buff</a>, Up: <a href="#perlreapi-Named-capture-callbacks" accesskey="u" rel="up">perlreapi Named capture callbacks</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="named_005fbuff_005fiter"></a>
<h4 class="subsubsection">59.3.7.2 named_buff_iter</h4>

<pre class="verbatim">    SV*     (*named_buff_iter) (pTHX_
                                REGEXP * const rx,
                                const SV * const lastkey,
                                const U32 flags);
</pre>
<hr>
<a name="perlreapi-qr_005fpackage"></a>
<div class="header">
<p>
Next: <a href="#perlreapi-dupe" accesskey="n" rel="next">perlreapi dupe</a>, Previous: <a href="#perlreapi-Named-capture-callbacks" accesskey="p" rel="prev">perlreapi Named capture callbacks</a>, Up: <a href="#perlreapi-Callbacks" accesskey="u" rel="up">perlreapi Callbacks</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="qr_005fpackage"></a>
<h4 class="subsection">59.3.8 qr_package</h4>

<pre class="verbatim">    SV* qr_package(pTHX_ REGEXP * const rx);
</pre>
<p>The package the qr// magic object is blessed into (as seen by <code>ref
qr//</code>).  It is recommended that engines change this to their package
name for identification regardless of if they implement methods
on the object.
</p>
<p>The package this method returns should also have the internal
<code>Regexp</code> package in its <code>@ISA</code>.  <code>qr//-&gt;isa(&quot;Regexp&quot;)</code> should always
be true regardless of what engine is being used.
</p>
<p>Example implementation might be:
</p>
<pre class="verbatim">    SV*
    Example_qr_package(pTHX_ REGEXP * const rx)
    {
        PERL_UNUSED_ARG(rx);
        return newSVpvs(&quot;re::engine::Example&quot;);
    }
</pre>
<p>Any method calls on an object created with <code>qr//</code> will be dispatched to the
package as a normal object.
</p>
<pre class="verbatim">    use re::engine::Example;
    my $re = qr//;
    $re-&gt;meth; # dispatched to re::engine::Example::meth()
</pre>
<p>To retrieve the <code>REGEXP</code> object from the scalar in an XS function use
the <code>SvRX</code> macro, see <a href="../perlapi/REGEXP-Functions.html#REGEXP-Functions">(perlapi)&quot;REGEXP Functions&quot; in perlapi</a>.
</p>
<pre class="verbatim">    void meth(SV * rv)
    PPCODE:
        REGEXP * re = SvRX(sv);
</pre>
<hr>
<a name="perlreapi-dupe"></a>
<div class="header">
<p>
Next: <a href="#perlreapi-op_005fcomp" accesskey="n" rel="next">perlreapi op_comp</a>, Previous: <a href="#perlreapi-qr_005fpackage" accesskey="p" rel="prev">perlreapi qr_package</a>, Up: <a href="#perlreapi-Callbacks" accesskey="u" rel="up">perlreapi Callbacks</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="dupe"></a>
<h4 class="subsection">59.3.9 dupe</h4>

<pre class="verbatim">    void* dupe(pTHX_ REGEXP * const rx, CLONE_PARAMS *param);
</pre>
<p>On threaded builds a regexp may need to be duplicated so that the pattern
can be used by multiple threads.  This routine is expected to handle the
duplication of any private data pointed to by the <code>pprivate</code> member of
the <code>regexp</code> structure.  It will be called with the preconstructed new
<code>regexp</code> structure as an argument, the <code>pprivate</code> member will point at
the <strong>old</strong> private structure, and it is this routine&rsquo;s responsibility to
construct a copy and return a pointer to it (which Perl will then use to
overwrite the field as passed to this routine.)
</p>
<p>This allows the engine to dupe its private data but also if necessary
modify the final structure if it really must.
</p>
<p>On unthreaded builds this field doesn&rsquo;t exist.
</p>
<hr>
<a name="perlreapi-op_005fcomp"></a>
<div class="header">
<p>
Previous: <a href="#perlreapi-dupe" accesskey="p" rel="prev">perlreapi dupe</a>, Up: <a href="#perlreapi-Callbacks" accesskey="u" rel="up">perlreapi Callbacks</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="op_005fcomp"></a>
<h4 class="subsection">59.3.10 op_comp</h4>

<p>This is private to the Perl core and subject to change. Should be left
null.
</p>
<hr>
<a name="perlreapi-The-REGEXP-structure"></a>
<div class="header">
<p>
Next: <a href="#perlreapi-HISTORY" accesskey="n" rel="next">perlreapi HISTORY</a>, Previous: <a href="#perlreapi-Callbacks" accesskey="p" rel="prev">perlreapi Callbacks</a>, Up: <a href="#perlreapi" accesskey="u" rel="up">perlreapi</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="The-REGEXP-structure"></a>
<h3 class="section">59.4 The REGEXP structure</h3>

<p>The REGEXP struct is defined in <samp>regexp.h</samp>.
All regex engines must be able to
correctly build such a structure in their <a href="#perlreapi-comp">comp</a> routine.
</p>
<p>The REGEXP structure contains all the data that Perl needs to be aware of
to properly work with the regular expression.  It includes data about
optimisations that Perl can use to determine if the regex engine should
really be used, and various other control info that is needed to properly
execute patterns in various contexts, such as if the pattern anchored in
some way, or what flags were used during the compile, or if the
program contains special constructs that Perl needs to be aware of.
</p>
<p>In addition it contains two fields that are intended for the private
use of the regex engine that compiled the pattern.  These are the
<code>intflags</code> and <code>pprivate</code> members.  <code>pprivate</code> is a void pointer to
an arbitrary structure, whose use and management is the responsibility
of the compiling engine.  Perl will never modify either of these
values.
</p>
<pre class="verbatim">    typedef struct regexp {
        /* what engine created this regexp? */
        const struct regexp_engine* engine;

        /* what re is this a lightweight copy of? */
        struct regexp* mother_re;

        /* Information about the match that the Perl core uses to manage
         * things */
        U32 extflags;   /* Flags used both externally and internally */
        I32 minlen;     /* mininum possible number of chars in */
                           string to match */
        I32 minlenret;  /* mininum possible number of chars in $&amp; */
        U32 gofs;       /* chars left of pos that we search from */

        /* substring data about strings that must appear
           in the final match, used for optimisations */
        struct reg_substr_data *substrs;

        U32 nparens;  /* number of capture groups */

        /* private engine specific data */
        U32 intflags;   /* Engine Specific Internal flags */
        void *pprivate; /* Data private to the regex engine which 
                           created this object. */

        /* Data about the last/current match. These are modified during
         * matching*/
        U32 lastparen;            /* highest close paren matched ($+) */
        U32 lastcloseparen;       /* last close paren matched ($^N) */
        regexp_paren_pair *swap;  /* Swap copy of *offs */
        regexp_paren_pair *offs;  /* Array of offsets for (@-) and
                                     (@+) */

        char *subbeg;  /* saved or original string so \digit works
                          forever. */
        SV_SAVED_COPY  /* If non-NULL, SV which is COW from original */
        I32 sublen;    /* Length of string pointed by subbeg */
        I32 suboffset;  /* byte offset of subbeg from logical start of
                           str */
        I32 subcoffset; /* suboffset equiv, but in chars (for @-/@+) */

        /* Information about the match that isn't often used */
        I32 prelen;           /* length of precomp */
        const char *precomp;  /* pre-compilation regular expression */

        char *wrapped;  /* wrapped version of the pattern */
        I32 wraplen;    /* length of wrapped */

        I32 seen_evals;   /* number of eval groups in the pattern - for
                             security checks */
        HV *paren_names;  /* Optional hash of paren names */

        /* Refcount of this regexp */
        I32 refcnt;             /* Refcount of this regexp */
    } regexp;
</pre>
<p>The fields are discussed in more detail below:
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#perlreapi-engine" accesskey="1">perlreapi <code>engine</code></a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#perlreapi-mother_005fre" accesskey="2">perlreapi <code>mother_re</code></a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#perlreapi-extflags" accesskey="3">perlreapi <code>extflags</code></a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#perlreapi-minlen-minlenret" accesskey="4">perlreapi <code>minlen</code> <code>minlenret</code></a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#perlreapi-gofs" accesskey="5">perlreapi <code>gofs</code></a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#perlreapi-substrs" accesskey="6">perlreapi <code>substrs</code></a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#perlreapi-nparens_002c-lastparen_002c-and-lastcloseparen" accesskey="7">perlreapi <code>nparens</code>, <code>lastparen</code>, and <code>lastcloseparen</code></a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#perlreapi-intflags" accesskey="8">perlreapi <code>intflags</code></a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#perlreapi-pprivate" accesskey="9">perlreapi <code>pprivate</code></a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#perlreapi-swap">perlreapi <code>swap</code></a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#perlreapi-offs">perlreapi <code>offs</code></a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#perlreapi-precomp-prelen">perlreapi <code>precomp</code> <code>prelen</code></a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#perlreapi-paren_005fnames">perlreapi <code>paren_names</code></a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#perlreapi-substrs-1">perlreapi <code>substrs</code> 1</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#perlreapi-subbeg-sublen-saved_005fcopy-suboffset-subcoffset">perlreapi <code>subbeg</code> <code>sublen</code> <code>saved_copy</code> <code>suboffset</code> <code>subcoffset</code></a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#perlreapi-wrapped-wraplen">perlreapi <code>wrapped</code> <code>wraplen</code></a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#perlreapi-seen_005fevals">perlreapi <code>seen_evals</code></a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#perlreapi-refcnt">perlreapi <code>refcnt</code></a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="perlreapi-engine"></a>
<div class="header">
<p>
Next: <a href="#perlreapi-mother_005fre" accesskey="n" rel="next">perlreapi <code>mother_re</code></a>, Up: <a href="#perlreapi-The-REGEXP-structure" accesskey="u" rel="up">perlreapi The REGEXP structure</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="engine"></a>
<h4 class="subsection">59.4.1 <code>engine</code></h4>

<p>This field points at a <code>regexp_engine</code> structure which contains pointers
to the subroutines that are to be used for performing a match.  It
is the compiling routine&rsquo;s responsibility to populate this field before
returning the regexp object.
</p>
<p>Internally this is set to <code>NULL</code> unless a custom engine is specified in
<code>$^H{regcomp}</code>, Perl&rsquo;s own set of callbacks can be accessed in the struct
pointed to by <code>RE_ENGINE_PTR</code>.
</p>
<hr>
<a name="perlreapi-mother_005fre"></a>
<div class="header">
<p>
Next: <a href="#perlreapi-extflags" accesskey="n" rel="next">perlreapi <code>extflags</code></a>, Previous: <a href="#perlreapi-engine" accesskey="p" rel="prev">perlreapi <code>engine</code></a>, Up: <a href="#perlreapi-The-REGEXP-structure" accesskey="u" rel="up">perlreapi The REGEXP structure</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="mother_005fre"></a>
<h4 class="subsection">59.4.2 <code>mother_re</code></h4>

<p>TODO, see <a href="http://www.mail-archive.com/perl5-changes@perl.org/msg17328.html">http://www.mail-archive.com/perl5-changes@perl.org/msg17328.html</a>
</p>
<hr>
<a name="perlreapi-extflags"></a>
<div class="header">
<p>
Next: <a href="#perlreapi-minlen-minlenret" accesskey="n" rel="next">perlreapi <code>minlen</code> <code>minlenret</code></a>, Previous: <a href="#perlreapi-mother_005fre" accesskey="p" rel="prev">perlreapi <code>mother_re</code></a>, Up: <a href="#perlreapi-The-REGEXP-structure" accesskey="u" rel="up">perlreapi The REGEXP structure</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="extflags"></a>
<h4 class="subsection">59.4.3 <code>extflags</code></h4>

<p>This will be used by Perl to see what flags the regexp was compiled
with, this will normally be set to the value of the flags parameter by
the <a href="#perlreapi-comp">comp</a> callback.  See the <a href="#perlreapi-comp">comp</a> documentation for
valid flags.
</p>
<hr>
<a name="perlreapi-minlen-minlenret"></a>
<div class="header">
<p>
Next: <a href="#perlreapi-gofs" accesskey="n" rel="next">perlreapi <code>gofs</code></a>, Previous: <a href="#perlreapi-extflags" accesskey="p" rel="prev">perlreapi <code>extflags</code></a>, Up: <a href="#perlreapi-The-REGEXP-structure" accesskey="u" rel="up">perlreapi The REGEXP structure</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="minlen-minlenret"></a>
<h4 class="subsection">59.4.4 <code>minlen</code> <code>minlenret</code></h4>

<p>The minimum string length (in characters) required for the pattern to match.
This is used to
prune the search space by not bothering to match any closer to the end of a
string than would allow a match.  For instance there is no point in even
starting the regex engine if the minlen is 10 but the string is only 5
characters long.  There is no way that the pattern can match.
</p>
<p><code>minlenret</code> is the minimum length (in characters) of the string that would
be found in $&amp; after a match.
</p>
<p>The difference between <code>minlen</code> and <code>minlenret</code> can be seen in the
following pattern:
</p>
<pre class="verbatim">    /ns(?=\d)/
</pre>
<p>where the <code>minlen</code> would be 3 but <code>minlenret</code> would only be 2 as the \d is
required to match but is not actually
included in the matched content.  This
distinction is particularly important as the substitution logic uses the
<code>minlenret</code> to tell if it can do in-place substitutions (these can
result in considerable speed-up).
</p>
<hr>
<a name="perlreapi-gofs"></a>
<div class="header">
<p>
Next: <a href="#perlreapi-substrs" accesskey="n" rel="next">perlreapi <code>substrs</code></a>, Previous: <a href="#perlreapi-minlen-minlenret" accesskey="p" rel="prev">perlreapi <code>minlen</code> <code>minlenret</code></a>, Up: <a href="#perlreapi-The-REGEXP-structure" accesskey="u" rel="up">perlreapi The REGEXP structure</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="gofs"></a>
<h4 class="subsection">59.4.5 <code>gofs</code></h4>

<p>Left offset from pos() to start match at.
</p>
<hr>
<a name="perlreapi-substrs"></a>
<div class="header">
<p>
Next: <a href="#perlreapi-nparens_002c-lastparen_002c-and-lastcloseparen" accesskey="n" rel="next">perlreapi <code>nparens</code>, <code>lastparen</code>, and <code>lastcloseparen</code></a>, Previous: <a href="#perlreapi-gofs" accesskey="p" rel="prev">perlreapi <code>gofs</code></a>, Up: <a href="#perlreapi-The-REGEXP-structure" accesskey="u" rel="up">perlreapi The REGEXP structure</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="substrs"></a>
<h4 class="subsection">59.4.6 <code>substrs</code></h4>

<p>Substring data about strings that must appear in the final match.  This
is currently only used internally by Perl&rsquo;s engine, but might be
used in the future for all engines for optimisations.
</p>
<hr>
<a name="perlreapi-nparens_002c-lastparen_002c-and-lastcloseparen"></a>
<div class="header">
<p>
Next: <a href="#perlreapi-intflags" accesskey="n" rel="next">perlreapi <code>intflags</code></a>, Previous: <a href="#perlreapi-substrs" accesskey="p" rel="prev">perlreapi <code>substrs</code></a>, Up: <a href="#perlreapi-The-REGEXP-structure" accesskey="u" rel="up">perlreapi The REGEXP structure</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="nparens_002c-lastparen_002c-and-lastcloseparen"></a>
<h4 class="subsection">59.4.7 <code>nparens</code>, <code>lastparen</code>, and <code>lastcloseparen</code></h4>

<p>These fields are used to keep track of how many paren groups could be matched
in the pattern, which was the last open paren to be entered, and which was
the last close paren to be entered.
</p>
<hr>
<a name="perlreapi-intflags"></a>
<div class="header">
<p>
Next: <a href="#perlreapi-pprivate" accesskey="n" rel="next">perlreapi <code>pprivate</code></a>, Previous: <a href="#perlreapi-nparens_002c-lastparen_002c-and-lastcloseparen" accesskey="p" rel="prev">perlreapi <code>nparens</code>, <code>lastparen</code>, and <code>lastcloseparen</code></a>, Up: <a href="#perlreapi-The-REGEXP-structure" accesskey="u" rel="up">perlreapi The REGEXP structure</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="intflags"></a>
<h4 class="subsection">59.4.8 <code>intflags</code></h4>

<p>The engine&rsquo;s private copy of the flags the pattern was compiled with. Usually
this is the same as <code>extflags</code> unless the engine chose to modify one of them.
</p>
<hr>
<a name="perlreapi-pprivate"></a>
<div class="header">
<p>
Next: <a href="#perlreapi-swap" accesskey="n" rel="next">perlreapi <code>swap</code></a>, Previous: <a href="#perlreapi-intflags" accesskey="p" rel="prev">perlreapi <code>intflags</code></a>, Up: <a href="#perlreapi-The-REGEXP-structure" accesskey="u" rel="up">perlreapi The REGEXP structure</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="pprivate"></a>
<h4 class="subsection">59.4.9 <code>pprivate</code></h4>

<p>A void* pointing to an engine-defined
data structure.  The Perl engine uses the
<code>regexp_internal</code> structure (see <a href="perlreguts.html#perlreguts-Base-Structures">perlreguts Base Structures</a>) but a custom
engine should use something else.
</p>
<hr>
<a name="perlreapi-swap"></a>
<div class="header">
<p>
Next: <a href="#perlreapi-offs" accesskey="n" rel="next">perlreapi <code>offs</code></a>, Previous: <a href="#perlreapi-pprivate" accesskey="p" rel="prev">perlreapi <code>pprivate</code></a>, Up: <a href="#perlreapi-The-REGEXP-structure" accesskey="u" rel="up">perlreapi The REGEXP structure</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="swap"></a>
<h4 class="subsection">59.4.10 <code>swap</code></h4>

<p>Unused.  Left in for compatibility with Perl 5.10.0.
</p>
<hr>
<a name="perlreapi-offs"></a>
<div class="header">
<p>
Next: <a href="#perlreapi-precomp-prelen" accesskey="n" rel="next">perlreapi <code>precomp</code> <code>prelen</code></a>, Previous: <a href="#perlreapi-swap" accesskey="p" rel="prev">perlreapi <code>swap</code></a>, Up: <a href="#perlreapi-The-REGEXP-structure" accesskey="u" rel="up">perlreapi The REGEXP structure</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="offs"></a>
<h4 class="subsection">59.4.11 <code>offs</code></h4>

<p>A <code>regexp_paren_pair</code> structure which defines offsets into the string being
matched which correspond to the <code>$&amp;</code> and <code>$1</code>, <code>$2</code> etc. captures, the
<code>regexp_paren_pair</code> struct is defined as follows:
</p>
<pre class="verbatim">    typedef struct regexp_paren_pair {
        I32 start;
        I32 end;
    } regexp_paren_pair;
</pre>
<p>If <code>-&gt;offs[num].start</code> or <code>-&gt;offs[num].end</code> is <code>-1</code> then that
capture group did not match.
<code>-&gt;offs[0].start/end</code> represents <code>$&amp;</code> (or
<code>${^MATCH}</code> under <code>//p</code>) and <code>-&gt;offs[paren].end</code> matches <code>$$paren</code> where
<code>$paren </code>= 1&gt;.
</p>
<hr>
<a name="perlreapi-precomp-prelen"></a>
<div class="header">
<p>
Next: <a href="#perlreapi-paren_005fnames" accesskey="n" rel="next">perlreapi <code>paren_names</code></a>, Previous: <a href="#perlreapi-offs" accesskey="p" rel="prev">perlreapi <code>offs</code></a>, Up: <a href="#perlreapi-The-REGEXP-structure" accesskey="u" rel="up">perlreapi The REGEXP structure</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="precomp-prelen"></a>
<h4 class="subsection">59.4.12 <code>precomp</code> <code>prelen</code></h4>

<p>Used for optimisations.  <code>precomp</code> holds a copy of the pattern that
was compiled and <code>prelen</code> its length.  When a new pattern is to be
compiled (such as inside a loop) the internal <code>regcomp</code> operator
checks if the last compiled <code>REGEXP</code>&rsquo;s <code>precomp</code> and <code>prelen</code>
are equivalent to the new one, and if so uses the old pattern instead
of compiling a new one.
</p>
<p>The relevant snippet from <code>Perl_pp_regcomp</code>:
</p>
<pre class="verbatim">        if (!re || !re-&gt;precomp || re-&gt;prelen != (I32)len ||
            memNE(re-&gt;precomp, t, len))
        /* Compile a new pattern */
</pre>
<hr>
<a name="perlreapi-paren_005fnames"></a>
<div class="header">
<p>
Next: <a href="#perlreapi-substrs-1" accesskey="n" rel="next">perlreapi <code>substrs</code> 1</a>, Previous: <a href="#perlreapi-precomp-prelen" accesskey="p" rel="prev">perlreapi <code>precomp</code> <code>prelen</code></a>, Up: <a href="#perlreapi-The-REGEXP-structure" accesskey="u" rel="up">perlreapi The REGEXP structure</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="paren_005fnames"></a>
<h4 class="subsection">59.4.13 <code>paren_names</code></h4>

<p>This is a hash used internally to track named capture groups and their
offsets.  The keys are the names of the buffers the values are dualvars,
with the IV slot holding the number of buffers with the given name and the
pv being an embedded array of I32.  The values may also be contained
independently in the data array in cases where named backreferences are
used.
</p>
<hr>
<a name="perlreapi-substrs-1"></a>
<div class="header">
<p>
Next: <a href="#perlreapi-subbeg-sublen-saved_005fcopy-suboffset-subcoffset" accesskey="n" rel="next">perlreapi <code>subbeg</code> <code>sublen</code> <code>saved_copy</code> <code>suboffset</code> <code>subcoffset</code></a>, Previous: <a href="#perlreapi-paren_005fnames" accesskey="p" rel="prev">perlreapi <code>paren_names</code></a>, Up: <a href="#perlreapi-The-REGEXP-structure" accesskey="u" rel="up">perlreapi The REGEXP structure</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="substrs-1"></a>
<h4 class="subsection">59.4.14 <code>substrs</code></h4>

<p>Holds information on the longest string that must occur at a fixed
offset from the start of the pattern, and the longest string that must
occur at a floating offset from the start of the pattern.  Used to do
Fast-Boyer-Moore searches on the string to find out if its worth using
the regex engine at all, and if so where in the string to search.
</p>
<hr>
<a name="perlreapi-subbeg-sublen-saved_005fcopy-suboffset-subcoffset"></a>
<div class="header">
<p>
Next: <a href="#perlreapi-wrapped-wraplen" accesskey="n" rel="next">perlreapi <code>wrapped</code> <code>wraplen</code></a>, Previous: <a href="#perlreapi-substrs-1" accesskey="p" rel="prev">perlreapi <code>substrs</code> 1</a>, Up: <a href="#perlreapi-The-REGEXP-structure" accesskey="u" rel="up">perlreapi The REGEXP structure</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="subbeg-sublen-saved_005fcopy-suboffset-subcoffset"></a>
<h4 class="subsection">59.4.15 <code>subbeg</code> <code>sublen</code> <code>saved_copy</code> <code>suboffset</code> <code>subcoffset</code></h4>

<p>Used during the execution phase for managing search and replace patterns,
and for providing the text for <code>$&amp;</code>, <code>$1</code> etc. <code>subbeg</code> points to a
buffer (either the original string, or a copy in the case of
<code>RX_MATCH_COPIED(rx)</code>), and <code>sublen</code> is the length of the buffer.  The
<code>RX_OFFS</code> start and end indices index into this buffer.
</p>
<p>In the presence of the <code>REXEC_COPY_STR</code> flag, but with the addition of
the <code>REXEC_COPY_SKIP_PRE</code> or <code>REXEC_COPY_SKIP_POST</code> flags, an engine
can choose not to copy the full buffer (although it must still do so in
the presence of <code>RXf_PMf_KEEPCOPY</code> or the relevant bits being set in
<code>PL_sawampersand</code>).  In this case, it may set <code>suboffset</code> to indicate the
number of bytes from the logical start of the buffer to the physical start
(i.e. <code>subbeg</code>).  It should also set <code>subcoffset</code>, the number of
characters in the offset. The latter is needed to support <code>@-</code> and <code>@+</code>
which work in characters, not bytes.
</p>
<hr>
<a name="perlreapi-wrapped-wraplen"></a>
<div class="header">
<p>
Next: <a href="#perlreapi-seen_005fevals" accesskey="n" rel="next">perlreapi <code>seen_evals</code></a>, Previous: <a href="#perlreapi-subbeg-sublen-saved_005fcopy-suboffset-subcoffset" accesskey="p" rel="prev">perlreapi <code>subbeg</code> <code>sublen</code> <code>saved_copy</code> <code>suboffset</code> <code>subcoffset</code></a>, Up: <a href="#perlreapi-The-REGEXP-structure" accesskey="u" rel="up">perlreapi The REGEXP structure</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="wrapped-wraplen"></a>
<h4 class="subsection">59.4.16 <code>wrapped</code> <code>wraplen</code></h4>

<p>Stores the string <code>qr//</code> stringifies to. The Perl engine for example
stores <code>(?^:eek)</code> in the case of <code>qr/eek/</code>.
</p>
<p>When using a custom engine that doesn&rsquo;t support the <code>(?:)</code> construct
for inline modifiers, it&rsquo;s probably best to have <code>qr//</code> stringify to
the supplied pattern, note that this will create undesired patterns in
cases such as:
</p>
<pre class="verbatim">    my $x = qr/a|b/;  # &quot;a|b&quot;
    my $y = qr/c/i;   # &quot;c&quot;
    my $z = qr/$x$y/; # &quot;a|bc&quot;
</pre>
<p>There&rsquo;s no solution for this problem other than making the custom
engine understand a construct like <code>(?:)</code>.
</p>
<hr>
<a name="perlreapi-seen_005fevals"></a>
<div class="header">
<p>
Next: <a href="#perlreapi-refcnt" accesskey="n" rel="next">perlreapi <code>refcnt</code></a>, Previous: <a href="#perlreapi-wrapped-wraplen" accesskey="p" rel="prev">perlreapi <code>wrapped</code> <code>wraplen</code></a>, Up: <a href="#perlreapi-The-REGEXP-structure" accesskey="u" rel="up">perlreapi The REGEXP structure</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="seen_005fevals"></a>
<h4 class="subsection">59.4.17 <code>seen_evals</code></h4>

<p>This stores the number of eval groups in
the pattern.  This is used for security
purposes when embedding compiled regexes into larger patterns with <code>qr//</code>.
</p>
<hr>
<a name="perlreapi-refcnt"></a>
<div class="header">
<p>
Previous: <a href="#perlreapi-seen_005fevals" accesskey="p" rel="prev">perlreapi <code>seen_evals</code></a>, Up: <a href="#perlreapi-The-REGEXP-structure" accesskey="u" rel="up">perlreapi The REGEXP structure</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="refcnt"></a>
<h4 class="subsection">59.4.18 <code>refcnt</code></h4>

<p>The number of times the structure is referenced.  When
this falls to 0, the regexp is automatically freed
by a call to pregfree.  This should be set to 1 in
each engine&rsquo;s <a href="#perlreapi-comp">comp</a> routine.
</p>
<hr>
<a name="perlreapi-HISTORY"></a>
<div class="header">
<p>
Next: <a href="#perlreapi-AUTHORS" accesskey="n" rel="next">perlreapi AUTHORS</a>, Previous: <a href="#perlreapi-The-REGEXP-structure" accesskey="p" rel="prev">perlreapi The REGEXP structure</a>, Up: <a href="#perlreapi" accesskey="u" rel="up">perlreapi</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="HISTORY-4"></a>
<h3 class="section">59.5 HISTORY</h3>

<p>Originally part of <a href="perlreguts.html#perlreguts-NAME">perlreguts NAME</a>.
</p>
<hr>
<a name="perlreapi-AUTHORS"></a>
<div class="header">
<p>
Next: <a href="#perlreapi-LICENSE" accesskey="n" rel="next">perlreapi LICENSE</a>, Previous: <a href="#perlreapi-HISTORY" accesskey="p" rel="prev">perlreapi HISTORY</a>, Up: <a href="#perlreapi" accesskey="u" rel="up">perlreapi</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="AUTHORS-4"></a>
<h3 class="section">59.6 AUTHORS</h3>

<p>Originally written by Yves Orton, expanded by Ãvar ArnfjÃ¶rÃ°
Bjarmason.
</p>
<hr>
<a name="perlreapi-LICENSE"></a>
<div class="header">
<p>
Previous: <a href="#perlreapi-AUTHORS" accesskey="p" rel="prev">perlreapi AUTHORS</a>, Up: <a href="#perlreapi" accesskey="u" rel="up">perlreapi</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="LICENSE-1"></a>
<h3 class="section">59.7 LICENSE</h3>

<p>Copyright 2006 Yves Orton and 2007 Ãvar ArnfjÃ¶rÃ° Bjarmason.
</p>
<p>This program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
</p>
<hr>
<div class="header">
<p>
Previous: <a href="#perlreapi-AUTHORS" accesskey="p" rel="prev">perlreapi AUTHORS</a>, Up: <a href="#perlreapi" accesskey="u" rel="up">perlreapi</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>



</body>
</html>
