<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by Texinfo 5.1.90+dev, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Perl pod documentation: perlrequick</title>

<meta name="description" content="Perl pod documentation: perlrequick">
<meta name="keywords" content="Perl pod documentation: perlrequick">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2any">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="index.html#Top" rel="start" title="Top">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="index.html#Top" rel="up" title="Top">
<link href="perlreref.html#perlreref" rel="next" title="perlreref">
<link href="perlreguts.html#perlreguts-REFERENCES" rel="prev" title="perlreguts REFERENCES">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.indentedblock {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smallindentedblock {margin-left: 3.2em; font-size: smaller}
div.smalllisp {margin-left: 3.2em}
kbd {font-style:oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nocodebreak {white-space:nowrap}
span.nolinebreak {white-space:nowrap}
span.roman {font-family:serif; font-weight:normal}
span.sansserif {font-family:sans-serif; font-weight:normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">
<a name="perlrequick"></a>
<div class="header">
<p>
Next: <a href="perlreref.html#perlreref" accesskey="n" rel="next">perlreref</a>, Previous: <a href="perlreguts.html#perlreguts" accesskey="p" rel="prev">perlreguts</a>, Up: <a href="index.html#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="perlrequick-1"></a>
<h2 class="chapter">65 perlrequick</h2>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#perlrequick-NAME" accesskey="1">perlrequick NAME</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#perlrequick-DESCRIPTION" accesskey="2">perlrequick DESCRIPTION</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#perlrequick-The-Guide" accesskey="3">perlrequick The Guide</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#perlrequick-BUGS" accesskey="4">perlrequick BUGS</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#perlrequick-SEE-ALSO" accesskey="5">perlrequick SEE ALSO</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#perlrequick-AUTHOR-AND-COPYRIGHT" accesskey="6">perlrequick AUTHOR AND COPYRIGHT</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="perlrequick-NAME"></a>
<div class="header">
<p>
Next: <a href="#perlrequick-DESCRIPTION" accesskey="n" rel="next">perlrequick DESCRIPTION</a>, Up: <a href="#perlrequick" accesskey="u" rel="up">perlrequick</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="NAME-64"></a>
<h3 class="section">65.1 NAME</h3>

<p>perlrequick - Perl regular expressions quick start
</p>
<hr>
<a name="perlrequick-DESCRIPTION"></a>
<div class="header">
<p>
Next: <a href="#perlrequick-The-Guide" accesskey="n" rel="next">perlrequick The Guide</a>, Previous: <a href="#perlrequick-NAME" accesskey="p" rel="prev">perlrequick NAME</a>, Up: <a href="#perlrequick" accesskey="u" rel="up">perlrequick</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="DESCRIPTION-63"></a>
<h3 class="section">65.2 DESCRIPTION</h3>

<p>This page covers the very basics of understanding, creating and
using regular expressions (&rsquo;regexes&rsquo;) in Perl.
</p>
<hr>
<a name="perlrequick-The-Guide"></a>
<div class="header">
<p>
Next: <a href="#perlrequick-BUGS" accesskey="n" rel="next">perlrequick BUGS</a>, Previous: <a href="#perlrequick-DESCRIPTION" accesskey="p" rel="prev">perlrequick DESCRIPTION</a>, Up: <a href="#perlrequick" accesskey="u" rel="up">perlrequick</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="The-Guide"></a>
<h3 class="section">65.3 The Guide</h3>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#perlrequick-Simple-word-matching" accesskey="1">perlrequick Simple word matching</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#perlrequick-Using-character-classes" accesskey="2">perlrequick Using character classes</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#perlrequick-Matching-this-or-that" accesskey="3">perlrequick Matching this or that</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#perlrequick-Grouping-things-and-hierarchical-matching" accesskey="4">perlrequick Grouping things and hierarchical matching</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#perlrequick-Extracting-matches" accesskey="5">perlrequick Extracting matches</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#perlrequick-Matching-repetitions" accesskey="6">perlrequick Matching repetitions</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#perlrequick-More-matching" accesskey="7">perlrequick More matching</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#perlrequick-Search-and-replace" accesskey="8">perlrequick Search and replace</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#perlrequick-The-split-operator" accesskey="9">perlrequick The split operator</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="perlrequick-Simple-word-matching"></a>
<div class="header">
<p>
Next: <a href="#perlrequick-Using-character-classes" accesskey="n" rel="next">perlrequick Using character classes</a>, Up: <a href="#perlrequick-The-Guide" accesskey="u" rel="up">perlrequick The Guide</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Simple-word-matching"></a>
<h4 class="subsection">65.3.1 Simple word matching</h4>

<p>The simplest regex is simply a word, or more generally, a string of
characters.  A regex consisting of a word matches any string that
contains that word:
</p>
<pre class="verbatim">    &quot;Hello World&quot; =~ /World/;  # matches
</pre>
<p>In this statement, <code>World</code> is a regex and the <code>//</code> enclosing
<code>/World/</code> tells Perl to search a string for a match.  The operator
<code>=~</code> associates the string with the regex match and produces a true
value if the regex matched, or false if the regex did not match.  In
our case, <code>World</code> matches the second word in <code>&quot;Hello World&quot;</code>, so the
expression is true.  This idea has several variations.
</p>
<p>Expressions like this are useful in conditionals:
</p>
<pre class="verbatim">    print &quot;It matches\n&quot; if &quot;Hello World&quot; =~ /World/;
</pre>
<p>The sense of the match can be reversed by using <code>!~</code> operator:
</p>
<pre class="verbatim">    print &quot;It doesn't match\n&quot; if &quot;Hello World&quot; !~ /World/;
</pre>
<p>The literal string in the regex can be replaced by a variable:
</p>
<pre class="verbatim">    $greeting = &quot;World&quot;;
    print &quot;It matches\n&quot; if &quot;Hello World&quot; =~ /$greeting/;
</pre>
<p>If you&rsquo;re matching against <code>$_</code>, the <code>$_ =~</code> part can be omitted:
</p>
<pre class="verbatim">    $_ = &quot;Hello World&quot;;
    print &quot;It matches\n&quot; if /World/;
</pre>
<p>Finally, the <code>//</code> default delimiters for a match can be changed to
arbitrary delimiters by putting an <code>'m'</code> out front:
</p>
<pre class="verbatim">    &quot;Hello World&quot; =~ m!World!;   # matches, delimited by '!'
    &quot;Hello World&quot; =~ m{World};   # matches, note the matching '{}'
    &quot;/usr/bin/perl&quot; =~ m&quot;/perl&quot;; # matches after '/usr/bin',
                                 # '/' becomes an ordinary char
</pre>
<p>Regexes must match a part of the string <em>exactly</em> in order for the
statement to be true:
</p>
<pre class="verbatim">    &quot;Hello World&quot; =~ /world/;  # doesn't match, case sensitive
    &quot;Hello World&quot; =~ /o W/;    # matches, ' ' is an ordinary char
    &quot;Hello World&quot; =~ /World /; # doesn't match, no ' ' at end
</pre>
<p>Perl will always match at the earliest possible point in the string:
</p>
<pre class="verbatim">    &quot;Hello World&quot; =~ /o/;       # matches 'o' in 'Hello'
    &quot;That hat is red&quot; =~ /hat/; # matches 'hat' in 'That'
</pre>
<p>Not all characters can be used &rsquo;as is&rsquo; in a match.  Some characters,
called <strong>metacharacters</strong>, are reserved for use in regex notation.
The metacharacters are
</p>
<pre class="verbatim">    {}[]()^$.|*+?\
</pre>
<p>A metacharacter can be matched by putting a backslash before it:
</p>
<pre class="verbatim">    &quot;2+2=4&quot; =~ /2+2/;    # doesn't match, + is a metacharacter
    &quot;2+2=4&quot; =~ /2\+2/;   # matches, \+ is treated like an ordinary +
    'C:\WIN32' =~ /C:\\WIN/;                       # matches
    &quot;/usr/bin/perl&quot; =~ /\/usr\/bin\/perl/;  # matches
</pre>
<p>In the last regex, the forward slash <code>'/'</code> is also backslashed,
because it is used to delimit the regex.
</p>
<p>Non-printable ASCII characters are represented by <strong>escape sequences</strong>.
Common examples are <code>\t</code> for a tab, <code>\n</code> for a newline, and <code>\r</code>
for a carriage return.  Arbitrary bytes are represented by octal
escape sequences, e.g., <code>\033</code>, or hexadecimal escape sequences,
e.g., <code>\x1B</code>:
</p>
<pre class="verbatim">    &quot;1000\t2000&quot; =~ m(0\t2)      # matches
    &quot;cat&quot;      =~ /\143\x61\x74/ # matches in ASCII, but a weird way to spell cat
</pre>
<p>Regexes are treated mostly as double-quoted strings, so variable
substitution works:
</p>
<pre class="verbatim">    $foo = 'house';
    'cathouse' =~ /cat$foo/;   # matches
    'housecat' =~ /${foo}cat/; # matches
</pre>
<p>With all of the regexes above, if the regex matched anywhere in the
string, it was considered a match.  To specify <em>where</em> it should
match, we would use the <strong>anchor</strong> metacharacters <code>^</code> and <code>$</code>.  The
anchor <code>^</code> means match at the beginning of the string and the anchor
<code>$</code> means match at the end of the string, or before a newline at the
end of the string.  Some examples:
</p>
<pre class="verbatim">    &quot;housekeeper&quot; =~ /keeper/;         # matches
    &quot;housekeeper&quot; =~ /^keeper/;        # doesn't match
    &quot;housekeeper&quot; =~ /keeper$/;        # matches
    &quot;housekeeper\n&quot; =~ /keeper$/;      # matches
    &quot;housekeeper&quot; =~ /^housekeeper$/;  # matches
</pre>
<hr>
<a name="perlrequick-Using-character-classes"></a>
<div class="header">
<p>
Next: <a href="#perlrequick-Matching-this-or-that" accesskey="n" rel="next">perlrequick Matching this or that</a>, Previous: <a href="#perlrequick-Simple-word-matching" accesskey="p" rel="prev">perlrequick Simple word matching</a>, Up: <a href="#perlrequick-The-Guide" accesskey="u" rel="up">perlrequick The Guide</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Using-character-classes"></a>
<h4 class="subsection">65.3.2 Using character classes</h4>

<p>A <strong>character class</strong> allows a set of possible characters, rather than
just a single character, to match at a particular point in a regex.
Character classes are denoted by brackets <code>[...]</code>, with the set of
characters to be possibly matched inside.  Here are some examples:
</p>
<pre class="verbatim">    /cat/;            # matches 'cat'
    /[bcr]at/;        # matches 'bat', 'cat', or 'rat'
    &quot;abc&quot; =~ /[cab]/; # matches 'a'
</pre>
<p>In the last statement, even though <code>'c'</code> is the first character in
the class, the earliest point at which the regex can match is <code>'a'</code>.
</p>
<pre class="verbatim">    /[yY][eE][sS]/; # match 'yes' in a case-insensitive way
                    # 'yes', 'Yes', 'YES', etc.
    /yes/i;         # also match 'yes' in a case-insensitive way
</pre>
<p>The last example shows a match with an <code>'i'</code> <strong>modifier</strong>, which makes
the match case-insensitive.
</p>
<p>Character classes also have ordinary and special characters, but the
sets of ordinary and special characters inside a character class are
different than those outside a character class.  The special
characters for a character class are <code>-]\^$</code> and are matched using an
escape:
</p>
<pre class="verbatim">   /[\]c]def/; # matches ']def' or 'cdef'
   $x = 'bcr';
   /[$x]at/;   # matches 'bat, 'cat', or 'rat'
   /[\$x]at/;  # matches '$at' or 'xat'
   /[\\$x]at/; # matches '\at', 'bat, 'cat', or 'rat'
</pre>
<p>The special character <code>'-'</code> acts as a range operator within character
classes, so that the unwieldy <code>[0123456789]</code> and <code>[abc...xyz]</code>
become the svelte <code>[0-9]</code> and <code>[a-z]</code>:
</p>
<pre class="verbatim">    /item[0-9]/;  # matches 'item0' or ... or 'item9'
    /[0-9a-fA-F]/;  # matches a hexadecimal digit
</pre>
<p>If <code>'-'</code> is the first or last character in a character class, it is
treated as an ordinary character.
</p>
<p>The special character <code>^</code> in the first position of a character class
denotes a <strong>negated character class</strong>, which matches any character but
those in the brackets.  Both <code>[...]</code> and <code>[^...]</code> must match a
character, or the match fails.  Then
</p>
<pre class="verbatim">    /[^a]at/;  # doesn't match 'aat' or 'at', but matches
               # all other 'bat', 'cat, '0at', '%at', etc.
    /[^0-9]/;  # matches a non-numeric character
    /[a^]at/;  # matches 'aat' or '^at'; here '^' is ordinary
</pre>
<p>Perl has several abbreviations for common character classes. (These
definitions are those that Perl uses in ASCII-safe mode with the <code>/a</code> modifier.
Otherwise they could match many more non-ASCII Unicode characters as
well.  See <a href="perlrecharclass.html#perlrecharclass-Backslash-sequences">perlrecharclass Backslash sequences</a> for details.)
</p>
<ul>
<li> \d is a digit and represents

<pre class="verbatim">    [0-9]
</pre>
</li><li> \s is a whitespace character and represents

<pre class="verbatim">    [\ \t\r\n\f]
</pre>
</li><li> \w is a word character (alphanumeric or _) and represents

<pre class="verbatim">    [0-9a-zA-Z_]
</pre>
</li><li> \D is a negated \d; it represents any character but a digit

<pre class="verbatim">    [^0-9]
</pre>
</li><li> \S is a negated \s; it represents any non-whitespace character

<pre class="verbatim">    [^\s]
</pre>
</li><li> \W is a negated \w; it represents any non-word character

<pre class="verbatim">    [^\w]
</pre>
</li><li> The period &rsquo;.&rsquo; matches any character but &quot;\n&quot;

</li></ul>

<p>The <code>\d\s\w\D\S\W</code> abbreviations can be used both inside and outside
of character classes.  Here are some in use:
</p>
<pre class="verbatim">    /\d\d:\d\d:\d\d/; # matches a hh:mm:ss time format
    /[\d\s]/;         # matches any digit or whitespace character
    /\w\W\w/;         # matches a word char, followed by a
                      # non-word char, followed by a word char
    /..rt/;           # matches any two chars, followed by 'rt'
    /end\./;          # matches 'end.'
    /end[.]/;         # same thing, matches 'end.'
</pre>
<p>The <strong>word&nbsp;anchor</strong>&nbsp;<!-- /@w --> <code>\b</code> matches a boundary between a word
character and a non-word character <code>\w\W</code> or <code>\W\w</code>:
</p>
<pre class="verbatim">    $x = &quot;Housecat catenates house and cat&quot;;
    $x =~ /\bcat/;  # matches cat in 'catenates'
    $x =~ /cat\b/;  # matches cat in 'housecat'
    $x =~ /\bcat\b/;  # matches 'cat' at end of string
</pre>
<p>In the last example, the end of the string is considered a word
boundary.
</p>
<hr>
<a name="perlrequick-Matching-this-or-that"></a>
<div class="header">
<p>
Next: <a href="#perlrequick-Grouping-things-and-hierarchical-matching" accesskey="n" rel="next">perlrequick Grouping things and hierarchical matching</a>, Previous: <a href="#perlrequick-Using-character-classes" accesskey="p" rel="prev">perlrequick Using character classes</a>, Up: <a href="#perlrequick-The-Guide" accesskey="u" rel="up">perlrequick The Guide</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Matching-this-or-that"></a>
<h4 class="subsection">65.3.3 Matching this or that</h4>

<p>We can match different character strings with the <strong>alternation</strong>
metacharacter <code>'|'</code>.  To match <code>dog</code> or <code>cat</code>, we form the regex
<code>dog|cat</code>.  As before, Perl will try to match the regex at the
earliest possible point in the string.  At each character position,
Perl will first try to match the first alternative, <code>dog</code>.  If
<code>dog</code> doesn&rsquo;t match, Perl will then try the next alternative, <code>cat</code>.
If <code>cat</code> doesn&rsquo;t match either, then the match fails and Perl moves to
the next position in the string.  Some examples:
</p>
<pre class="verbatim">    &quot;cats and dogs&quot; =~ /cat|dog|bird/;  # matches &quot;cat&quot;
    &quot;cats and dogs&quot; =~ /dog|cat|bird/;  # matches &quot;cat&quot;
</pre>
<p>Even though <code>dog</code> is the first alternative in the second regex,
<code>cat</code> is able to match earlier in the string.
</p>
<pre class="verbatim">    &quot;cats&quot;          =~ /c|ca|cat|cats/; # matches &quot;c&quot;
    &quot;cats&quot;          =~ /cats|cat|ca|c/; # matches &quot;cats&quot;
</pre>
<p>At a given character position, the first alternative that allows the
regex match to succeed will be the one that matches. Here, all the
alternatives match at the first string position, so the first matches.
</p>
<hr>
<a name="perlrequick-Grouping-things-and-hierarchical-matching"></a>
<div class="header">
<p>
Next: <a href="#perlrequick-Extracting-matches" accesskey="n" rel="next">perlrequick Extracting matches</a>, Previous: <a href="#perlrequick-Matching-this-or-that" accesskey="p" rel="prev">perlrequick Matching this or that</a>, Up: <a href="#perlrequick-The-Guide" accesskey="u" rel="up">perlrequick The Guide</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Grouping-things-and-hierarchical-matching"></a>
<h4 class="subsection">65.3.4 Grouping things and hierarchical matching</h4>

<p>The <strong>grouping</strong> metacharacters <code>()</code> allow a part of a regex to be
treated as a single unit.  Parts of a regex are grouped by enclosing
them in parentheses.  The regex <code>house(cat|keeper)</code> means match
<code>house</code> followed by either <code>cat</code> or <code>keeper</code>.  Some more examples
are
</p>
<pre class="verbatim">    /(a|b)b/;    # matches 'ab' or 'bb'
    /(^a|b)c/;   # matches 'ac' at start of string or 'bc' anywhere

    /house(cat|)/;  # matches either 'housecat' or 'house'
    /house(cat(s|)|)/;  # matches either 'housecats' or 'housecat' or
                        # 'house'.  Note groups can be nested.

    &quot;20&quot; =~ /(19|20|)\d\d/;  # matches the null alternative '()\d\d',
                             # because '20\d\d' can't match
</pre>
<hr>
<a name="perlrequick-Extracting-matches"></a>
<div class="header">
<p>
Next: <a href="#perlrequick-Matching-repetitions" accesskey="n" rel="next">perlrequick Matching repetitions</a>, Previous: <a href="#perlrequick-Grouping-things-and-hierarchical-matching" accesskey="p" rel="prev">perlrequick Grouping things and hierarchical matching</a>, Up: <a href="#perlrequick-The-Guide" accesskey="u" rel="up">perlrequick The Guide</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Extracting-matches"></a>
<h4 class="subsection">65.3.5 Extracting matches</h4>

<p>The grouping metacharacters <code>()</code> also allow the extraction of the
parts of a string that matched.  For each grouping, the part that
matched inside goes into the special variables <code>$1</code>, <code>$2</code>, etc.
They can be used just as ordinary variables:
</p>
<pre class="verbatim">    # extract hours, minutes, seconds
    $time =~ /(\d\d):(\d\d):(\d\d)/;  # match hh:mm:ss format
    $hours = $1;
    $minutes = $2;
    $seconds = $3;
</pre>
<p>In list context, a match <code>/regex/</code> with groupings will return the
list of matched values <code>($1,$2,...)</code>.  So we could rewrite it as
</p>
<pre class="verbatim">    ($hours, $minutes, $second) = ($time =~ /(\d\d):(\d\d):(\d\d)/);
</pre>
<p>If the groupings in a regex are nested, <code>$1</code> gets the group with the
leftmost opening parenthesis, <code>$2</code> the next opening parenthesis,
etc.  For example, here is a complex regex and the matching variables
indicated below it:
</p>
<pre class="verbatim">    /(ab(cd|ef)((gi)|j))/;
     1  2      34
</pre>
<p>Associated with the matching variables <code>$1</code>, <code>$2</code>, ... are
the <strong>backreferences</strong> <code>\g1</code>, <code>\g2</code>, ...  Backreferences are
matching variables that can be used <em>inside</em> a regex:
</p>
<pre class="verbatim">    /(\w\w\w)\s\g1/; # find sequences like 'the the' in string
</pre>
<p><code>$1</code>, <code>$2</code>, ... should only be used outside of a regex, and <code>\g1</code>,
<code>\g2</code>, ... only inside a regex.
</p>
<hr>
<a name="perlrequick-Matching-repetitions"></a>
<div class="header">
<p>
Next: <a href="#perlrequick-More-matching" accesskey="n" rel="next">perlrequick More matching</a>, Previous: <a href="#perlrequick-Extracting-matches" accesskey="p" rel="prev">perlrequick Extracting matches</a>, Up: <a href="#perlrequick-The-Guide" accesskey="u" rel="up">perlrequick The Guide</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Matching-repetitions"></a>
<h4 class="subsection">65.3.6 Matching repetitions</h4>

<p>The <strong>quantifier</strong> metacharacters <code>?</code>, <code>*</code>, <code>+</code>, and <code>{}</code> allow us
to determine the number of repeats of a portion of a regex we
consider to be a match.  Quantifiers are put immediately after the
character, character class, or grouping that we want to specify.  They
have the following meanings:
</p>
<ul>
<li> <code>a?</code> = match &rsquo;a&rsquo; 1 or 0 times

</li><li> <code>a*</code> = match &rsquo;a&rsquo; 0 or more times, i.e., any number of times

</li><li> <code>a+</code> = match &rsquo;a&rsquo; 1 or more times, i.e., at least once

</li><li> <code>a{n,m}</code> = match at least <code>n</code> times, but not more than <code>m</code>
times.

</li><li> <code>a{n,}</code> = match at least <code>n</code> or more times

</li><li> <code>a{n}</code> = match exactly <code>n</code> times

</li></ul>

<p>Here are some examples:
</p>
<pre class="verbatim">    /[a-z]+\s+\d*/;  # match a lowercase word, at least some space, and
                     # any number of digits
    /(\w+)\s+\g1/;    # match doubled words of arbitrary length
    $year =~ /^\d{2,4}$/;  # make sure year is at least 2 but not more
                           # than 4 digits
    $year =~ /^\d{4}$|^\d{2}$/;    # better match; throw out 3 digit dates
</pre>
<p>These quantifiers will try to match as much of the string as possible,
while still allowing the regex to match.  So we have
</p>
<pre class="verbatim">    $x = 'the cat in the hat';
    $x =~ /^(.*)(at)(.*)$/; # matches,
                            # $1 = 'the cat in the h'
                            # $2 = 'at'
                            # $3 = ''   (0 matches)
</pre>
<p>The first quantifier <code>.*</code> grabs as much of the string as possible
while still having the regex match. The second quantifier <code>.*</code> has
no string left to it, so it matches 0 times.
</p>
<hr>
<a name="perlrequick-More-matching"></a>
<div class="header">
<p>
Next: <a href="#perlrequick-Search-and-replace" accesskey="n" rel="next">perlrequick Search and replace</a>, Previous: <a href="#perlrequick-Matching-repetitions" accesskey="p" rel="prev">perlrequick Matching repetitions</a>, Up: <a href="#perlrequick-The-Guide" accesskey="u" rel="up">perlrequick The Guide</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="More-matching"></a>
<h4 class="subsection">65.3.7 More matching</h4>

<p>There are a few more things you might want to know about matching
operators.
The global modifier <code>//g</code> allows the matching operator to match
within a string as many times as possible.  In scalar context,
successive matches against a string will have <code>//g</code> jump from match
to match, keeping track of position in the string as it goes along.
You can get or set the position with the <code>pos()</code> function.
For example,
</p>
<pre class="verbatim">    $x = &quot;cat dog house&quot;; # 3 words
    while ($x =~ /(\w+)/g) {
        print &quot;Word is $1, ends at position &quot;, pos $x, &quot;\n&quot;;
    }
</pre>
<p>prints
</p>
<pre class="verbatim">    Word is cat, ends at position 3
    Word is dog, ends at position 7
    Word is house, ends at position 13
</pre>
<p>A failed match or changing the target string resets the position.  If
you don&rsquo;t want the position reset after failure to match, add the
<code>//c</code>, as in <code>/regex/gc</code>.
</p>
<p>In list context, <code>//g</code> returns a list of matched groupings, or if
there are no groupings, a list of matches to the whole regex.  So
</p>
<pre class="verbatim">    @words = ($x =~ /(\w+)/g);  # matches,
                                # $word[0] = 'cat'
                                # $word[1] = 'dog'
                                # $word[2] = 'house'
</pre>
<hr>
<a name="perlrequick-Search-and-replace"></a>
<div class="header">
<p>
Next: <a href="#perlrequick-The-split-operator" accesskey="n" rel="next">perlrequick The split operator</a>, Previous: <a href="#perlrequick-More-matching" accesskey="p" rel="prev">perlrequick More matching</a>, Up: <a href="#perlrequick-The-Guide" accesskey="u" rel="up">perlrequick The Guide</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Search-and-replace"></a>
<h4 class="subsection">65.3.8 Search and replace</h4>

<p>Search and replace is performed using <code>s/regex/replacement/modifiers</code>.
The <code>replacement</code> is a Perl double-quoted string that replaces in the
string whatever is matched with the <code>regex</code>.  The operator <code>=~</code> is
also used here to associate a string with <code>s///</code>.  If matching
against <code>$_</code>, the <code><span class="nolinebreak">$_</span>&nbsp;=~</code><!-- /@w --> can be dropped.  If there is a match,
<code>s///</code> returns the number of substitutions made; otherwise it returns
false.  Here are a few examples:
</p>
<pre class="verbatim">    $x = &quot;Time to feed the cat!&quot;;
    $x =~ s/cat/hacker/;   # $x contains &quot;Time to feed the hacker!&quot;
    $y = &quot;'quoted words'&quot;;
    $y =~ s/^'(.*)'$/$1/;  # strip single quotes,
                           # $y contains &quot;quoted words&quot;
</pre>
<p>With the <code>s///</code> operator, the matched variables <code>$1</code>, <code>$2</code>, etc.
are immediately available for use in the replacement expression. With
the global modifier, <code>s///g</code> will search and replace all occurrences
of the regex in the string:
</p>
<pre class="verbatim">    $x = &quot;I batted 4 for 4&quot;;
    $x =~ s/4/four/;   # $x contains &quot;I batted four for 4&quot;
    $x = &quot;I batted 4 for 4&quot;;
    $x =~ s/4/four/g;  # $x contains &quot;I batted four for four&quot;
</pre>
<p>The non-destructive modifier <code>s///r</code> causes the result of the substitution
to be returned instead of modifying <code>$_</code> (or whatever variable the
substitute was bound to with <code>=~</code>):
</p>
<pre class="verbatim">    $x = &quot;I like dogs.&quot;;
    $y = $x =~ s/dogs/cats/r;
    print &quot;$x $y\n&quot;; # prints &quot;I like dogs. I like cats.&quot;

    $x = &quot;Cats are great.&quot;;
    print $x =~ s/Cats/Dogs/r =~ s/Dogs/Frogs/r =~ s/Frogs/Hedgehogs/r, &quot;\n&quot;;
    # prints &quot;Hedgehogs are great.&quot;

    @foo = map { s/[a-z]/X/r } qw(a b c 1 2 3);
    # @foo is now qw(X X X 1 2 3)
</pre>
<p>The evaluation modifier <code>s///e</code> wraps an <code>eval{...}</code> around the
replacement string and the evaluated result is substituted for the
matched substring.  Some examples:
</p>
<pre class="verbatim">    # reverse all the words in a string
    $x = &quot;the cat in the hat&quot;;
    $x =~ s/(\w+)/reverse $1/ge;   # $x contains &quot;eht tac ni eht tah&quot;

    # convert percentage to decimal
    $x = &quot;A 39% hit rate&quot;;
    $x =~ s!(\d+)%!$1/100!e;       # $x contains &quot;A 0.39 hit rate&quot;
</pre>
<p>The last example shows that <code>s///</code> can use other delimiters, such as
<code>s!!!</code> and <code>s{}{}</code>, and even <code>s{}//</code>.  If single quotes are used
<code>s'''</code>, then the regex and replacement are treated as single-quoted
strings.
</p>
<hr>
<a name="perlrequick-The-split-operator"></a>
<div class="header">
<p>
Previous: <a href="#perlrequick-Search-and-replace" accesskey="p" rel="prev">perlrequick Search and replace</a>, Up: <a href="#perlrequick-The-Guide" accesskey="u" rel="up">perlrequick The Guide</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="The-split-operator"></a>
<h4 class="subsection">65.3.9 The split operator</h4>

<p><code>split /regex/, string</code> splits <code>string</code> into a list of substrings
and returns that list.  The regex determines the character sequence
that <code>string</code> is split with respect to.  For example, to split a
string into words, use
</p>
<pre class="verbatim">    $x = &quot;Calvin and Hobbes&quot;;
    @word = split /\s+/, $x;  # $word[0] = 'Calvin'
                              # $word[1] = 'and'
                              # $word[2] = 'Hobbes'
</pre>
<p>To extract a comma-delimited list of numbers, use
</p>
<pre class="verbatim">    $x = &quot;1.618,2.718,   3.142&quot;;
    @const = split /,\s*/, $x;  # $const[0] = '1.618'
                                # $const[1] = '2.718'
                                # $const[2] = '3.142'
</pre>
<p>If the empty regex <code>//</code> is used, the string is split into individual
characters.  If the regex has groupings, then the list produced contains
the matched substrings from the groupings as well:
</p>
<pre class="verbatim">    $x = &quot;/usr/bin&quot;;
    @parts = split m!(/)!, $x;  # $parts[0] = ''
                                # $parts[1] = '/'
                                # $parts[2] = 'usr'
                                # $parts[3] = '/'
                                # $parts[4] = 'bin'
</pre>
<p>Since the first character of $x matched the regex, <code>split</code> prepended
an empty initial element to the list.
</p>
<hr>
<a name="perlrequick-BUGS"></a>
<div class="header">
<p>
Next: <a href="#perlrequick-SEE-ALSO" accesskey="n" rel="next">perlrequick SEE ALSO</a>, Previous: <a href="#perlrequick-The-Guide" accesskey="p" rel="prev">perlrequick The Guide</a>, Up: <a href="#perlrequick" accesskey="u" rel="up">perlrequick</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="BUGS-7"></a>
<h3 class="section">65.4 BUGS</h3>

<p>None.
</p>
<hr>
<a name="perlrequick-SEE-ALSO"></a>
<div class="header">
<p>
Next: <a href="#perlrequick-AUTHOR-AND-COPYRIGHT" accesskey="n" rel="next">perlrequick AUTHOR AND COPYRIGHT</a>, Previous: <a href="#perlrequick-BUGS" accesskey="p" rel="prev">perlrequick BUGS</a>, Up: <a href="#perlrequick" accesskey="u" rel="up">perlrequick</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="SEE-ALSO-33"></a>
<h3 class="section">65.5 SEE ALSO</h3>

<p>This is just a quick start guide.  For a more in-depth tutorial on
regexes, see <a href="perlretut.html#perlretut-NAME">perlretut NAME</a> and for the reference page, see <a href="perlre.html#perlre-NAME">perlre NAME</a>.
</p>
<hr>
<a name="perlrequick-AUTHOR-AND-COPYRIGHT"></a>
<div class="header">
<p>
Previous: <a href="#perlrequick-SEE-ALSO" accesskey="p" rel="prev">perlrequick SEE ALSO</a>, Up: <a href="#perlrequick" accesskey="u" rel="up">perlrequick</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="AUTHOR-AND-COPYRIGHT"></a>
<h3 class="section">65.6 AUTHOR AND COPYRIGHT</h3>

<p>Copyright (c) 2000 Mark Kvale
All rights reserved.
</p>
<p>This document may be distributed under the same terms as Perl itself.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#perlrequick-Acknowledgments" accesskey="1">perlrequick Acknowledgments</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="perlrequick-Acknowledgments"></a>
<div class="header">
<p>
Up: <a href="#perlrequick-AUTHOR-AND-COPYRIGHT" accesskey="u" rel="up">perlrequick AUTHOR AND COPYRIGHT</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Acknowledgments"></a>
<h4 class="subsection">65.6.1 Acknowledgments</h4>

<p>The author would like to thank Mark-Jason Dominus, Tom Christiansen,
Ilya Zakharevich, Brad Hughes, and Mike Giroux for all their helpful
comments.
</p>
<hr>
<div class="header">
<p>
Up: <a href="#perlrequick-AUTHOR-AND-COPYRIGHT" accesskey="u" rel="up">perlrequick AUTHOR AND COPYRIGHT</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>



</body>
</html>
