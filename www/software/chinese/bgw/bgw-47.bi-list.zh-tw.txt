Welcome to another issue of the Brave GNU World, which will be a little more technical this month. But even though some projects are probably of primary interest to developers, one can hope that also less-technical readers will be able to draw new perspectives and inspirations from them.

歡迎來到又一期的《勇敢 GNU 世界》， 這個月將會多一點點技術性。 但是即使一些計畫可能主要對開發者來說才會感〔到〕興趣， 還是可以期望比較沒有技術背景的讀者也〔有能力〕 由於它們而激起新的看法和靈感。 【譯註：為求優譯，中英文並陳將持續到二○○三年三月上旬； 在此期間，請不吝於提供對於本文翻譯的意見。】
Twin（文字模式窗格環境）

The first topic this month is Twin, [5] a multi-window, multi-application text-based environment by Massimiliano Ghilardi. Consequently, Twin is an acronym for "Text WINdows" or (even better) "a textmode window environment."

本月份第一個要討論的是 Twin ， [5] 由 Massimiliano Ghilardi 所完成的一個多窗格（multi-window）、 多應用（multi-application） 的以文字作為基礎的環境（text-based environment）。 因此 Twin 是「Text WINdows」的一個首字母縮寫語， 或「（更好的〔擴展全名〕）textmode window environment （文字模式窗格環境）。」

The project aims at people who seek to have an environment with several windows without needing or wanting all the features of X11 - especially its significant resource hunger.

這個計畫的目標在於那些尋求擁有一個具有多個窗格的環境， 同時不需要或缺少 X11 的所有特徵（features） -- 特別是它吞噬資源的驚人胃口 -- 的人。

Combining Twin with Links, a text-mode web browser, only requires about 5% of the resources compared to X11 with the graphical browser Konqueror. All applications that can be used on a console or in a terminal window can also be used under Twin.

將 Twin 與〔網路〕鏈接（Links）組合起來， 〔就成了〕一個文字模式的網頁瀏覽器（text-mode web browser）， 與在 X11 下的圖形瀏覽器 Konqueror 相比， 只需要大約百分之五的資源。 同時， 可以在主控台（console）或終端機視窗中使用的所有應用〔程式〕， 也都可以在 Twin 下面使用。

In a time where graphic cards are trying to outrace each other with new features and where what was impossible to afford yesterday is available for pocket change the day after, this seems almost anachronistic. But as already explained for the RULE project in the last issue, [6] this is only true for a small part of mankind.

在〔圖形〕顯示卡百家爭鳴推陳出新， 而且產品降價迅速的時代裡， 這看起來似乎不合時代〔潮流〕。 但是如同在前一期 RULE 計畫〔的介紹〕中已經作出的解釋， [6] 這個〔所謂的不合潮流，〕 只有對一小部份的人〔而言〕是真實的。

In many places people will depend on using hardware for a long time that has already been declared outdated. This is often also true for schools in financially better-off countries.

在許多地方， 有許多人仍然需要長時間地使用過時的機器。 就算是在富裕及小康（financially better-off）的國家的學校裡， 也經常是如此。

But there is also another group that profits from Twin, that is normally not the focus when thinking about new software: Blind and vision-impaired people. As they depend on using Braille-Terminals, they have little use for graphical user interfaces.

但是也有其他的群組可以從 Twin 獲得利益， 當想到新軟體時正常來說不是焦點的〔群組〕： 盲人與視覺障礙的同胞。 由於他們依賴於使用點字終端機（Braille-Terminals）， 圖形使用者介面對於他們沒有多大用處。

With Twin, they can now also use a full environment with multiple windows and applications. In fact Massimiliano tells that he indeed gets a lot of feedback from this group of users, which was initially suprising to him.

經由 Twin 〔的使用〕， 他們現在也可以使用具有多窗格以及應用的完整環境。 事實上， Massimiliano 說他確實收到了來自這個群組的許多回應， 這在一開始對他〔而言〕是個驚喜。

Technically speaking, the project consists of a server, called "twin" like the whole project. This server accepts connections by the clients and creates or modifies windows according to their commands. Also the server dynamically manages the different displays and devices.

從技術上來講， 這個計畫含有一個如同整個計畫〔所稱的〕， 稱為「twin」的伺服器。 這個伺服器接受由用戶端（clients）〔所作出〕的連接（connections）， 並且根據它們的指令建立或修改窗格。 這個伺服器也動態地管理不同的顯示（displays）和裝置（devices）。

Twin currently handles the console with mouse support via gpm and every termcap or ncurses compatible terminal with mouse support by the "xterm" mouse protocol, if available. But it is also possible to use X11 by means of a simple X11 driver or the graphically enhanced gfx-driver for output as well as another Twin server on another machine.

Twin 目前處理具有滑鼠支持的主控台的方式是， 經由 gpm 和每一個與 termcap 或 ncurses 相容的終端機， 如果可以取得的話， 這些終端機並且通過“xterm”的滑鼠協定。 但是它也有可能用一個簡單的 X11 驅動器（driver）， 或者（為了輸出的）圖形增強的 gfx-驅動器， 和另一個在其它機器上的 Twin 伺服器的方式使用 X11 。

The General Graphics Interface (GGI) is also supported, but since it still lacks keyboard support, this most probably makes it rather unsuitable for most applications.

〔它〕也支援一般圖形介面（General Graphics Interface ； GGI）， 但是由於它還缺乏鍵盤的支援， 這相當〔程度〕地使它不適合於大部份的應用。

Among the other components are the libraries libTw, which handles the communication with the server, as well as libTT, which as the toolkit library provides an abstraction from of the more graphically oriented server-side functions to the more window/object oriented functions clients prefer. The third library is libTutf, a Unicode library, which allows transferring text from and to unicode. This library will probably become obsolete by using standard libraries some time in the future when the final open issues have been addressed.

其他的組成（components）還有 libTw 程式庫， 它操縱著與伺服器〔之間〕的通信（communication）， 以及 libTT ，它是作為提供「由較為圖形導向的伺服端功能， 到較為窗格／物件導向 -- 這是用戶端較為喜歡（的表示法） -- 的功能」 的抽象化（abstraction）的工具組程式庫。 第三個程式庫是 libTutf ， 一個允許在 unicode （萬國碼）和文字（text） 之間互相轉換的 Unicode 程式庫。 這個程式庫或許在未來， 當最後的公開刊行〔的 Unicode〕已經被提出後， 會由於使用了標準程式庫而被淘汰。

And finally there are the clients. Currently there are only a few of them, of which two are built into the server. Both the window manager, which can be configured through a "~/.twinrc" configuration file, and a simple terminal emulating the console have been integrated into the server for technical reasons.

最後有〔一些〕用戶端。 目前來說它們只有幾個， 而其中有兩個是建造在伺服器中。 窗格管理員（可以經由“twinrc”組態檔來進行組態） 和用來模擬控制台的一個簡單終端機這兩者， 都己經由於技術的理由而被整合到伺服器中了。

Other clients are an additional terminal emulator (twterm), a login manager similar to xdm/gdm/kdm (twdm), a system monitor (twsysmon), utilities to (de-)register displays with the server as well as other smaller clients that are more suited for testing than real work.

其它的用戶端有： 一個額外的終端模擬器（twterm）、 一個類似於 xdm/gdm/kdm 的登錄管理器（twdm）、 一個系統監視器（twsysmon）和 一些登錄（和取消）顯示到伺服器以及其它較為適合測試， 而非實際工作的較小用戶端的實用性程式（utilities）。

The project originates as a DOS program in 1993, but multitasking problems brought it to a halt pretty soon. It only took up speed again when Massimiliano switched to GNU/Linux in 1999 and ported the project to his new platform.

這個計畫是在一九九三年作為一個 DOS 程式而開始， 但是多工（multitasking）問題使它暫停了好一段時間。 當 Massimiliano 在一九九九年將它切換到 GNU/Linux 後， 它才又開始加速了進行， 並將這計畫改寫並實作（ported）到他的新平台上。

The project has been written entirely in C, one of the reasons for its small memory footprint - a Twin server usually requires less memory than the Bash shell. And of course Twin is Free Software - its licenses are the GNU General Public License (GPL) for server and clients and the GNU Lesser General Public License (LGPL) for the libraries.

這個計畫完全是以 C 〔語言〕編寫而成， 其中一個理由是它的小記憶體需求量（memory footprint） - 一個 Twin 伺服器通常比 Bash 外殼（shell）需要更少的記憶體。 Twin 當然是自由軟體 - 它的許可證在伺服器上是 GNU General Public License (GPL) ， 而在用戶端（為了程式庫〔的使用〕）則是 GNU Lesser General Public License (LGPL) 。

Further development is pursued by Massimiliano in his (rather spare) free time, and he still has a lot of ideas. First he'd like to complete the toolkit library and its documentation, then more editors, task bars, file managers, web browsers, email programs and TTY based programs should be expanded to use it.

更進一步的開發是由 Massimiliano 在他的（變得更少的） 空閒時間中所進行， 並且他還有一大堆想法。 首先他想要完成工具箱程式庫（toolkit library）及其文件， 這樣更多的編輯器、任務列（task bars）、檔案管理器、網頁瀏覽器、 電子郵件程式和以 TTY 作為基礎的程式可以被擴展來使用它。

For these tasks Massimiliano explicitly asked to relay his need for help, because there is still so much to do. He for instance seeks volunteers to document the communication library, creating a libTW screensaver, completing twdialog, the Twin equivalent of Dialog or work on twclip, a utility to copy and paste the contents of a clipboard.

對於這些任務， Massimiliano 明確地請求「傳達他的需要」的幫助， 因為還有許多要做的事情。 舉例來說他尋找從事下列工作的自願者： 通信程式庫的文件化、 建立一個 libTW 螢幕保護程式、 完成 twdialog （Twin 中的對話框〔Dialog〕同等物） 或在 twclip （一個可以複製和貼上 clipboard 中的內容的實用性程式） 上的工作。

Those who are interested in participating should take a look at the mailing list, users will for instance find Twin already present in the stable branch of the Debian distribution.

有興趣參與的人應該要看一下郵寄清單， 使用者將會， 舉例來說， 發現 Twin 已經出現在 Debian 散佈件的穩定版本（stable branch） 中了。
C++ 套件（C++ Packages）

The column continues with some projects that should make the life of C++ developers more easy and have all been released by Christian Holm around December 1st 2002. [7]

這個專欄接下來將以一些應該可以讓 C++ 開發員〔的日子〕 好過一點的計畫繼續， 它們大約在二○○二年都己經由 Christian Holm 發布了。 [7]

When people shall communicate with computers, they need to agree upon a common language to be used in communication. Especially when this communication does not happen in real time or is very complex. That is for instance the case with programming languages or configuration files.

當人們以電腦進行通信時， 他們需要同意在通信中使用一個共同的語言。 特別是當這個通信並沒有即時地發生或是非常複雜的時候。 那正是如程式設計語言或組態檔案所顯示的情形。

The basic problem is that functions for syntax checking and reading or evaluating of such languages can easily become very complex. And when changes of definition or grammar become necessary, this often results in a very time consuming search for bugs.

最基本的問題是， 給語法檢查用的函數以及這樣子的語言的讀入或求算 （reading or evaluating）可以很容易地就變得非常複雜。 而且當定義或語法的改變成為必要時， 通常會導致非常耗時的臭蟲搜尋。

Additionally, creating such functions tends to be a tedious job without major intellectual feats, which programmers seek to avoid.

此外， 建立這樣的函數傾向於變成一種冗長的工作， 而沒有主要的智力挑戰〔的成就感〕， 而這是程式員所尋求要避免的。

For this reason, tools have been created that can automate the translation of definitions of grammar into functions that can read that grammer. Of course this means that the definition of grammar itself needs to be machine readable. The probably most common form of such a definition is the "Lookahead Left to Right Parsing" (LALR) context-free grammar.

一些工具已經由於這個原因被建立出， 並且也可以用來自動地轉譯語法的定義到「可以讀入那個語法的函數」。 當然這表明了語法的定義本身也需要是機器可讀的。 這樣一個定義的最為共同的形式可能是“前看由左至右剖析” （Lookahead Left to Right Parsing ； LALR） 的環境無關（context-free）語法。

One of the best and most-popular LALR(1) parser is Bison, [8] the Yacc equivalent of the GNU Project. Yacc itself stands for "Yet Another Compiler-Compiler" and Bison has deliberately been kept compatible to Yacc in order to ease transition from Yacc to Bison.

其中一個最好並且最受歡迎的 LALR(1) 剖析器是 Bison ， [8] 它是 GNU 計畫的 Yacc 同等物。 Yacc 它本身指的是“又一個用來製作編譯器的編譯器” （Yet Another Compiler-Compiler） 並且 Bison 刻意地保持與 Yacc 的相容以簡化從 Yacc 到 Bison 的轉移。

An application often working hand in hand with Bison is Flex, [9] which can be used to generate routines that allow dissecting a source input into single expressions, because it automates generation of source code for pattern matching. Flex is also the GNU-counterpart to another program - in this case "Lex"

一個通常與 Bison 一同工作的應用程式是 Flex ， [9] 它可以被用來建立允許「解析一個來源輸入到單一表示式」的規則， 因為它自動化了源碼的樣式比對的建立。 Flex 也是另一個程式的 GNU 對等物 - 在這裡〔這個程式〕則是“Lex”。

Hopefully this short introduction was also understandable for not-so-technical readers; if you wish to learn more about this, the web provides some good entry points. [10]

希望這個簡短的介紹， 對於並不那麼具有技術背景的讀者而言也是可以理解的； 如果你想要學習到更多關於這個〔的相關知識〕， 這個網站提供了一些很好的進入點。 [10]
“Yacc/Lex--”（剖析器／掃描器的 C++ 標頭檔）

Both Bison [8] and Flex [9] usually create C source code. Is this code used in C++, they tend to clutter the global namespace; also there are no C++ interfaces available.

Bison [8] 和 Flex [9] 這兩者通常建立 C 〔語言〕源碼。 如果這代碼在 C++ 中使用， 它們有傾向將全域名稱空間（global namespace）搞得一團亂〔的狀況〕； 同時也沒有 C++ 介面可以取得。

For this reason Christian Holm Christiansen has written a group of header files called Yacc/Lexx--, which allow encapsulating the C output of Bison and Flex in C++ classes. In this, the changes to the parser/scanner specifications were deliberately kept at a minimum to allow for greatest possible flexibility.

由於這個原因， Christian Holm Christiansen 已經編寫了一群稱為 Yacc/Lexx-- 的標頭檔（header files）， 它們允許將 Bison 與 Flex 的 C 語言輸入封裝到 C++ 類別（classes）中。 在此， 對「剖析器／掃瞄器」規格書（specifications）的改變， 都被慎重地維持在最少〔的狀況〕， 以允許最大的可能變通性。

In fact Flex itself provides capabilities to generate C++ sourcecode, but the output was too inflexible for Christians liking and also it didn't fit well with the parser classes generated by Bison. Therefore he wanted a common capsulation for both. In fact it was this asymmetry between the C output of Bison and the C++ output of Flex that made him start this project.

事實上， Flex 它本身提供了建立 C++ 源碼的能力， 但是這輸出太過於無法變通， 所以並不合 Christians 的意， 而且它也沒有與 Bison 所建立的剖析器類別很好地搭配。 因此他想要一個可以為兩者所使用的共同封裝。 事實上， 正是由於 Bison 的 C 輸出和 Flex 的 C++ 輸出之間的不對稱， 使得他開始了這個計畫。

Compared to projects like bison++, which has the advantage of direct C++ output, Christian sees the advantages of his method in being independent from the internals of the employed Yacc/Lex implementation. Therefore it is more stable with respect to changes in the Yacc/Lex projects and not immediately affected by their internal modifications.

與類似 bison++ 的計畫相比， 它有著一個直接的 C++ 輸出的優點， Christian 看到了他的方法， 因為獨立於部署的 Yacc/Lex 實作的內部（internals）， 因此就「在 Yacc/Lex 計畫內的改變」而言它較為穩定， 並且不會立即地由於它們內部〔所作出〕修改而受影響。

But there are also some Yacc/Lex clones displaying odd behaviour and are not POSIX compliant; these can be problematic to use, which is a special problem of this project.

但是也有一些 Yacc/Lex 仿製品表現出奇怪的行為， 並且不合乎（compliant） POSIX 〔標準〕； 這些可能會對使用造成問題， 這是這個計畫的一個特殊問題。

Therefore Christian plans for the close future to test more Yacc/Lex implementations and would be happy about help in this area. Also help testing it on other platforms and with different compilers would be very welcome.

因此 Christian 打算在最近的將來測試更多的 Yacc/Lex 實作品， 並且他會很高興在這個領域上獲得幫忙。 另外在其它的平台和以不同的編譯器測試它也是非常歡迎的。
“Readline--”（提供程式具有命令列功能的 C++ 程式庫）

The GNU Readline Library [11] provides functions that allow integrating a versatile commandline into other projects.

GNU Readline 程式庫 [11] 提供了允許「整合一個用途廣泛的命令列到其它計畫」的一些函數。

Among the features of GNU Readline are a vi and EMACS mode, it can save old input, recreate it and allow editing it again or also complete the beginnings of previously entered commands similar to the csh shell.

GNU Readline 的特色中有一個 vi 與 EMACS 模式， 它可以儲存舊的輸入、 重新建立它並且允許再次編輯它， 或者也〔可以〕完成類似於 csh 外殼的先前輸入， 〔而尚未完成的〕指令的起頭。

The Readline-- project by Christian Holm Christensen allows C++ programmers to access the GNU Readline Library by means of C++ classes. Not surprisingly, C++ developers seeking to include a commandline interface in their applications are the main target group of this project.

由 Christian Holm Christensen 所完成的 Readline-- 計畫， 允許 C++ 程式員〔直接〕用 C++ 類別的方式取用 GNU Readline 程式庫。 沒有讓人意外的是， 尋求將一個命令列介面包括到他們的應用程式中的 C++ 開發員， 是這個計畫的主要目標群組。

The program originated when Christian himself needed a commandline interface to test his C++ parser, a task during which he also created the previous project.

這個程式是在當 Christian 他自己需要一個命令列介面， 以測試他的 C++ 剖析器的時候開始， 那是一個在他也建立了前面的計畫期間內的任務。

The largest problem is currently that the library is not yet , so it should be handled with care in complex applications. Fixing this as well as improving the interface are Christians next plans for the project, because even though the interface is complete, he considers it not intuitive in some places.

目前最大的問題是， 這個程式庫還不是線程安全（thread safe）的， 所以在複雜的應用程式中它應該要被小心地處理。 修正這個〔問題〕以及改進介面是 Christians 這個計畫的下一步， 因為即使介面被完成了， 他〔還是〕認為它在某些地方不夠直觀。
“Option--”（使用命令列選項）

With Option--, Christian provides a C++ parser for commandline options; a library that allows C++ programs to find and evaluate commandline options passed at program start.

經由 Option-- ， Christian 提供了一個為命令列選項（options）〔所用的〕 C++ 剖析器； 〔那是〕一個允許 C++ 程式找出並求算（find and evaluate） 在程式一開始傳遞〔進去〕的命令列選項。

The major advantage of the project compared with similar projects is that possible options are represented by template-classes, which makes the project very flexible. Option-- only works for non-positional arguments, though. So if the user needs to be forced by syntax to only use a certain option at a certain position in the commandline, Option-- is not a good choice.

這個計畫與相似的計畫相比的主要優點就是， 可能的選項是由樣板類別（template-classes）所表示， 這使得這個計畫相當具有變通性。 然而， Option-- 只作用在非位置引數（non-positional arguments）〔的實用〕上。 所以如果使用者的需要受到了語法〔規則〕的強迫， 而只能夠使用在命令列中特定位置的特定選項， 那麼 Option-- 並不是個好選擇。

The first lines of this project were written by Christian, when the ROOT project needed commandline-options, even though that project later used another solution.

這計畫的前面幾行是由 Christian 所編寫的， 當 ROOT 計畫需要命令列選項（commandline-options）時， 雖然那個計畫在稍後使用了另一個解決方案。

But when he discovered to need something of the kind himself, Christian completed the project and by now it has gotten so stable that there are little plans besides further tests.

但是當他發現到他自己有那類型的需求時， Christian 完成這個計畫， 並且現在它已經變得如此地穩定， 除了更進一步的測試之外只有很少的〔修改〕打算。
“Thread--”（在 C++ 程式中使用線程）

The last project by Christian Holm Christensen in this issue is Thread--, a project to use Threads in C++ programs.

在本期中由 Christian Holm Christensen 所完成的最後一個計畫是 Thread-- ， 那是一個在 C++ 程式中使用線程（Threads）的計畫。

Since the concept of "Threads" is most likely not known to all readers, a short explanation is probably in order.

由於“線程”（Threads）的概念很有可能並沒有被所有的讀者瞭解， 〔因此，有〕一個簡短的解釋可能會比較好。

Essentially, all computers work linear. If they get a task, they will complete it step by step in the given order with all their capacity. In most cases, this would only allow running one program at a time, however.

本質上， 所有的電腦都是線性地進行工作。 如果它們有了一項任務， 它們會全力地以給定的次序將它一步一步地完成。 然而， 在大部份的情況這將只會容許在同一個時間執行一個程式。

In order to allow working on several programs simultaneously - the so-called "Multi-Tasking" - the executing kernel of the computer, the processor, jumps from task to task. Each of these tasks in turn is again worked on in a strictly linear fashion, but the method allows splitting the computers capacity between different programs.

為了允許同時地處理幾個程式 - 也就是所謂的“多工”（Multi-Tasking） - 電腦的執行內核（處理器）〔必須〕在任務與任務間跳躍。 每一個這些的任務輪流著以一個嚴格的線性方式再一次地〔進行〕處理， 但是這個方法允許在不同的程式間分擔電腦的能力。

As the programs and their tasks become more complex, working only strictly linear within a program is increasingly insatisfactory. A solution to this problem are threads, which allow splitting programs into different "task threads" that again can be worked on linearily to solve different subunits of the complex problem.

隨著程式以及它們的任務變得更加複雜， 在一個程式中只以嚴格的線性方式進行工作也變得愈來愈不合適。 針對這個問題的一個解決方案就是線程， 它允許將程式拆解成不同的“任務線程”， 因而再一次， 〔電腦〕可以線性地解決複雜問題的不同次要單元（subunits）。

The interaction and communication between these different threads of course also needs to be coordinated and controlled, a functionality which can be accessed by means of Thread-- from C++.

介於這些不同線程之間的互動和通信當然也需要被協調和控制， 那是一個可以經由 C++ 的 Thread-- 而被取用的功能（functionality）。

Different from similar projects like Boost::Thread, ZThread or Common C++, Thread-- does not distribute preprocessor macros throughout the source code. Implementation specific parts are instead put into Traits. This makes the library quite small and extensible.

與像是 Boost::Thread 、 ZThread 或 Common C++ 等類似計畫不同的是： Thread-- 並沒有散佈前置處理器（preprocessor）巨集碼（macros）， 而使其遍及源碼〔之中〕。 取而代之的是實作品的特定部份被放到 Traits 中。 這使得這個程式庫很小並且可以擴充。

Christian originally began working on Thread-- in order to test the thread-safety of Readline-- and according to him it works fine on GNU/Linux, but GCC versions of 2.95.x and below are problematic, so it is advisable to check for the GCC version.

Christian 最初開始致力於 Thread-- 上是為了測試 Readline-- 的線程安全， 並且根據他的說法， 它在 GNU/Linux 運作地還好， 但是 GCC 2.95.x 或以下的版本還有點問題， 因此建議檢查一下 GCC 的版本。

The other problems are semaphores under Solaris and Threads under Win32; he could not test it on other platforms. Help with these problems as well as information about other platforms is very welcome.

其它的問題有在 Solaris 下的信號器（semaphores） 還有在 Win32 下的線程； 他沒有辦法在其它平台上測試它。 對於這些問題的幫忙以及關於其它平台的資訊是非常歡迎的。

So far enough of the projects written by Christian. Regular readers of the Brave GNU World will have noticed that two essential pieces of information are still missing. These will now be provided.

到目前為止， 由 Christian 所編寫的計畫已經足夠了。 《勇敢 GNU 世界》的老讀者將已經注意到資訊中的兩個必要片斷還付諸闕如。 現在〔我們〕將要來提供這些。

First: The programming language used for all projects is C++ with the GNU Autotools and second: All projects are available as Free Software under the GNU Lesser General Public License (LGPL) available. All of them can be found on the C++ page of Christian. [7]

首先：所有計畫所使用的程式設計語言是搭配 GNU Autotools 的 C++ ； 其次：所有的計畫都可以在 GNU Lesser General Public License (LGPL) 下作為自由軟體取得。 它們全部都可以在 Christian 的 C++ 頁面中找到。 [7]
第六屆歐洲委員會架構網領（6th EC Framework Progamme）

As mentioned in issue 40 [12] of the Brave GNU World, the FSF Europe [13] wrote a recommendation [14] to the European Commission on April 30th, 2002. The recommendation, which was supported by over 50 parties throughout Europe, first explained the advantages of Free Software for the region Europe and European countries in order to then suggest giving Free Software priority status.

如同在《勇敢 GNU 世界》第 40 期中所提到的， [12] FSF 歐洲 [13] 在二○○二年四月三十日撰寫了一份推薦書 [14] 給歐洲委員會。 這份由遍及歐洲的五十個團體所支持的推薦書， 首先解釋了自由軟體在歐洲區域以及歐洲國家的優點， 以為了接著提議給予自由軟體優先權狀態（priority status）。

The background for this recommendation was the 6th Framework Programme [15] for European funding of Research and Development, which was decided upon last year. These programs always run for four years and contain most of the European funds for the scientific area. In this, one of its main goals is to further the European economy and society through funding of research and development.

這個推薦書的背景是， 在去年被決定的提供歐洲研發資金的第六屆架構網領 [15] 。 這些〔政策〕網領總是以四年〔為一期〕來實行， 並且包含了大部份科學領域的歐洲資金提供。 在此， 其中一個它的主要目標在於經由提供研發資金， 以更進一步地促進歐洲的經濟和社會〔發展〕。

Although the 5th Framework Programme already contained some first initiatives for Free Software, the 6th Framework Programme originally did not plan to further Free Software in any way. Therefore the FSF Europe issued the aforementioned recommendation.

雖然第五屆的架構網領已經包含了一些自由軟體的初步提議， 第六屆架構網領在最初卻也沒有以任何方式促進自由軟體的打算。 因此 FSF 歐洲提出了上述的推薦書。

On December 17th 2002 the 6th Framework Programme was finalized and it seems that the recommendation to make Free Software the preferred form for project proposals has been heard. The "Information Society Technologies" (IST) Work Programme, in which the funding of computer science and information technology is handled, now contains a statement that can give Free Software projects in the evaluation process.

在第六屆架構網領於二○○二年十二月十七日結束後， 看起來這份推薦書使得自由軟體在已經聽取的計畫提出中成了較為優先的形式。 “資訊社會技術”（Information Society Technologies ； IST）工作網領， 也就是處理提供電腦科學和資訊技術資金的〔政策〕網領， 現在包含了一項陳述， 給予了自由軟體計畫得以處在評估過程（evaluation process） 中〔的機會〕。

This means effectively that the whole budget of the IST Work Programme, containing 1,725 billion Euro, has been opened for Free Software. This is most likely the largest sum that was ever available for Free Software funding; although of course not exclusively in this case.

這有效地表明， IST 工作網領的全部預算（包含十億七千二百五十萬歐元） 都已經對自由軟體開放了。 這相當有可能是可以為自由軟體提供資金的曾經出現的最大總數； 雖然（當然是這樣）在這個例子中並不是〔由自由軟體〕獨佔的。

In order to now support companies, universities and research centers to launch projects for and with Free Software within this framework, the FSF Europe sent out a request [16] on December 18th 2002, in which it asks all interested parties to get in touch.

現在為了要在這個網領中支持公司、大學和研究中心， 使其為了或以自由軟體開始〔新的〕計畫， FSF 歐洲在二○○二年十二月十八日送出了一個請求 [16] ， 要求所有有興趣的團體〔與其〕取得聯繫。

The goal is to possibly create a Free Software project for each of the important areas addressed in the 6th Framework Programme, in order to avoid seeing these funds spent on proprietary software. Because areas like eDemocracy, eHealth or eSecurity could have massive effects on our future and must be addressed with Free Software.

目標是在可能的範圍內， 在第六屆架構網領中所提及的每一個重要領域都建立一個自由軟體計畫， 以避免看到這些資金被花在私權的軟體上。 因為像是 eDemocracy （電子民主）、 eHealth （電子保健）或 eSecurity （電子安全）等領域， 對於我們的未來可以發揮重大的影響， 因此必須以自由軟體〔的形式〕來加以表達。

It takes a lot of time and effort to set up these projects, get them organized and coordinated with the administration in Brussels, but the FSF Europe will do as much as it can to see Free Software projects use the possibilities that it created.

建立起這些計畫、 使它們具有組織並且與在布魯塞爾（Brussels） 的管理部門進行協調將會花去許多時間和努力， 但 FSF 歐洲將會竭盡所能地， 以看到自由軟體計畫利用它所創造出來的可能性。
《TUX&GNU@school》（教育領域專欄）

Towards the end of this issue it is my pleasure to point readers to another remarkable column. Mario Fux, himself a long-time reader of the Brave GNU World, began last year to write a similar column dedicated specifically to Free Software in school.

接近了這一期的尾聲， 我很高興地向讀者指出另一個出色的專欄。 Mario Fux ，他本身是個《勇敢 GNU 世界》的長期讀者， 在去年開始了撰寫一個特別地致力於在學校中的自由軟體的類似專欄。

By now he has finished 5 issues of the "TUX&GNU@school" column in German and English, which has found its new home on the FSF Europe home page. [17] I wish Mario, as well as Christian Selig and Kristian Rink, who support him as a kind of editorial board, all the best for the future and encourage especially - though not only - readers from the educational field to take a look at it.

目前為止， 他已經以德文和英文完成了 5 期的“TUX&GNU@school”專欄， 並且已經找到了它在 FSF 歐洲首頁中的新家。 [17] 我希望 Mario 以及作為一種編輯群的 Christian Selig 和 Kristian Rink 未來的一切都很好， 同時也特別地鼓勵來自教育界（以及其它領域）的讀者可以看一看它。
下月待續

Enough Brave GNU World for this month, as usual I'd like to ask for questions, ideas and comments by mail. [1]

本月份的《勇敢 GNU 世界》〔已經〕足夠了， 和平常一樣， 我想請求〔大家〕以郵件寄來問題、想法和意見。 [1] 【譯註：請以英文或德文撰寫郵件，其他的語言無法被瞭解； 或以中文送到本文翻譯。】

This address is also where project proposals should be sent. And I'd like to encourage all authors to take the time. It may seem suspiciously like writing documentation, but it is a good way to inform other people about your project.

這個位址也是計畫提出（project proposals）應該要送到的地方。 我也想要鼓勵所有〔計畫〕的作者花點時間〔提出你的計畫〕。 看起來可能會十分類似於撰寫文件（documentation）， 但〔卻〕是個通知其他人有關於你的計畫的好方法。

And also please do not worry about your project not being important enough. In fact I still have to encounter a project that would not be interesting enough to at least write a few interesting lines about it.

同時也請不必擔心你的計畫還不夠重要。 事實上我還沒有遇過一個無趣到讓我寫不出幾行有趣文字的計畫。

So much for now, until next month.

就到此為止， 下個月見。
