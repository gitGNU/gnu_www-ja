
程式設計概論
************

本節討論了在設計程式時，你應該加入考慮的一些議題。

使用什麼語言
============

當你想要使用一種可以在編譯和運行時都很快速的語言，最佳的選擇是 C 語言。使用其它語言就像是使用「非標準」的功能特色：它會對使用者造成困難。即使 GCC 支援了其它的語言，使用者也許會發現「需要去安裝針對那個其它語言的編譯器，以為了建立你的程式」不太方便。舉例來說，如果你以 C++ 撰寫了你的程式，人們將會需要安裝 GNU C++ 編譯器以用來編譯你的程式。

C 相較於 C++ 以及其它的編譯式語言具有一項額外的優勢：更多的人瞭解 C ，所以更多的人將會發現如果它是以 C 寫成的話，會較為容易閱讀以及修改程式。

如以一般而言，使用 C 語言，較之其它相對的替代品，是好得多的。

不過對於那項結論而言，我們有著兩個例外狀況：

   * 使用其它語言來撰寫「特別著眼於給那個語言使用的」一個工具程式是沒有問題的。那是因為唯一會想要去建立那個工具的人，不管怎樣都會去安裝另外的語言。

   * 如果一支應用程式只對於社群的一小部分有用的話，那麼它以什麼語言寫成的問題，對於其他人就較沒有影響，所以只要你自己高興就好了。

許多程式都被設計成具有可擴充性：它們包括有一個較 C 高階的語言的解譯器。通常程式的許多部份本身也是以那種語言寫成的。 Emacs 編輯器在這項技術上佔有先驅地位。

GNU 軟體的標準擴充性解譯器是 GUILE ，它實作了 Scheme 語言（一種 Lisp 語言特別簡潔、清楚的方言）  `http://www.gnu.org/software/guile/' 。我們並不拒絕以其它像是 Perl 和 Python 的「腳本語言」所撰寫的程式，但是使用 GUILE 對於 GNU 系統的整體一致性是相當重要的。

與其它實作品的相容性
====================

在一些偶爾的例外中，為 GNU 寫的實用程式和程式庫，應該要與 Berkeley Unix 中的那些對等物、標準 C （如果標準 C 指定了它們的行為的話）、以及 POSIX （如果標準 POSIX 指定了它們的行為的話）保持向上相容。

當這些標準互相衝突時，提供它們中的每一個有著自己的「相容模式」是很有用的。

標準 C 和 POSIX 禁止了許多類型的擴充。但不管怎樣，「自由地」去製作那些擴充，並且包括一個 `--ansi' 、 `--posix' 、或 `--compatible' 選項來將它們關閉。然而，如果這擴充有著極大的機會使任何真實的程式或腳本毀損，那麼它就並不真的是向上相容了。如以你應該試著重新設計它的介面，並且使它向上相容。

許多 GNU 程式在當環境變數 `POSIXLY_CORRECT' 被定義時（即使它是定義為空值），壓制著與 POSIX 相衝的擴充。如果適當的話，請讓你的程式認得這個變數。

當一個功能特色只被使用者所使用（而不是給程式或命令檔案使用），並且它在 Unix 中實在沒有做得很好，你可以大方地將它完全地替換為某種完全不同而且更好的東西（舉例來說， `vi' 被 Emacs 替換）。但是同時提供一個相容的功能特色會是很優的（因為存在著一支 `vi' 的仿製品，所以我們也提供它）。

不管它們是否有前例可循，額外的有用功能特色都是歡迎的。

使用非標準的功能特色
====================

已經存在的許多 GNU 設施，相較於相對應的 Unix 設施而言，支援了許多的方便擴充。在實作你的程式時，是否要使用這些擴充是個難題。

一方面，使用這些擴充可以製作出一個較為乾淨的程式。另一方面，除非其它的 GNU 工具可以取得，否則人們將無法建立程式。這可能會造成程式只在較少種類的機器上工作。

「採用某些擴充」也許可以簡單地同時提供兩種可選替代。舉例來說，你可以定義具有「關鍵字」 `INLINE' 的函數，並且定義那作為一個巨集，用來根據編譯器而擴展成 `inline' 或什麼也不是。

一般而言，如果你可以直截了當地不用它們做事的話，也許最好是不要去使用擴充，不過如果它們是個大改進的話，還是去使用吧。

對於這個規則的一個例外是，運行在非常多不同類型系統的大型、建構良好的程式（像是 Emacs）。在這樣的程式中使用 GNU 擴充會讓許多使用者不高興，所以我們不那樣做。

另外一個例外是對那些用來作為編譯品的一部份的程式：它所指的是必須以其它編譯器編譯，以啟動 GNU 編譯品設施的任何事。如果這些需要 GNU 編譯器，那麼如果並沒有已經安裝好它們，沒有人可以編譯它們。那在特定的情形下會是極端地麻煩。

標準與標準以前的 C 語言
=======================

一九八九年的標準 C 現在已經足夠普及了，使用它的功能特色在新程式中是沒有問題的。但有個例外：絕不要使用標準 C 的 "trigraph" 功能特色。

一九九九年標準 C 還沒有普及，所以請不要在程式中採用它的功能特色。不過如果它們存在的話，使用它的功能特色是沒問題的。

然而，在大部份的程式中，支援「標準以前的編譯器」是容易的，所以如果你知道如何做，儘管去做。如果你在維護的程式有著這樣的支援，你應該試著保持它的可用性。

要支援標準以前的 C ，那麼就不要以標準原型式來撰寫函數定義，

     int
     foo (int x, int y)
     ...

而要以標準以前的形式來撰寫定義，像這樣，

     int
     foo (x, y)
          int x, y;
     ...

並且使用一個個別的宣告來指定引數原型：

     int foo (int, int);

不管怎樣，你在標頭檔中需要一個這樣的宣告，以在所有呼叫到函數的檔案中獲得使用原型的利益。同時一旦你有了這宣告，正常來講，以標準以前形式來撰寫函數定義也沒有什麼損失。

這項技術對於較 `int' 更窄的整數型並不適用。如果你認為一個引數應該是較 `int' 更窄的型別，將它宣告為 `int' 以作為替代。

有幾個這項技術難以使用的特別情形。舉例來說，如果一個函數引數需要持有系統型別 `dev_t' ，你就有了麻煩，因為 `dev_t' 在一些機器上比 `int' 還短；但是你無法使用 `int' 作為替代，因為 `dev_t' 在某些機器上比 `int' 寬。在一個非標準的定義中，並沒有一個你可以安全地在所有的機器上使用的型別。要「支援非標準 C 並且傳遞這樣一個引數」的唯一方式是，使用 Autoconf 來檢查 `dev_t' 的寬度，並且據之選擇引數型別。這也許並不值上這個麻煩。

為了支援並不認得原型的標準前編譯器，你也許會想要使用像是這樣的前處理器巨集，像是這樣：

     /* Declare the prototype for a general external function.  */
     #if defined (__STDC__) || defined (WINDOWSNT)
     #define P_(proto) proto
     #else
     #define P_(proto) ()
     #endif

條件式編譯
==========

當「支援的配置選項」在當建立你的程式時就已經知道時，我們較為屬意使用 `if (... )' 在條件式編譯上，因為在前面的情形中，編譯器會實行較大規模的「所有可能的代碼路徑檢查」。

舉例來說，請撰寫成

       if (HAS_FOO)
         ...
       else
         ...

而不是：

       #ifdef HAS_FOO
         ...
       #else
         ...
       #endif

一個像是 GCC 的現代編譯器，在這兩種情形都將會生成完全相同的代碼，並且我們也成功地使用了類似的技術在數個計畫中了。當然，前一個方法假定了 `HAS_FOO' 被定義為 0 或 1 這兩者其一。

雖然這並不是解決所有的移植問題的銀彈（治本方法），而且也不總是適當的，不過遵循著這項策略將會每年節省了 GCC 開發者許多小時數，或甚至天數。

在「類函數」的巨集，像是在 GCC 中的 `REVERSIBLE_CC_MODE' 的情形中，並不能就只是在 `if( ...)' statements 中被使用，我們有個簡單的處理方式。就再導入另一個巨集，如在下面的例子中的作法：

       #ifdef REVERSIBLE_CC_MODE
       #define HAS_REVERSIBLE_CC_MODE 1
       #else
       #define HAS_REVERSIBLE_CC_MODE 0
       #endif

