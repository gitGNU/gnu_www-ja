<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.52
     from ../texi/cvs.texinfo on 7 November 1998 -->

<TITLE>CVS--Concurrent Versions System - Multiple developers</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="cvs_1.html">first</A>, <A HREF="cvs_6.html">previous</A>, <A HREF="cvs_8.html">next</A>, <A HREF="cvs_25.html">last</A> section, <A HREF="cvs_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC37" HREF="cvs_toc.html#TOC37">Multiple developers</A></H1>
<P>
<A NAME="IDX127"></A>
<A NAME="IDX128"></A>
<A NAME="IDX129"></A>
<A NAME="IDX130"></A>
<A NAME="IDX131"></A>
<A NAME="IDX132"></A>
<A NAME="IDX133"></A>
<A NAME="IDX134"></A>

</P>
<P>
When more than one person works on a software project
things often get complicated.  Often, two people try to
edit the same file simultaneously.  One solution, known
as <EM>file locking</EM> or <EM>reserved checkouts</EM>, is
to allow only one person to edit each file at a time.
This is the only solution with some version control
systems, including RCS and SCCS.  CVS
doesn't have a very nice implementation of reserved
checkouts (yet) but there are ways to get it working
(for example, see the <CODE>cvs admin -l</CODE> command in
section <A HREF="cvs_20.html#SEC92">admin options</A>).  It also may be possible to use
the watches features described below, together with
suitable procedures (not enforced by software), to
avoid having two people edit at the same time.

</P>
<P>
The default model with CVS is known as
<EM>unreserved checkouts</EM>.  In this model, developers
can edit their own <EM>working copy</EM> of a file
simultaneously.  The first person that commits his
changes has no automatic way of knowing that another
has started to edit it.  Others will get an error
message when they try to commit the file.  They must
then use CVS commands to bring their working copy
up to date with the repository revision.  This process
is almost automatic.

</P>
<P>
CVS also supports mechanisms which facilitate
various kinds of communcation, without actually
enforcing rules like reserved checkouts do.

</P>
<P>
The rest of this chapter describes how these various
models work, and some of the issues involved in
choosing between them.

</P>



<H2><A NAME="SEC38" HREF="cvs_toc.html#TOC38">File status</A></H2>
<P>
<A NAME="IDX135"></A>
<A NAME="IDX136"></A>

</P>
<P>
Based on what operations you have performed on a
checked out file, and what operations others have
performed to that file in the repository, one can
classify a file in a number of states.  The states, as
reported by the <CODE>status</CODE> command, are:

</P>
<DL COMPACT>

<DT>Up-to-date
<DD>
<A NAME="IDX137"></A>
 
The file is identical with the latest revision in the
repository for the branch in use.

<DT>Locally Modified
<DD>
<A NAME="IDX138"></A>
You have edited the file, and not yet committed your changes.

<DT>Locally Added
<DD>
<A NAME="IDX139"></A>
You have added the file with <CODE>add</CODE>, and not yet
committed your changes.

<DT>Locally Removed
<DD>
<A NAME="IDX140"></A>
You have removed the file with <CODE>remove</CODE>, and not yet
committed your changes.

<DT>Needs Checkout
<DD>
<A NAME="IDX141"></A>
Someone else has committed a newer revision to the
repository.  The name is slightly misleading; you will
ordinarily use <CODE>update</CODE> rather than
<CODE>checkout</CODE> to get that newer revision.

<DT>Needs Patch
<DD>
<A NAME="IDX142"></A>
Like Needs Checkout, but the CVS server will send
a patch rather than the entire file.  Sending a patch or
sending an entire file accomplishes the same thing.

<DT>Needs Merge
<DD>
<A NAME="IDX143"></A>
Someone else has committed a newer revision to the repository, and you
have also made modifications to the file.

<DT>Unresolved Conflict
<DD>
<A NAME="IDX144"></A>
This is like Locally Modified, except that a previous
<CODE>update</CODE> command gave a conflict.  You need to
resolve the conflict as described in section <A HREF="cvs_7.html#SEC40">Conflicts example</A>.

<DT>Unknown
<DD>
<A NAME="IDX145"></A>
CVS doesn't know anything about this file.  For
example, you have created a new file and have not run
<CODE>add</CODE>.

</DL>

<P>
To help clarify the file status, <CODE>status</CODE> also
reports the <CODE>Working revision</CODE> which is the
revision that the file in the working directory derives
from, and the <CODE>Repository revision</CODE> which is the
latest revision in the repository for the branch in
use.

</P>
<P>
For information on the options to <CODE>status</CODE>, see
section <A HREF="cvs_20.html#SEC128">status--Display status information on checked out files</A>.  For information on its <CODE>Sticky tag</CODE>
and <CODE>Sticky date</CODE> output, see section <A HREF="cvs_8.html#SEC54">Sticky tags</A>.
For information on its <CODE>Sticky options</CODE> output,
see the <SAMP>`-k'</SAMP> option in section <A HREF="cvs_20.html#SEC133">update options</A>.

</P>


<H2><A NAME="SEC39" HREF="cvs_toc.html#TOC39">Bringing a file up to date</A></H2>
<P>
<A NAME="IDX146"></A>
<A NAME="IDX147"></A>
<A NAME="IDX148"></A>
<A NAME="IDX149"></A>

</P>
<P>
When you want to update or merge a file, use the <CODE>update</CODE>
command.  For files that are not up to date this is roughly equivalent
to a <CODE>checkout</CODE> command: the newest revision of the file is
extracted from the repository and put in your working copy of the
module.

</P>
<P>
Your modifications to a file are never lost when you
use <CODE>update</CODE>.  If no newer revision exists,
running <CODE>update</CODE> has no effect.  If you have
edited the file, and a newer revision is available,
CVS will merge all changes into your working copy.

</P>
<P>
For instance, imagine that you checked out revision 1.4 and started
editing it.  In the meantime someone else committed revision 1.5, and
shortly after that revision 1.6.  If you run <CODE>update</CODE> on the file
now, CVS will incorporate all changes between revision 1.4 and 1.6 into
your file.

</P>
<P>
<A NAME="IDX150"></A>
If any of the changes between 1.4 and 1.6 were made too
close to any of the changes you have made, an
<EM>overlap</EM> occurs.  In such cases a warning is
printed, and the resulting file includes both
versions of the lines that overlap, delimited by
special markers.
See section <A HREF="cvs_20.html#SEC132">update--Bring work tree in sync with repository</A>, for a complete description of the
<CODE>update</CODE> command.

</P>


<H2><A NAME="SEC40" HREF="cvs_toc.html#TOC40">Conflicts example</A></H2>
<P>
<A NAME="IDX151"></A>
<A NAME="IDX152"></A>
<A NAME="IDX153"></A>

</P>
<P>
Suppose revision 1.4 of <TT>`driver.c'</TT> contains this:

</P>

<PRE>
#include &#60;stdio.h&#62;

void main()
{
    parse();
    if (nerr == 0)
        gencode();
    else
        fprintf(stderr, "No code generated.\n");
    exit(nerr == 0 ? 0 : 1);
}
</PRE>

<P>
Revision 1.6 of <TT>`driver.c'</TT> contains this:

</P>

<PRE>
#include &#60;stdio.h&#62;

int main(int argc,
         char **argv)
{
    parse();
    if (argc != 1)
    {
        fprintf(stderr, "tc: No args expected.\n");
        exit(1);
    }
    if (nerr == 0)
        gencode();
    else
        fprintf(stderr, "No code generated.\n");
    exit(!!nerr);
}
</PRE>

<P>
Your working copy of <TT>`driver.c'</TT>, based on revision
1.4, contains this before you run <SAMP>`cvs update'</SAMP>:

</P>

<PRE>
#include &#60;stdlib.h&#62;
#include &#60;stdio.h&#62;

void main()
{
    init_scanner();
    parse();
    if (nerr == 0)
        gencode();
    else
        fprintf(stderr, "No code generated.\n");
    exit(nerr == 0 ? EXIT_SUCCESS : EXIT_FAILURE);
}
</PRE>

<P>
You run <SAMP>`cvs update'</SAMP>:

</P>

<PRE>
$ cvs update driver.c
RCS file: /usr/local/cvsroot/yoyodyne/tc/driver.c,v
retrieving revision 1.4
retrieving revision 1.6
Merging differences between 1.4 and 1.6 into driver.c
rcsmerge warning: overlaps during merge
cvs update: conflicts found in driver.c
C driver.c
</PRE>

<P>
<A NAME="IDX154"></A>
CVS tells you that there were some conflicts.
Your original working file is saved unmodified in
<TT>`.#driver.c.1.4'</TT>.  The new version of
<TT>`driver.c'</TT> contains this:

</P>

<PRE>
#include &#60;stdlib.h&#62;
#include &#60;stdio.h&#62;

int main(int argc,
         char **argv)
{
    init_scanner();
    parse();
    if (argc != 1)
    {
        fprintf(stderr, "tc: No args expected.\n");
        exit(1);
    }
    if (nerr == 0)
        gencode();
    else
        fprintf(stderr, "No code generated.\n");
&#60;&#60;&#60;&#60;&#60;&#60;&#60; driver.c
    exit(nerr == 0 ? EXIT_SUCCESS : EXIT_FAILURE);
=======
    exit(!!nerr);
&#62;&#62;&#62;&#62;&#62;&#62;&#62; 1.6
}
</PRE>

<P>
<A NAME="IDX155"></A>
<A NAME="IDX156"></A>
<A NAME="IDX157"></A>
<A NAME="IDX158"></A>
<A NAME="IDX159"></A>

</P>
<P>
Note how all non-overlapping modifications are incorporated in your working
copy, and that the overlapping section is clearly marked with
<SAMP>`&#60;&#60;&#60;&#60;&#60;&#60;&#60;'</SAMP>, <SAMP>`======='</SAMP> and <SAMP>`&#62;&#62;&#62;&#62;&#62;&#62;&#62;'</SAMP>.

</P>
<P>
<A NAME="IDX160"></A>
<A NAME="IDX161"></A>
You resolve the conflict by editing the file, removing the markers and
the erroneous line.  Suppose you end up with this file:

<PRE>
#include &#60;stdlib.h&#62;
#include &#60;stdio.h&#62;

int main(int argc,
         char **argv)
{
    init_scanner();
    parse();
    if (argc != 1)
    {
        fprintf(stderr, "tc: No args expected.\n");
        exit(1);
    }
    if (nerr == 0)
        gencode();
    else
        fprintf(stderr, "No code generated.\n");
    exit(nerr == 0 ? EXIT_SUCCESS : EXIT_FAILURE);
}
</PRE>

<P>
You can now go ahead and commit this as revision 1.7.

</P>

<PRE>
$ cvs commit -m "Initialize scanner. Use symbolic exit values." driver.c
Checking in driver.c;
/usr/local/cvsroot/yoyodyne/tc/driver.c,v  &#60;--  driver.c
new revision: 1.7; previous revision: 1.6
done
</PRE>

<P>
For your protection, CVS will refuse to check in a
file if a conflict occurred and you have not resolved
the conflict.  Currently to resolve a conflict, you
must change the timestamp on the file, and must also
insure that the file contains no conflict markers.  If
your file legitimately contains conflict markers (that
is, occurrences of <SAMP>`&#62;&#62;&#62;&#62;&#62;&#62;&#62; '</SAMP> at the start of a
line that don't mark a conflict), then CVS has
trouble handling this and you need to start hacking on
the <CODE>CVS/Entries</CODE> file or other such workarounds.

</P>
<P>
<A NAME="IDX162"></A>
If you use release 1.04 or later of pcl-cvs (a GNU
Emacs front-end for CVS) you can use an Emacs
package called emerge to help you resolve conflicts.
See the documentation for pcl-cvs.

</P>


<H2><A NAME="SEC41" HREF="cvs_toc.html#TOC41">Informing others about commits</A></H2>
<P>
<A NAME="IDX163"></A>
<A NAME="IDX164"></A>
<A NAME="IDX165"></A>

</P>
<P>
It is often useful to inform others when you commit a
new revision of a file.  The <SAMP>`-i'</SAMP> option of the
<TT>`modules'</TT> file, or the <TT>`loginfo'</TT> file, can be
used to automate this process.  See section <A HREF="cvs_21.html#SEC137">The modules file</A>.
See section <A HREF="cvs_21.html#SEC144">Loginfo</A>.  You can use these features of CVS
to, for instance, instruct CVS to mail a
message to all developers, or post a message to a local
newsgroup.

</P>


<H2><A NAME="SEC42" HREF="cvs_toc.html#TOC42">Several developers simultaneously attempting to run CVS</A></H2>

<P>
<A NAME="IDX166"></A>
If several developers try to run CVS at the same
time, one may get the following message:

</P>

<PRE>
[11:43:23] waiting for bach's lock in /usr/local/cvsroot/foo
</PRE>

<P>
CVS will try again every 30 seconds, and either
continue with the operation or print the message again,
if it still needs to wait.  If a lock seems to stick
around for an undue amount of time, find the person
holding the lock and ask them about the cvs command
they are running.  If they aren't running a cvs
command, look for and remove files starting with
<TT>`#cvs.tfl'</TT>, <TT>`#cvs.rfl'</TT>, or <TT>`#cvs.wfl'</TT>
from the repository.

</P>
<P>
Note that these locks are to protect CVS's
internal data structures and have no relationship to
the word <EM>lock</EM> in the sense used by
RCS---which refers to reserved checkouts
(see section <A HREF="cvs_7.html#SEC37">Multiple developers</A>).

</P>
<P>
Any number of people can be reading from a given
repository at a time; only when someone is writing do
the locks prevent other people from reading or writing.

</P>
<P>
<A NAME="IDX167"></A>
<A NAME="IDX168"></A>
One might hope for the following property

</P>

<PRE>
If someone commits some changes in one cvs command,
then an update by someone else will either get all the
changes, or none of them.
</PRE>

<P>
but CVS does <EM>not</EM> have this property.  For
example, given the files

</P>

<PRE>
a/one.c
a/two.c
b/three.c
b/four.c
</PRE>

<P>
if someone runs

</P>

<PRE>
cvs ci a/two.c b/three.c
</PRE>

<P>
and someone else runs <CODE>cvs update</CODE> at the same
time, the person running <CODE>update</CODE> might get only
the change to <TT>`b/three.c'</TT> and not the change to
<TT>`a/two.c'</TT>.

</P>


<H2><A NAME="SEC43" HREF="cvs_toc.html#TOC43">Mechanisms to track who is editing files</A></H2>
<P>
<A NAME="IDX169"></A>

</P>
<P>
For many groups, use of CVS in its default mode is
perfectly satisfactory.  Users may sometimes go to
check in a modification only to find that another
modification has intervened, but they deal with it and
proceed with their check in.  Other groups prefer to be
able to know who is editing what files, so that if two
people try to edit the same file they can choose to
talk about who is doing what when rather than be
surprised at check in time.  The features in this
section allow such coordination, while retaining the
ability of two developers to edit the same file at the
same time.

</P>
<P>
For maximum benefit developers should use <CODE>cvs
edit</CODE> (not <CODE>chmod</CODE>) to make files read-write to
edit them, and <CODE>cvs release</CODE> (not <CODE>rm</CODE>) to
discard a working directory which is no longer in use,
but CVS is not able to enforce this behavior.

</P>



<H3><A NAME="SEC44" HREF="cvs_toc.html#TOC44">Telling CVS to watch certain files</A></H3>

<P>
To enable the watch features, you first specify that
certain files are to be watched.

</P>
<P>
<A NAME="IDX170"></A>
<DL>
<DT><U>Command:</U> <B>cvs watch on</B> <I>[<CODE>-l</CODE>] files ...</I>
<DD><A NAME="IDX171"></A>

</P>
<P>
<A NAME="IDX172"></A>
Specify that developers should run <CODE>cvs edit</CODE>
before editing <VAR>files</VAR>.  CVS will create working
copies of <VAR>files</VAR> read-only, to remind developers
to run the <CODE>cvs edit</CODE> command before working on
them.

</P>
<P>
If <VAR>files</VAR> includes the name of a directory, CVS
arranges to watch all files added to the corresponding
repository directory, and sets a default for files
added in the future; this allows the user to set
notification policies on a per-directory basis.  The
contents of the directory are processed recursively,
unless the <CODE>-l</CODE> option is given.

</P>
<P>
If <VAR>files</VAR> is omitted, it defaults to the current directory.

</P>
<P>
<A NAME="IDX173"></A>
</DL>

</P>
<P>
<DL>
<DT><U>Command:</U> <B>cvs watch off</B> <I>[<CODE>-l</CODE>] files ...</I>
<DD><A NAME="IDX174"></A>

</P>
<P>
Do not provide notification about work on <VAR>files</VAR>.  CVS will create
working copies of <VAR>files</VAR> read-write.

</P>
<P>
The <VAR>files</VAR> and <CODE>-l</CODE> arguments are processed as for <CODE>cvs
watch on</CODE>.

</P>
</DL>



<H3><A NAME="SEC45" HREF="cvs_toc.html#TOC45">Telling CVS to notify you</A></H3>

<P>
You can tell CVS that you want to receive
notifications about various actions taken on a file.
You can do this without using <CODE>cvs watch on</CODE> for
the file, but generally you will want to use <CODE>cvs
watch on</CODE>, so that developers use the <CODE>cvs edit</CODE>
command.

</P>
<P>
<A NAME="IDX175"></A>
<DL>
<DT><U>Command:</U> <B>cvs watch add</B> <I>[<CODE>-a</CODE> action] [<CODE>-l</CODE>] files ...</I>
<DD><A NAME="IDX176"></A>

</P>
<P>
Add the current user to the list of people to receive notification of
work done on <VAR>files</VAR>.

</P>
<P>
The <CODE>-a</CODE> option specifies what kinds of events CVS should notify
the user about.  <VAR>action</VAR> is one of the following:

</P>
<DL COMPACT>

<DT><CODE>edit</CODE>
<DD>
Another user has applied the <CODE>cvs edit</CODE> command (described
below) to a file.

<DT><CODE>unedit</CODE>
<DD>
Another user has applied the <CODE>cvs unedit</CODE> command (described
below) or the <CODE>cvs release</CODE> command to a file, or has deleted
the file and allowed <CODE>cvs update</CODE> to recreate it.

<DT><CODE>commit</CODE>
<DD>
Another user has committed changes to a file.

<DT><CODE>all</CODE>
<DD>
All of the above.

<DT><CODE>none</CODE>
<DD>
None of the above.  (This is useful with <CODE>cvs edit</CODE>,
described below.)

</DL>

<P>
The <CODE>-a</CODE> option may appear more than once, or not at all.  If
omitted, the action defaults to <CODE>all</CODE>.

</P>
<P>
The <VAR>files</VAR> and <CODE>-l</CODE> option are processed as for the
<CODE>cvs watch</CODE> commands.

</P>
</DL>

<P>
<A NAME="IDX177"></A>
<DL>
<DT><U>Command:</U> <B>cvs watch remove</B> <I>[<CODE>-a</CODE> action] [<CODE>-l</CODE>] files ...</I>
<DD><A NAME="IDX178"></A>

</P>
<P>
Remove a notification request established using <CODE>cvs watch add</CODE>;
the arguments are the same.  If the <CODE>-a</CODE> option is present, only
watches for the specified actions are removed.

</P>
</DL>

<P>
<A NAME="IDX179"></A>
When the conditions exist for notification, CVS
calls the <TT>`notify'</TT> administrative file.  Edit
<TT>`notify'</TT> as one edits the other administrative
files (see section <A HREF="cvs_5.html#SEC20">The administrative files</A>).  This
file follows the usual conventions for administrative
files (see section <A HREF="cvs_21.html#SEC140">The common syntax</A>), where each line is a regular
expression followed by a command to execute.  The
command should contain a single ocurrence of <SAMP>`%s'</SAMP>
which will be replaced by the user to notify; the rest
of the information regarding the notification will be
supplied to the command on standard input.  The
standard thing to put in the <CODE>notify</CODE> file is the
single line:

</P>

<PRE>
ALL mail %s -s \"CVS notification\"
</PRE>

<P>
This causes users to be notified by electronic mail.

</P>
<P>
<A NAME="IDX180"></A>
Note that if you set this up in the straightforward
way, users receive notifications on the server machine.
One could of course write a <TT>`notify'</TT> script which
directed notifications elsewhere, but to make this
easy, CVS allows you to associate a notification
address for each user.  To do so create a file
<TT>`users'</TT> in <TT>`CVSROOT'</TT> with a line for each
user in the format <VAR>user</VAR>:<VAR>value</VAR>.  Then
instead of passing the name of the user to be notified
to <TT>`notify'</TT>, CVS will pass the <VAR>value</VAR>
(normally an email address on some other machine).

</P>


<H3><A NAME="SEC46" HREF="cvs_toc.html#TOC46">How to edit a file which is being watched</A></H3>

<P>
<A NAME="IDX181"></A>
Since a file which is being watched is checked out
read-only, you cannot simply edit it.  To make it
read-write, and inform others that you are planning to
edit it, use the <CODE>cvs edit</CODE> command.  Some systems
call this a <EM>checkout</EM>, but CVS uses that term
for obtaining a copy of the sources (see section <A HREF="cvs_4.html#SEC11">Getting the source</A>), an operation which those systems call a
<EM>get</EM> or a <EM>fetch</EM>.

</P>
<P>
<A NAME="IDX182"></A>
<DL>
<DT><U>Command:</U> <B>cvs edit</B> <I>[options] files ...</I>
<DD><A NAME="IDX183"></A>

</P>
<P>
Prepare to edit the working files <VAR>files</VAR>.  CVS makes the
<VAR>files</VAR> read-write, and notifies users who have requested
<CODE>edit</CODE> notification for any of <VAR>files</VAR>.

</P>
<P>
The <CODE>cvs edit</CODE> command accepts the same <VAR>options</VAR> as the
<CODE>cvs watch add</CODE> command, and establishes a temporary watch for the
user on <VAR>files</VAR>; CVS will remove the watch when <VAR>files</VAR> are
<CODE>unedit</CODE>ed or <CODE>commit</CODE>ted.  If the user does not wish to
receive notifications, she should specify <CODE>-a none</CODE>.

</P>
<P>
The <VAR>files</VAR> and <CODE>-l</CODE> option are processed as for the <CODE>cvs
watch</CODE> commands.

</P>
</DL>

<P>
Normally when you are done with a set of changes, you
use the <CODE>cvs commit</CODE> command, which checks in your
changes and returns the watched files to their usual
read-only state.  But if you instead decide to abandon
your changes, or not to make any changes, you can use
the <CODE>cvs unedit</CODE> command.

</P>
<P>
<A NAME="IDX184"></A>
<A NAME="IDX185"></A>
<A NAME="IDX186"></A>
<DL>
<DT><U>Command:</U> <B>cvs unedit</B> <I>[<CODE>-l</CODE>] files ...</I>
<DD><A NAME="IDX187"></A>

</P>
<P>
Abandon work on the working files <VAR>files</VAR>, and revert them to the
repository versions on which they are based.  CVS makes those
<VAR>files</VAR> read-only for which users have requested notification using
<CODE>cvs watch on</CODE>.  CVS notifies users who have requested <CODE>unedit</CODE>
notification for any of <VAR>files</VAR>.

</P>
<P>
The <VAR>files</VAR> and <CODE>-l</CODE> option are processed as for the
<CODE>cvs watch</CODE> commands.

</P>
<P>
If watches are not in use, the <CODE>unedit</CODE> command
probably does not work, and the way to revert to the
repository version is to remove the file and then use
<CODE>cvs update</CODE> to get a new copy.  The meaning is
not precisely the same; removing and updating may also
bring in some changes which have been made in the
repository since the last time you updated.
</DL>

</P>
<P>
When using client/server CVS, you can use the
<CODE>cvs edit</CODE> and <CODE>cvs unedit</CODE> commands even if
CVS is unable to succesfully communicate with the
server; the notifications will be sent upon the next
successful CVS command.

</P>


<H3><A NAME="SEC47" HREF="cvs_toc.html#TOC47">Information about who is watching and editing</A></H3>

<P>
<A NAME="IDX188"></A>
<DL>
<DT><U>Command:</U> <B>cvs watchers</B> <I>[<CODE>-l</CODE>] files ...</I>
<DD><A NAME="IDX189"></A>

</P>
<P>
List the users currently watching changes to <VAR>files</VAR>.  The report
includes the files being watched, and the mail address of each watcher.

</P>
<P>
The <VAR>files</VAR> and <CODE>-l</CODE> arguments are processed as for the
<CODE>cvs watch</CODE> commands.

</P>
</DL>

<P>
<A NAME="IDX190"></A>
<DL>
<DT><U>Command:</U> <B>cvs editors</B> <I>[<CODE>-l</CODE>] files ...</I>
<DD><A NAME="IDX191"></A>

</P>
<P>
List the users currently working on <VAR>files</VAR>.  The report
includes the mail address of each user, the time when the user began
working with the file, and the host and path of the working directory
containing the file.

</P>
<P>
The <VAR>files</VAR> and <CODE>-l</CODE> arguments are processed as for the
<CODE>cvs watch</CODE> commands.

</P>
</DL>



<H3><A NAME="SEC48" HREF="cvs_toc.html#TOC48">Using watches with old versions of CVS</A></H3>

<P>
<A NAME="IDX192"></A>
If you use the watch features on a repository, it
creates <TT>`CVS'</TT> directories in the repository and
stores the information about watches in that directory.
If you attempt to use CVS 1.6 or earlier with the
repository, you get an error message such as

</P>

<PRE>
cvs update: cannot open CVS/Entries for reading: No such file or directory
</PRE>

<P>
and your operation will likely be aborted.  To use the
watch features, you must upgrade all copies of CVS
which use that repository in local or server mode.  If
you cannot upgrade, use the <CODE>watch off</CODE> and
<CODE>watch remove</CODE> commands to remove all watches, and
that will restore the repository to a state which
CVS 1.6 can cope with.

</P>


<H2><A NAME="SEC49" HREF="cvs_toc.html#TOC49">Choosing between reserved or unreserved checkouts</A></H2>
<P>
<A NAME="IDX193"></A>

</P>
<P>
Reserved and unreserved checkouts each have pros and
cons.  Let it be said that a lot of this is a matter of
opinion or what works given different groups' working
styles, but here is an attempt to briefly describe the
issues.  There are many ways to organize a team of
developers.  CVS does not try to enforce a certain
organization.  It is a tool that can be used in several
ways.

</P>
<P>
Reserved checkouts can be very counter-productive.  If
two persons want to edit different parts of a file,
there may be no reason to prevent either of them from
doing so.  Also, it is common for someone to take out a
lock on a file, because they are planning to edit it,
but then forget to release the lock.

</P>
<P>
People, especially people who are familiar with
reserved checkouts, often wonder how often conflicts
occur if unreserved checkouts are used, and how
difficult they are to resolve.  The experience with
many groups is that they occur rarely and usually are
relatively straightforward to resolve.

</P>
<P>
The rarity of serious conflicts may be surprising, until one realizes
that they occur only when two developers disagree on the proper design
for a given section of code; such a disagreement suggests that the
team has not been communicating properly in the first place.  In order
to collaborate under <EM>any</EM> source management regimen, developers
must agree on the general design of the system; given this agreement,
overlapping changes are usually straightforward to merge.

</P>
<P>
In some cases unreserved checkouts are clearly
inappropriate.  If no merge tool exists for the kind of
file you are managing (for example word processor files
or files edited by Computer Aided Design programs), and
it is not desirable to change to a program which uses a
mergeable data format, then resolving conflicts is
going to be unpleasant enough that you generally will
be better off to simply avoid the conflicts instead, by
using reserved checkouts.

</P>
<P>
The watches features described above in section <A HREF="cvs_7.html#SEC43">Mechanisms to track who is editing files</A>
can be considered to be an intermediate model between
reserved checkouts and unreserved checkouts.  When you
go to edit a file, it is possible to find out who else
is editing it.  And rather than having the system
simply forbid both people editing the file, it can tell
you what the situation is and let you figure out
whether it is a problem in that particular case or not.
Therefore, for some groups it can be considered the
best of both the reserved checkout and unreserved
checkout worlds.

</P>
<P><HR><P>
Go to the <A HREF="cvs_1.html">first</A>, <A HREF="cvs_6.html">previous</A>, <A HREF="cvs_8.html">next</A>, <A HREF="cvs_25.html">last</A> section, <A HREF="cvs_toc.html">table of contents</A>.
</BODY>
</HTML>
