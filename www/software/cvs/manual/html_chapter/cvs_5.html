<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.52
     from ../texi/cvs.texinfo on 7 November 1998 -->

<TITLE>CVS--Concurrent Versions System - The Repository</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="cvs_1.html">first</A>, <A HREF="cvs_4.html">previous</A>, <A HREF="cvs_6.html">next</A>, <A HREF="cvs_25.html">last</A> section, <A HREF="cvs_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC15" HREF="cvs_toc.html#TOC15">The Repository</A></H1>
<P>
<A NAME="IDX56"></A>
<A NAME="IDX57"></A>
<A NAME="IDX58"></A>
<A NAME="IDX59"></A>
<A NAME="IDX60"></A>
<A NAME="IDX61"></A>

</P>
<P>
The CVS <EM>repository</EM> stores a complete copy of
all the files and directories which are under version
control.

</P>
<P>
Normally, you never access any of the files in the
repository directly.  Instead, you use CVS
commands to get your own copy of the files, and then
work on that copy.  When you've finished a set of
changes, you check (or <EM>commit</EM>) them back into the
repository.  The repository then contains the changes
which you have made, as well as recording exactly what
you changed, when you changed it, and other such
information.

</P>
<P>
<A NAME="IDX62"></A>
CVS can access a repository by a variety of
means.  It might be on the local computer, or it might
be on a computer across the room or across the world.
To distinguish various ways to access a repository, the
repository name can start with an <EM>access method</EM>.
For example, the access method <CODE>:local:</CODE> means to
access a repository directory, so the repository
<CODE>:local:/usr/local/cvsroot</CODE> means that the
repository is in <TT>`/usr/local/cvsroot'</TT> on the
computer running CVS.  For information on other
access methods, see section <A HREF="cvs_5.html#SEC24">Remote repositories</A>.

</P>
<P>
If the access method is omitted, then if the repository
does not contain <SAMP>`:'</SAMP>, then <CODE>:local:</CODE> is
assumed.  If it does contain <SAMP>`:'</SAMP> than either
<CODE>:ext:</CODE> or <CODE>:server:</CODE> is assumed.  For
example, if you have a local repository in
<TT>`/usr/local/cvsroot'</TT>, you can use
<CODE>/usr/local/cvsroot</CODE> instead of
<CODE>:local:/usr/local/cvsroot</CODE>.  But if (under
Windows NT, for example) your local repository is
<TT>`c:\src\cvsroot'</TT>, then you must specify the access
method, as in <CODE>:local:c:\src\cvsroot</CODE>.

</P>
<P>
The repository is split in two parts.  <TT>`$CVSROOT/CVSROOT'</TT> contains
administrative files for CVS.  The other directories contain the actual
user-defined modules.

</P>



<H2><A NAME="SEC16" HREF="cvs_toc.html#TOC16">Telling CVS where your repository is</A></H2>

<P>
There are a couple of different ways to tell CVS
where to find the repository.  You can name the
repository on the command line explicitly, with the
<CODE>-d</CODE> (for "directory") option:

</P>

<PRE>
cvs -d /usr/local/cvsroot checkout yoyodyne/tc
</PRE>

<P>
<A NAME="IDX63"></A>
<A NAME="IDX64"></A>
<A NAME="IDX65"></A>
<A NAME="IDX66"></A>
<A NAME="IDX67"></A>
        Or you can set the <CODE>$CVSROOT</CODE> environment
variable to an absolute path to the root of the
repository, <TT>`/usr/local/cvsroot'</TT> in this example.
To set <CODE>$CVSROOT</CODE>, all <CODE>csh</CODE> and <CODE>tcsh</CODE>
users should have this line in their <TT>`.cshrc'</TT> or
<TT>`.tcshrc'</TT> files:

</P>

<PRE>
setenv CVSROOT /usr/local/cvsroot
</PRE>

<P>
<CODE>sh</CODE> and <CODE>bash</CODE> users should instead have these lines in their
<TT>`.profile'</TT> or <TT>`.bashrc'</TT>:

</P>

<PRE>
CVSROOT=/usr/local/cvsroot
export CVSROOT
</PRE>

<P>
        A repository specified with <CODE>-d</CODE> will
override the <CODE>$CVSROOT</CODE> environment variable.
Once you've checked a working copy out from the
repository, it will remember where its repository is
(the information is recorded in the
<TT>`CVS/Root'</TT> file in the working copy).  

</P>
<P>
The <CODE>-d</CODE> option and the <TT>`CVS/Root'</TT> file both
override the <CODE>$CVSROOT</CODE> environment variable.  If
<CODE>-d</CODE> option differs from <TT>`CVS/Root'</TT>, the
former is used (and specifying <CODE>-d</CODE> will cause
<TT>`CVS/Root'</TT> to be updated).  Of course, for proper
operation they should be two ways of referring to the
same repository.

</P>


<H2><A NAME="SEC17" HREF="cvs_toc.html#TOC17">How data is stored in the repository</A></H2>
<P>
<A NAME="IDX68"></A>

</P>
<P>
For most purposes it isn't important <EM>how</EM>
CVS stores information in the repository.  In
fact, the format has changed in the past, and is likely
to change in the future.  Since in almost all cases one
accesses the repository via CVS commands; such
changes need not be disruptive.

</P>
<P>
However, in some cases it may be necessary to
understand how CVS stores data in the repository,
for example you might need to track down CVS locks
(see section <A HREF="cvs_7.html#SEC42">Several developers simultaneously attempting to run CVS</A>) or you might need to deal with
the file permissions appropriate for the repository.

</P>



<H3><A NAME="SEC18" HREF="cvs_toc.html#TOC18">Where files are stored within the repository</A></H3>

<P>
The overall structure of the repository is a directory
tree corresponding to the directories in the working
directory.  For example, supposing the repository is in
<TT>`/usr/local/cvsroot'</TT>, here is a possible directory
tree (showing only the directories):

</P>

<PRE>
<TT>/usr</TT>
 |
 +--<TT>local</TT>
 |   |
 |   +--<TT>cvsroot</TT>
 |   |    | 
 |   |    +--<TT>CVSROOT</TT>
          |      (administrative files) 
          | 
          +--<TT>gnu</TT>
          |   | 
          |   +--<TT>diff</TT>
          |   |   (source code to GNU diff) 
          |   | 
          |   +--<TT>rcs</TT>
          |   |   (source code to RCS)
          |   | 
          |   +--<TT>cvs</TT>
          |       (source code to CVS) 
          | 
          +--<TT>yoyodyne</TT>
              | 
              +--<TT>tc</TT>
              |    |
              |    +--<TT>man</TT>
              |    |
              |    +--<TT>testing</TT>
              | 
              +--(other Yoyodyne software)
</PRE>

<P>
With the directories are <EM>history files</EM> for each file
under version control.  The name of the history file is
the name of the corresponding file with <SAMP>`,v'</SAMP>
appended to the end.  Here is what the repository for
the <TT>`yoyodyne/tc'</TT> directory might look like:

</P>

<PRE>
  <CODE>$CVSROOT</CODE>
    |
    +--<TT>yoyodyne</TT>
    |   |
    |   +--<TT>tc</TT>
    |   |   |
            +--<TT>Makefile,v</TT>
            +--<TT>backend.c,v</TT>
            +--<TT>driver.c,v</TT>
            +--<TT>frontend.c,v</TT>
            +--<TT>parser.c,v</TT>
            +--<TT>man</TT>
            |    |
            |    +--<TT>tc.1,v</TT>
            |     
            +--<TT>testing</TT>
                 |
                 +--<TT>testpgm.t,v</TT>
                 +--<TT>test2.t,v</TT>
</PRE>

<P>
<A NAME="IDX69"></A>
<A NAME="IDX70"></A>
The history files contain, among other things, enough
information to recreate any revision of the file, a log
of all commit messages and the user-name of the person
who committed the revision.  The history files are
known as <EM>RCS files</EM>, because the first program to
store files in that format was a version control system
known as RCS.  For a full
description of the file format, see the <CODE>man</CODE> page
<CITE>rcsfile(5)</CITE>, distributed with RCS.  This
file format has become very common--many systems other
than CVS or RCS can at least import history
files in this format.

</P>


<H3><A NAME="SEC19" HREF="cvs_toc.html#TOC19">File permissions</A></H3>
<P>
<A NAME="IDX71"></A>
<A NAME="IDX72"></A>
<A NAME="IDX73"></A>
<A NAME="IDX74"></A>
All <SAMP>`,v'</SAMP> files are created read-only, and you
should not change the permission of those files.  The
directories inside the repository should be writable by
the persons that have permission to modify the files in
each directory.  This normally means that you must
create a Unix group (see group(5)) consisting of the
persons that are to edit the files in a project, and
set up the repository so that it is that group that
owns the directory.

</P>
<P>
This means that you can only control access to files on
a per-directory basis.

</P>
<P>
Note that users must also have write access to check
out files, because CVS needs to create lock files
(see section <A HREF="cvs_7.html#SEC42">Several developers simultaneously attempting to run CVS</A>).

</P>
<P>
Also note that users must have write access to the
<TT>`CVSROOT/val-tags'</TT> file.  CVS uses it to keep
track of what tags are valid tag names (it is sometimes
updated when tags are used, as well as when they are
created, though).

</P>
<P>
<A NAME="IDX75"></A>
<A NAME="IDX76"></A>
CVS tries to set up reasonable file permissions
for new directories that are added inside the tree, but
you must fix the permissions manually when a new
directory should have different permissions than its
parent directory.  If you set the <CODE>CVSUMASK</CODE>
environment variable that will control the file
permissions which CVS uses in creating directories
and/or files in the repository.  <CODE>CVSUMASK</CODE> does
not affect the file permissions in the working
directory; such files have the permissions which are
typical for newly created files, except that sometimes
CVS creates them read-only (see the sections on
watches, section <A HREF="cvs_7.html#SEC44">Telling CVS to watch certain files</A>; -r, section <A HREF="cvs_20.html#SEC89">Global options</A>; or CVSREAD, section <A HREF="cvs_22.html#SEC151">All environment variables which affect CVS</A>).

</P>
<P>
<A NAME="IDX77"></A>
<A NAME="IDX78"></A>
Since CVS was not written to be run setuid, it is
unsafe to try to run it setuid.  You cannot use the
setuid features of RCS together with CVS.

</P>


<H2><A NAME="SEC20" HREF="cvs_toc.html#TOC20">The administrative files</A></H2>
<P>
<A NAME="IDX79"></A>
<A NAME="IDX80"></A>
<A NAME="IDX81"></A>
<A NAME="IDX82"></A>

</P>

<P>
The directory <TT>`$CVSROOT/CVSROOT'</TT> contains some <EM>administrative
files</EM>.  See section <A HREF="cvs_21.html#SEC136">Reference manual for the Administrative files</A>, for a complete description.
You can use CVS without any of these files, but
some commands work better when at least the
<TT>`modules'</TT> file is properly set up.

</P>
<P>
The most important of these files is the <TT>`modules'</TT>
file.  It defines all modules in the repository.  This
is a sample <TT>`modules'</TT> file.

</P>

<PRE>
CVSROOT         CVSROOT
modules         CVSROOT modules
cvs             gnu/cvs
rcs             gnu/rcs
diff            gnu/diff
tc              yoyodyne/tc
</PRE>

<P>
The <TT>`modules'</TT> file is line oriented.  In its
simplest form each line contains the name of the
module, whitespace, and the directory where the module
resides.  The directory is a path relative to
<CODE>$CVSROOT</CODE>.  The last four lines in the example
above are examples of such lines.

</P>

<P>
The line that defines the module called <SAMP>`modules'</SAMP>
uses features that are not explained here.
See section <A HREF="cvs_21.html#SEC137">The modules file</A>, for a full explanation of all the
available features.

</P>


<H3><A NAME="SEC21" HREF="cvs_toc.html#TOC21">Editing administrative files</A></H3>
<P>
<A NAME="IDX83"></A>
<A NAME="IDX84"></A>

</P>
<P>
You edit the administrative files in the same way that you would edit
any other module.  Use <SAMP>`cvs checkout CVSROOT'</SAMP> to get a working
copy, edit it, and commit your changes in the normal way.

</P>
<P>
It is possible to commit an erroneous administrative
file.  You can often fix the error and check in a new
revision, but sometimes a particularly bad error in the
administrative file makes it impossible to commit new
revisions.  

</P>


<H2><A NAME="SEC22" HREF="cvs_toc.html#TOC22">Multiple repositories</A></H2>
<P>
<A NAME="IDX85"></A>
<A NAME="IDX86"></A>
<A NAME="IDX87"></A>
<A NAME="IDX88"></A>
<A NAME="IDX89"></A>
<A NAME="IDX90"></A>

</P>
<P>
In some situations it is a good idea to have more than
one repository, for instance if you have two
development groups that work on separate projects
without sharing any code.  All you have to do to have
several repositories is to specify the appropriate
repository, using the <CODE>CVSROOT</CODE> environment
variable, the <SAMP>`-d'</SAMP> option to CVS, or (once
you have checked out a working directory) by simply
allowing CVS to use the repository that was used
to check out the working directory
(see section <A HREF="cvs_5.html#SEC16">Telling CVS where your repository is</A>).

</P>
<P>
The big advantage of having multiple repositories is
that they can reside on different servers.  The big
disadvantage is that you cannot have a single CVS
command recurse into directories which comes from
different repositories.  Generally speaking, if you are
thinking of setting up several repositories on the same
machine, you might want to consider using several
directories within the same repository.

</P>
<P>
None of the examples in this manual show multiple
repositories.

</P>


<H2><A NAME="SEC23" HREF="cvs_toc.html#TOC23">Creating a repository</A></H2>

<P>
<A NAME="IDX91"></A>
<A NAME="IDX92"></A>
<A NAME="IDX93"></A>

</P>
<P>
To set up a CVS repository, choose a directory
with ample disk space available for the revision
history of the source files.  It should be accessable
(directly or via a networked file system) from all
machines which want to use CVS in server or local
mode; the client machines need not have any access to
it other than via the CVS protocol.  It is not
possible to use CVS to read from a repository
which one only has read access to; CVS needs to be
able to create lock files (see section <A HREF="cvs_7.html#SEC42">Several developers simultaneously attempting to run CVS</A>).

</P>
<P>
<A NAME="IDX94"></A>
To create a repository, run the <CODE>cvs init</CODE>
command.  It will set up an empty repository in the
CVS root specified in the usual way
(see section <A HREF="cvs_5.html#SEC15">The Repository</A>).  For example,

</P>

<PRE>
cvs -d /usr/local/cvsroot init
</PRE>

<P>
<CODE>cvs init</CODE> is careful to never overwrite any
existing files in the repository, so no harm is done if
you run <CODE>cvs init</CODE> on an already set-up
repository.

</P>
<P>
<CODE>cvs init</CODE> will enable history logging; if you
don't want that, remove the history file after running
<CODE>cvs init</CODE>.  See section <A HREF="cvs_21.html#SEC149">The history file</A>.

</P>


<H2><A NAME="SEC24" HREF="cvs_toc.html#TOC24">Remote repositories</A></H2>
<P>
<A NAME="IDX95"></A>
<A NAME="IDX96"></A>
<A NAME="IDX97"></A>

</P>
<P>
        Your working copy of the sources can be on a
different machine than the repository.  Generally,
using a remote repository is just like using a local
one, except that the format of the repository name is:

</P>

<PRE>
:<VAR>method</VAR>:<VAR>user</VAR>@<VAR>hostname</VAR>:/path/to/repository
</PRE>

<P>
The details of exactly what needs to be set up depend
on how you are connecting to the server.

</P>
<P>
If <VAR>method</VAR> is not specified, and the repository
name contains <SAMP>`:'</SAMP>, then the default is <CODE>ext</CODE>
or <CODE>server</CODE>, depending on your platform; both are
described in section <A HREF="cvs_5.html#SEC25">Connecting with rsh</A>.

</P>



<H3><A NAME="SEC25" HREF="cvs_toc.html#TOC25">Connecting with rsh</A></H3>

<P>
<A NAME="IDX98"></A>
CVS uses the <TT>`rsh'</TT> protocol to perform these
operations, so the remote user host needs to have a
<TT>`.rhosts'</TT> file which grants access to the local
user.

</P>
<P>
For example, suppose you are the user <TT>`mozart'</TT> on
the local machine <TT>`anklet.grunge.com'</TT>, and the
server machine is <TT>`chainsaw.brickyard.com'</TT>.  On
chainsaw, put the following line into the file
<TT>`.rhosts'</TT> in <TT>`bach'</TT>'s home directory:

</P>

<PRE>
anklet.grunge.com  mozart
</PRE>

<P>
Then test that <CODE>rsh</CODE> is working with

</P>

<PRE>
rsh -l bach chainsaw.brickyard.com 'echo $PATH'
</PRE>

<P>
<A NAME="IDX99"></A>
Next you have to make sure that <CODE>rsh</CODE> will be able
to find the server.  Make sure that the path which
<CODE>rsh</CODE> printed in the above example includes the
directory containing a program named <CODE>cvs</CODE> which
is the server.  You need to set the path in
<TT>`.bashrc'</TT>, <TT>`.cshrc'</TT>, etc., not <TT>`.login'</TT>
or <TT>`.profile'</TT>.  Alternately, you can set the
environment variable <CODE>CVS_SERVER</CODE> on the client
machine to the filename of the server you want to use,
for example <TT>`/usr/local/bin/cvs-1.6'</TT>.

</P>
<P>
There is no need to edit <CODE>inetd.conf</CODE> or start a
CVS server daemon.

</P>
<P>
<A NAME="IDX100"></A>
<A NAME="IDX101"></A>
There are two access methods that you use in CVSROOT
for rsh.  <CODE>:server:</CODE> specifies an internal rsh
client, which is supported only by some CVS ports.
<CODE>:ext:</CODE> specifies an external rsh program.  By
default this is <CODE>rsh</CODE> but you may set the
<CODE>CVS_RSH</CODE> environment variable to invoke another
program which can access the remote server (for
example, <CODE>remsh</CODE> on HP-UX 9 because <CODE>rsh</CODE> is
something different).  It must be a program which can
transmit data to and from the server without modifying
it; for example the Windows NT <CODE>rsh</CODE> is not
suitable since it by default translates between CRLF
and LF.  The OS/2 CVS port has a hack to pass <SAMP>`-b'</SAMP>
to <CODE>rsh</CODE> to get around this, but since this could
potentially cause programs for programs other than the
standard <CODE>rsh</CODE>, it may change in the future.  If
you set <CODE>CVS_RSH</CODE> to <CODE>SSH</CODE> or some other rsh
replacement, the instructions in the rest of this
section concerning <TT>`.rhosts'</TT> and so on are likely
to be incorrect; consult the documentation for your rsh
replacement.

</P>
<P>
Continuing our example, supposing you want to access
the module <TT>`foo'</TT> in the repository
<TT>`/usr/local/cvsroot/'</TT>, on machine
<TT>`chainsaw.brickyard.com'</TT>, you are ready to go:

</P>

<PRE>
cvs -d :ext:bach@chainsaw.brickyard.com:/usr/local/cvsroot checkout foo
</PRE>

<P>
(The <TT>`bach@'</TT> can be omitted if the username is
the same on both the local and remote hosts.)

</P>



<H3><A NAME="SEC26" HREF="cvs_toc.html#TOC26">Direct connection with password authentication</A></H3>

<P>
The CVS client can also connect to the server
using a password protocol.  This is particularly useful
if using <CODE>rsh</CODE> is not feasible (for example,
the server is behind a firewall), and Kerberos also is
not available.

</P>
<P>
        To use this method, it is necessary to make
some adjustments on both the server and client sides.

</P>



<H4><A NAME="SEC27" HREF="cvs_toc.html#TOC27">Setting up the server for password authentication</A></H4>

<P>
<A NAME="IDX102"></A>
<A NAME="IDX103"></A>
<A NAME="IDX104"></A>
On the server side, the file <TT>`/etc/inetd.conf'</TT>
needs to be edited so <CODE>inetd</CODE> knows to run the
command <CODE>cvs pserver</CODE> when it receives a
connection on the right port.  By default, the port
number is 2401; it would be different if your client
were compiled with <CODE>CVS_AUTH_PORT</CODE> defined to
something else, though.

</P>
<P>
        If your <CODE>inetd</CODE> allows raw port numbers in
<TT>`/etc/inetd.conf'</TT>, then the following (all on a
single line in <TT>`inetd.conf'</TT>) should be sufficient:

</P>

<PRE>
2401  stream  tcp  nowait  root  /usr/local/bin/cvs
cvs -b /usr/local/bin pserver
</PRE>

<P>
The <SAMP>`-b'</SAMP> option specifies the directory which contains
the RCS binaries on the server.  You could also use the
<SAMP>`-T'</SAMP> option to specify a temporary directory.

</P>
<P>
        If your <CODE>inetd</CODE> wants a symbolic service
name instead of a raw port number, then put this in
<TT>`/etc/services'</TT>:

</P>

<PRE>
cvspserver      2401/tcp
</PRE>

<P>
        and put <CODE>cvspserver</CODE> instead of
<CODE>2401</CODE> in <TT>`inetd.conf'</TT>.

</P>
<P>
        Once the above is taken care of, restart your
<CODE>inetd</CODE>, or do whatever is necessary to force it
to reread its initialization files.

</P>

<P>
<A NAME="IDX105"></A>
<A NAME="IDX106"></A>
Because the client stores and transmits passwords in
cleartext (almost--see section <A HREF="cvs_5.html#SEC29">Security considerations with password authentication</A> for details), a separate CVS password
file may be used, so people don't compromise their
regular passwords when they access the repository.
This file is <TT>`$CVSROOT/CVSROOT/passwd'</TT>
(see section <A HREF="cvs_5.html#SEC20">The administrative files</A>).  Its format is
similar to <TT>`/etc/passwd'</TT>, except that it only has
two fields, username and password.  For example:

</P>

<PRE>
bach:ULtgRLXo7NRxs
cwang:1sOp854gDF3DY
</PRE>

<P>
The password is encrypted according to the standard
Unix <CODE>crypt()</CODE> function, so it is possible to
paste in passwords directly from regular Unix
<TT>`passwd'</TT> files.

</P>
<P>
When authenticating a password, the server first checks
for the user in the CVS <TT>`passwd'</TT> file.  If it
finds the user, it compares against that password.  If
it does not find the user, or if the CVS
<TT>`passwd'</TT> file does not exist, then the server
tries to match the password using the system's
user-lookup routine.  When using the CVS
<TT>`passwd'</TT> file, the server runs under as the
username specified in the the third argument in the
entry, or as the first argument if there is no third
argument (in this way CVS allows imaginary
usernames provided the CVS <TT>`passwd'</TT> file
indicates corresponding valid system usernames).  In
any case, CVS will have no privileges which the
(valid) user would not have.

</P>
<P>
Right now, the only way to put a password in the
CVS <TT>`passwd'</TT> file is to paste it there from
somewhere else.  Someday, there may be a <CODE>cvs
passwd</CODE> command.

</P>


<H4><A NAME="SEC28" HREF="cvs_toc.html#TOC28">Using the client with password authentication</A></H4>
<P>
<A NAME="IDX107"></A>
<A NAME="IDX108"></A>
<A NAME="IDX109"></A>
<A NAME="IDX110"></A>
Before connecting to the server, the client must <EM>log
in</EM> with the command <CODE>cvs login</CODE>.  Logging in
verifies a password with the server, and also records
the password for later transactions with the server.
The <CODE>cvs login</CODE> command needs to know the
username, server hostname, and full repository path,
and it gets this information from the repository
argument or the <CODE>CVSROOT</CODE> environment variable.

</P>
<P>
<CODE>cvs login</CODE> is interactive -- it prompts for a
password:

</P>

<PRE>
cvs -d :pserver:bach@chainsaw.brickyard.com:/usr/local/cvsroot login 
CVS password: 
</PRE>

<P>
The password is checked with the server; if it is
correct, the <CODE>login</CODE> succeeds, else it fails,
complaining that the password was incorrect.

</P>
<P>
Once you have logged in, you can force CVS to
connect directly to the server and authenticate with
the stored password:

</P>

<PRE>
cvs -d :pserver:bach@chainsaw.brickyard.com:/usr/local/cvsroot checkout foo
</PRE>

<P>
The <SAMP>`:pserver:'</SAMP> is necessary because without it,
CVS will assume it should use <CODE>rsh</CODE> to
connect with the server (see section <A HREF="cvs_5.html#SEC25">Connecting with rsh</A>).
(Once you have a working copy checked out and are
running CVS commands from within it, there is no
longer any need to specify the repository explicitly,
because CVS records it in the working copy's
<TT>`CVS'</TT> subdirectory.)

</P>
<P>
<A NAME="IDX111"></A>
Passwords are stored by default in the file
<TT>`$HOME/.cvspass'</TT>.  Its format is human-readable,
but don't edit it unless you know what you are doing.
The passwords are not stored in cleartext, but are
trivially encoded to protect them from "innocent"
compromise (i.e., inadvertently being seen by a system
administrator who happens to look at that file).

</P>
<P>
The <CODE>CVS_PASSFILE</CODE> environment variable overrides
this default.  If you use this variable, make sure you
set it <EM>before</EM> <CODE>cvs login</CODE> is run.  If you
were to set it after running <CODE>cvs login</CODE>, then
later CVS commands would be unable to look up the
password for transmission to the server.

</P>
<P>
<A NAME="IDX112"></A>
The <CODE>CVS_PASSWORD</CODE> environment variable overrides
<EM>all</EM> stored passwords.  If it is set, CVS
will use it for all password-authenticated
connections.

</P>


<H4><A NAME="SEC29" HREF="cvs_toc.html#TOC29">Security considerations with password authentication</A></H4>

<P>
The passwords are stored on the client side in a
trivial encoding of the cleartext, and transmitted in
the same encoding.  The encoding is done only to
prevent inadvertent password compromises (i.e., a
system administrator accidentally looking at the file),
and will not prevent even a naive attacker from gaining
the password.

</P>
<P>
The separate CVS password file (see section <A HREF="cvs_5.html#SEC27">Setting up the server for password authentication</A>) allows people
to use a different password for repository access than
for login access.  On the other hand, once a user has
access to the repository, she can execute programs on
the server system through a variety of means.  Thus, repository
access implies fairly broad system access as well.  It
might be possible to modify CVS to prevent that,
but no one has done so as of this writing.
Furthermore, there may be other ways in which having
access to CVS allows people to gain more general
access to the system; noone has done a careful audit.

</P>
<P>
In summary, anyone who gets the password gets
repository access, and some measure of general system
access as well.  The password is available to anyone
who can sniff network packets or read a protected
(i.e., user read-only) file.  If you want real
security, get Kerberos.

</P>


<H3><A NAME="SEC30" HREF="cvs_toc.html#TOC30">Direct connection with kerberos</A></H3>

<P>
<A NAME="IDX113"></A>
<A NAME="IDX114"></A>
The main disadvantage of using rsh is that all the data
needs to pass through additional programs, so it may be
slower.  So if you have kerberos installed you can
connect via a direct TCP connection,
authenticating with kerberos.

</P>
<P>
To do this, CVS needs to be compiled with kerberos
support; when configuring CVS it tries to detect
whether kerberos is present or you can use the
<TT>`--with-krb4'</TT> flag to configure.

</P>
<P>
The data transmitted is <EM>not</EM> encrypted by
default.  Encryption support must be compiled into both
the client and server; use the
<TT>`--enable-encryption'</TT> configure option to turn it
on.  You must then use the <CODE>-x</CODE> global option to
request encryption.

</P>
<P>
<A NAME="IDX115"></A>
You need to edit <CODE>inetd.conf</CODE> on the server
machine to run <CODE>cvs kserver</CODE>.  The client uses
port 1999 by default; if you want to use another port
specify it in the <CODE>CVS_CLIENT_PORT</CODE> environment
variable on the client.

</P>
<P>
<A NAME="IDX116"></A>
When you want to use CVS, get a ticket in the
usual way (generally <CODE>kinit</CODE>); it must be a ticket
which allows you to log into the server machine.  Then
you are ready to go:

</P>

<PRE>
cvs -d :kserver:chainsaw.brickyard.com:/user/local/cvsroot checkout foo
</PRE>

<P>
Previous versions of CVS would fall back to a
connection via rsh; this version will not do so.

</P>
<P><HR><P>
Go to the <A HREF="cvs_1.html">first</A>, <A HREF="cvs_4.html">previous</A>, <A HREF="cvs_6.html">next</A>, <A HREF="cvs_25.html">last</A> section, <A HREF="cvs_toc.html">table of contents</A>.
</BODY>
</HTML>
