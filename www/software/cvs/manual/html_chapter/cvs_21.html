<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.52
     from ../texi/cvs.texinfo on 7 November 1998 -->

<TITLE>CVS--Concurrent Versions System - Reference manual for the Administrative files</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="cvs_1.html">first</A>, <A HREF="cvs_20.html">previous</A>, <A HREF="cvs_22.html">next</A>, <A HREF="cvs_25.html">last</A> section, <A HREF="cvs_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC136" HREF="cvs_toc.html#TOC136">Reference manual for the Administrative files</A></H1>
<P>
<A NAME="IDX358"></A>
<A NAME="IDX359"></A>
<A NAME="IDX360"></A>
<A NAME="IDX361"></A>

</P>
<P>
Inside the repository, in the directory
<TT>`$CVSROOT/CVSROOT'</TT>, there are a number of
supportive files for CVS.  You can use CVS in a limited
fashion without any of them, but if they are set up
properly they can help make life easier.  For a
discussion of how to edit them, See section <A HREF="cvs_5.html#SEC20">The administrative files</A>.

</P>
<P>
The most important of these files is the <TT>`modules'</TT>
file, which defines the modules inside the repository.

</P>



<H2><A NAME="SEC137" HREF="cvs_toc.html#TOC137">The modules file</A></H2>
<P>
<A NAME="IDX362"></A>
<A NAME="IDX363"></A>

</P>
<P>
The <TT>`modules'</TT> file records your definitions of
names for collections of source code.  CVS will
use these definitions if you use CVS to update the
modules file (use normal commands like <CODE>add</CODE>,
<CODE>commit</CODE>, etc).

</P>
<P>
The <TT>`modules'</TT> file may contain blank lines and
comments (lines beginning with <SAMP>`#'</SAMP>) as well as
module definitions.  Long lines can be continued on the
next line by specifying a backslash (<SAMP>`\'</SAMP>) as the
last character on the line.

</P>
<P>
A module definition is a single line of the
<TT>`modules'</TT> file, in either of two formats.  In both
cases, <VAR>mname</VAR> represents the symbolic module name,
and the remainder of the line is its definition.

</P>
<DL COMPACT>

<DT><CODE><VAR>mname</VAR> -a <VAR>aliases</VAR>...</CODE>
<DD>
This represents the simplest way of defining a module
<VAR>mname</VAR>.  The <SAMP>`-a'</SAMP> flags the definition as a
simple alias: CVS will treat any use of <VAR>mname</VAR> (as
a command argument) as if the list of names
<VAR>aliases</VAR> had been specified instead.
<VAR>aliases</VAR> may contain either other module names or
paths.  When you use paths in aliases, <CODE>checkout</CODE>
creates all intermediate directories in the working
directory, just as if the path had been specified
explicitly in the CVS arguments.

<DT><CODE><VAR>mname</VAR> [ options ] <VAR>dir</VAR> [ <VAR>files</VAR>... ] [ &#38;<VAR>module</VAR>... ]</CODE>
<DD>
In the simplest case, this form of module definition
reduces to <SAMP>`<VAR>mname</VAR> <VAR>dir</VAR>'</SAMP>.  This defines
all the files in directory <VAR>dir</VAR> as module mname.
<VAR>dir</VAR> is a relative path (from <CODE>$CVSROOT</CODE>) to a
directory of source in the source repository.  In this
case, on checkout, a single directory called
<VAR>mname</VAR> is created as a working directory; no
intermediate directory levels are used by default, even
if <VAR>dir</VAR> was a path involving several directory
levels.

By explicitly specifying files in the module definition
after <VAR>dir</VAR>, you can select particular files from
directory <VAR>dir</VAR>.  The sample definition for
<SAMP>`modules'</SAMP> is an example of a module defined with a
single file from a particular directory.  Here is
another example:


<PRE>
m4test  unsupported/gnu/m4 foreach.m4 forloop.m4
</PRE>

With this definition, executing <SAMP>`cvs checkout
m4test'</SAMP> will create a single working directory
<TT>`m4test'</TT> containing the two files listed, which
both come from a common directory several levels deep
in the CVS source repository.

A module definition can refer to other modules by
including <SAMP>`&#38;<VAR>module</VAR>'</SAMP> in its definition.
<CODE>checkout</CODE> creates a subdirectory for each such
module, in your working directory.

<DL COMPACT>

<DT><CODE>-d <VAR>name</VAR></CODE>
<DD>
Name the working directory something other than the
module name.

<A NAME="IDX364"></A>
<DT><CODE>-e <VAR>prog</VAR></CODE>
<DD>
Specify a program <VAR>prog</VAR> to run whenever files in a
module are exported.  <VAR>prog</VAR> runs with a single
argument, the module name.

<A NAME="IDX365"></A>
<DT><CODE>-i <VAR>prog</VAR></CODE>
<DD>
Specify a program <VAR>prog</VAR> to run whenever files in a
module are committed.  <VAR>prog</VAR> runs with a single
argument, the full pathname of the affected directory
in a source repository.  The <TT>`commitinfo'</TT>,
<TT>`loginfo'</TT>, and <TT>`editinfo'</TT> files provide other
ways to call a program on commit.

<A NAME="IDX366"></A>
<DT><CODE>-o <VAR>prog</VAR></CODE>
<DD>
Specify a program <VAR>prog</VAR> to run whenever files in a
module are checked out.  <VAR>prog</VAR> runs with a single
argument, the module name.

<A NAME="IDX367"></A>
<A NAME="IDX368"></A>
<DT><CODE>-s <VAR>status</VAR></CODE>
<DD>
Assign a status to the module.  When the module file is
printed with <SAMP>`cvs checkout -s'</SAMP> the modules are
sorted according to primarily module status, and
secondarily according to the module name.  This option
has no other meaning.  You can use this option for
several things besides status: for instance, list the
person that is responsible for this module.

<A NAME="IDX369"></A>
<DT><CODE>-t <VAR>prog</VAR></CODE>
<DD>
Specify a program <VAR>prog</VAR> to run whenever files in a
module are tagged with <CODE>rtag</CODE>.  <VAR>prog</VAR> runs
with two arguments: the module name and the symbolic
tag specified to <CODE>rtag</CODE>.  There is no way to
specify a program to run when <CODE>tag</CODE> is executed.

<A NAME="IDX370"></A>
<DT><CODE>-u <VAR>prog</VAR></CODE>
<DD>
Specify a program <VAR>prog</VAR> to run whenever <SAMP>`cvs
update'</SAMP> is executed from the top-level directory of the
checked-out module.  <VAR>prog</VAR> runs with a single
argument, the full path to the source repository for
this module.
</DL>
</DL>



<H2><A NAME="SEC138" HREF="cvs_toc.html#TOC138">The cvswrappers file</A></H2>
<P>
<A NAME="IDX371"></A>
<A NAME="IDX372"></A>
<A NAME="IDX373"></A>

</P>

<P>
Wrappers allow you to set a hook which transforms files on
their way in and out of CVS.  Most or all of the
wrappers features do not work with client/server CVS.

</P>
<P>
The file <TT>`cvswrappers'</TT> defines the script that will be
run on a file when its name matches a regular
expresion. There are two scripts that can be run on a
file or directory. One script is executed on the file/directory
before being checked into the repository (this is denoted
with the <CODE>-t</CODE> flag) and the other when the file is
checked out of the repository (this is denoted with the
<CODE>-f</CODE> flag)

</P>
<P>
The <TT>`cvswrappers'</TT> also has a <SAMP>`-m'</SAMP> option to
specify the merge methodology that should be used when
the file is updated.  <CODE>MERGE</CODE> means the usual
CVS behavior: try to merge the files (this
generally will not work for binary files).  <CODE>COPY</CODE>
means that <CODE>cvs update</CODE> will merely copy one
version over the other, and require the user using
mechanisms outside CVS, to insert any necessary
changes.
The <SAMP>`-m'</SAMP> wrapper option only affects behavior when
merging is done on update; it does not affect how files
are stored.  See See section <A HREF="cvs_18.html#SEC83">Handling binary files</A>, for more on
binary files.

</P>
<P>
The basic format of the file <TT>`cvswrappers'</TT> is:

</P>

<PRE>
wildcard     [option value][option value]...

where option is one of
-f           from cvs filter         value: path to filter
-t           to cvs filter           value: path to filter
-m           update methodology      value: MERGE or COPY
-k           keyword expansion       value: expansion mode

and value is a single-quote delimited value.
</PRE>


<PRE>
*.nib    -f 'unwrap %s' -t 'wrap %s %s' -m 'COPY'
*.c      -t 'indent %s %s'
</PRE>

<P>
The above example of a <TT>`cvswrappers'</TT> file
states that all files/directories that end with a <CODE>.nib</CODE>
should be filtered with the <TT>`wrap'</TT> program before
checking the file into the repository. The file should
be filtered though the <TT>`unwrap'</TT> program when the
file is checked out of the repository. The
<TT>`cvswrappers'</TT> file also states that a <CODE>COPY</CODE>
methodology should be used when updating the files in
the repository (that is no merging should be performed).

</P>
<P>
The last example line says that all files that end with
a <CODE>*.c</CODE> should be filtered with <TT>`indent'</TT>
before being checked into the repository. Unlike the previous
example no filtering of the <CODE>*.c</CODE> file is done when
it is checked out of the repository.
The <CODE>-t</CODE> filter is called with two arguments,
the first is the name of the file/directory to filter
and the second is the pathname to where the resulting
filtered file should be placed.

</P>
<P>
The <CODE>-f</CODE> filter is called with one argument,
which is the name of the file to filter from. The end
result of this filter will be a file in the users directory
that they can work on as they normally would.

</P>
<P>
For another example, the following command imports a
directory, treating files whose name ends in
<SAMP>`.exe'</SAMP> as binary:

</P>

<PRE>
cvs import -I ! -W "*.exe -k 'b'" first-dir vendortag reltag
</PRE>



<H2><A NAME="SEC139" HREF="cvs_toc.html#TOC139">The commit support files</A></H2>
<P>
<A NAME="IDX374"></A>

</P>
<P>
The <SAMP>`-i'</SAMP> flag in the <TT>`modules'</TT> file can be
used to run a certain program whenever files are
committed (see section <A HREF="cvs_21.html#SEC137">The modules file</A>).  The files described in
this section provide other, more flexible, ways to run
programs whenever something is committed.

</P>
<P>
There are three kind of programs that can be run on
commit.  They are specified in files in the repository,
as described below.  The following table summarizes the
file names and the purpose of the corresponding
programs.

</P>
<DL COMPACT>

<DT><TT>`commitinfo'</TT>
<DD>
The program is responsible for checking that the commit
is allowed.  If it exits with a non-zero exit status
the commit will be aborted.

<DT><TT>`editinfo'</TT>
<DD>
The specified program is used to edit the log message,
and possibly verify that it contains all required
fields.  This is most useful in combination with the
<TT>`rcsinfo'</TT> file, which can hold a log message
template (see section <A HREF="cvs_21.html#SEC147">Rcsinfo</A>).

<DT><TT>`loginfo'</TT>
<DD>
The specified program is called when the commit is
complete.  It receives the log message and some
additional information and can store the log message in
a file, or mail it to appropriate persons, or maybe
post it to a local newsgroup, or...  Your
imagination is the limit!
</DL>



<H3><A NAME="SEC140" HREF="cvs_toc.html#TOC140">The common syntax</A></H3>
<P>
<A NAME="IDX375"></A>
<A NAME="IDX376"></A>
<A NAME="IDX377"></A>

</P>

<P>
The four files <TT>`commitinfo'</TT>, <TT>`loginfo'</TT>,
<TT>`rcsinfo'</TT> and <TT>`editinfo'</TT> all have a common
format.  The purpose of the files are described later
on.  The common syntax is described here.

</P>
<P>
Each line contains the following:

<UL>
<LI>

A regular expression

<LI>

A whitespace separator--one or more spaces and/or tabs.

<LI>

A file name or command-line template.
</UL>

<P>
Blank lines are ignored.  Lines that start with the
character <SAMP>`#'</SAMP> are treated as comments.  Long lines
unfortunately can <EM>not</EM> be broken in two parts in
any way.

</P>
<P>
The first regular expression that matches the current
directory name in the repository is used.  The rest of the line
is used as a file name or command-line as appropriate.

</P>


<H2><A NAME="SEC141" HREF="cvs_toc.html#TOC141">Commitinfo</A></H2>
<P>
<A NAME="IDX378"></A>
<A NAME="IDX379"></A>
<A NAME="IDX380"></A>

</P>
<P>
The <TT>`commitinfo'</TT> file defines programs to execute
whenever <SAMP>`cvs commit'</SAMP> is about to execute.  These
programs are used for pre-commit checking to verify
that the modified, added and removed files are really
ready to be committed.  This could be used, for
instance, to verify that the changed files conform to
to your site's standards for coding practice.

</P>
<P>
As mentioned earlier, each line in the
<TT>`commitinfo'</TT> file consists of a regular expression
and a command-line template.  The template can include
a program name and any number of arguments you wish to
supply to it.  The full path to the current source
repository is appended to the template, followed by the
file names of any files involved in the commit (added,
removed, and modified files).

</P>
<P>
The first line with a regular expression matching the
relative path to the module will be used.  If the
command returns a non-zero exit status the commit will
be aborted.

</P>
<P>
<A NAME="IDX381"></A>
If the repository name does not match any of the
regular expressions in this file, the <SAMP>`DEFAULT'</SAMP>
line is used, if it is specified.

</P>
<P>
<A NAME="IDX382"></A>
All occurances of the name <SAMP>`ALL'</SAMP> appearing as a
regular expression are used in addition to the first
matching regular expression or the name <SAMP>`DEFAULT'</SAMP>.

</P>
<P>
Note: when CVS is accessing a remote repository,
<TT>`commitinfo'</TT> will be run on the <EM>remote</EM>
(i.e., server) side, not the client side (see section <A HREF="cvs_5.html#SEC24">Remote repositories</A>).

</P>



<H2><A NAME="SEC142" HREF="cvs_toc.html#TOC142">Editinfo</A></H2>
<P>
<A NAME="IDX383"></A>
<A NAME="IDX384"></A>
<A NAME="IDX385"></A>
<A NAME="IDX386"></A>

</P>
<P>
If you want to make sure that all log messages look the
same way, you can use the <TT>`editinfo'</TT> file to
specify a program that is used to edit the log message.
This program could be a custom-made editor that always
enforces a certain style of the log message, or maybe a
simple shell script that calls an editor, and checks
that the entered message contains the required fields.

</P>
<P>
If no matching line is found in the <TT>`editinfo'</TT>
file, the editor specified in the environment variable
<CODE>$CVSEDITOR</CODE> is used instead.  If that variable is
not set, then the environment variable <CODE>$EDITOR</CODE>
is used instead.  If that variable is not
set a precompiled default, normally <CODE>vi</CODE>, will be
used.

</P>
<P>
The <TT>`editinfo'</TT> file is often most useful together
with the <TT>`rcsinfo'</TT> file, which can be used to
specify a log message template.

</P>
<P>
Each line in the <TT>`editinfo'</TT> file consists of a
regular expression and a command-line template.  The
template must include a program name, and can include
any number of arguments.  The full path to the current
log message template file is appended to the template.

</P>
<P>
One thing that should be noted is that the <SAMP>`ALL'</SAMP>
keyword is not supported.  If more than one matching
line is found, the first one is used.  This can be
useful for specifying a default edit script in a
module, and then overriding it in a subdirectory.

</P>
<P>
<A NAME="IDX387"></A>
If the repository name does not match any of the
regular expressions in this file, the <SAMP>`DEFAULT'</SAMP>
line is used, if it is specified.

</P>
<P>
If the edit script exits with a non-zero exit status,
the commit is aborted.

</P>
<P>
Note: when CVS is accessing a remote repository,
or when the <SAMP>`-m'</SAMP> or <SAMP>`-F'</SAMP> options to <CODE>cvs
commit</CODE> are used, <TT>`editinfo'</TT> will not be consulted.
There is no good workaround for this.

</P>



<H3><A NAME="SEC143" HREF="cvs_toc.html#TOC143">Editinfo example</A></H3>

<P>
The following is a little silly example of a
<TT>`editinfo'</TT> file, together with the corresponding
<TT>`rcsinfo'</TT> file, the log message template and an
editor script.  We begin with the log message template.
We want to always record a bug-id number on the first
line of the log message.  The rest of log message is
free text.  The following template is found in the file
<TT>`/usr/cvssupport/tc.template'</TT>.

</P>

<PRE>
BugId:    
</PRE>

<P>
The script <TT>`/usr/cvssupport/bugid.edit'</TT> is used to
edit the log message.

</P>

<PRE>
#!/bin/sh
#
#       bugid.edit filename
#
#  Call $EDITOR on FILENAME, and verify that the
#  resulting file contains a valid bugid on the first
#  line.
if [ "x$EDITOR" = "x" ]; then EDITOR=vi; fi
if [ "x$CVSEDITOR" = "x" ]; then CVSEDITOR=$EDITOR; fi
$CVSEDITOR $1
until head -1|grep '^BugId:[ ]*[0-9][0-9]*$' &#60; $1
do  echo -n  "No BugId found.  Edit again? ([y]/n)"
    read ans
    case ${ans} in
        n*) exit 1;;
    esac
    $CVSEDITOR $1
done
</PRE>

<P>
The <TT>`editinfo'</TT> file contains this line:

</P>

<PRE>
^tc     /usr/cvssupport/bugid.edit
</PRE>

<P>
The <TT>`rcsinfo'</TT> file contains this line:

</P>

<PRE>
^tc     /usr/cvssupport/tc.template
</PRE>



<H2><A NAME="SEC144" HREF="cvs_toc.html#TOC144">Loginfo</A></H2>
<P>
<A NAME="IDX388"></A>
<A NAME="IDX389"></A>
<A NAME="IDX390"></A>
<A NAME="IDX391"></A>
<A NAME="IDX392"></A>

</P>
<P>
The <TT>`loginfo'</TT> file is used to control where
<SAMP>`cvs commit'</SAMP> log information is sent.  The first
entry on a line is a regular expression which is tested
against the directory that the change is being made to,
relative to the <CODE>$CVSROOT</CODE>.  If a match is found, then
the remainder of the line is a filter program that
should expect log information on its standard input.

</P>
<P>
The filter program may use one and only one % modifier
(a la printf).  If <SAMP>`%s'</SAMP> is specified in the filter
program, a brief title is included (enclosed in single
quotes) showing the modified file names.

</P>
<P>
If the repository name does not match any of the
regular expressions in this file, the <SAMP>`DEFAULT'</SAMP>
line is used, if it is specified.

</P>
<P>
All occurances of the name <SAMP>`ALL'</SAMP> appearing as a
regular expression are used in addition to the first
matching regular expression or <SAMP>`DEFAULT'</SAMP>.

</P>
<P>
The first matching regular expression is used.

</P>
<P>
See section <A HREF="cvs_21.html#SEC139">The commit support files</A>, for a description of the syntax of
the <TT>`loginfo'</TT> file.  

</P>
<P>
Note: when CVS is accessing a remote repository,
<TT>`loginfo'</TT> will be run on the <EM>remote</EM>
(i.e., server) side, not the client side (see section <A HREF="cvs_5.html#SEC24">Remote repositories</A>).

</P>



<H3><A NAME="SEC145" HREF="cvs_toc.html#TOC145">Loginfo example</A></H3>

<P>
The following <TT>`loginfo'</TT> file, together with the
tiny shell-script below, appends all log messages 
to the file <TT>`$CVSROOT/CVSROOT/commitlog'</TT>,
and any commits to the administrative files (inside
the <TT>`CVSROOT'</TT> directory) are also logged in
<TT>`/usr/adm/cvsroot-log'</TT>.

</P>

<PRE>
ALL             /usr/local/bin/cvs-log $CVSROOT/CVSROOT/commitlog
^CVSROOT        /usr/local/bin/cvs-log /usr/adm/cvsroot-log
</PRE>

<P>
The shell-script <TT>`/usr/local/bin/cvs-log'</TT> looks
like this:

</P>

<PRE>
#!/bin/sh
(echo "-----------------------------------------------------------------";
 echo -n $USER"  ";
 date;
 echo;
 sed '1s+'${CVSROOT}'++') &#62;&#62; $1
</PRE>



<H3><A NAME="SEC146" HREF="cvs_toc.html#TOC146">Keeping a checked out copy</A></H3>

<P>
<A NAME="IDX393"></A>
<A NAME="IDX394"></A>

</P>
<P>
It is often useful to maintain a directory tree which
contains files which correspond to the latest version
in the repository.  For example, other developers might
want to refer to the latest sources without having to
check them out, or you might be maintaining a web site
with CVS and want every checkin to cause the files
used by the web server to be updated.

</P>
<P>
The way to do this is by having loginfo invoke
<CODE>cvs update</CODE>.  Doing so in the naive way will
cause a problem with locks, so the <CODE>cvs update</CODE>
must be run in the background.
Here is an example (this should all be on one line):

</P>

<PRE>
^cyclic-pages		(date; cat; (sleep 2; cd /u/www/local-docs;
 cvs -q update -d) &#38;) &#62;&#62; $CVSROOT/CVSROOT/updatelog 2&#62;&#38;1
</PRE>

<P>
This will cause checkins to repository directories
starting with <CODE>cyclic-pages</CODE> to update the checked
out tree in <TT>`/u/www/local-docs'</TT>.

</P>


<H2><A NAME="SEC147" HREF="cvs_toc.html#TOC147">Rcsinfo</A></H2>
<P>
<A NAME="IDX395"></A>
<A NAME="IDX396"></A>
<A NAME="IDX397"></A>
<A NAME="IDX398"></A>

</P>
<P>
The <TT>`rcsinfo'</TT> file can be used to specify a form to
edit when filling out the commit log.  The
<TT>`rcsinfo'</TT> file has a syntax similar to the
<TT>`editinfo'</TT>, <TT>`commitinfo'</TT> and <TT>`loginfo'</TT>
files.  See section <A HREF="cvs_21.html#SEC140">The common syntax</A>.  Unlike the other files the second
part is <EM>not</EM> a command-line template.  Instead,
the part after the regular expression should be a full pathname to
a file containing the log message template.

</P>
<P>
If the repository name does not match any of the
regular expressions in this file, the <SAMP>`DEFAULT'</SAMP>
line is used, if it is specified.

</P>
<P>
All occurances of the name <SAMP>`ALL'</SAMP> appearing as a
regular expression are used in addition to the first
matching regular expression or <SAMP>`DEFAULT'</SAMP>.

</P>
<P>
The log message template will be used as a default log
message.  If you specify a log message with <SAMP>`cvs
commit -m <VAR>message</VAR>'</SAMP> or <SAMP>`cvs commit -f
<VAR>file</VAR>'</SAMP> that log message will override the
template.

</P>
<P>
See section <A HREF="cvs_21.html#SEC143">Editinfo example</A>, for an example <TT>`rcsinfo'</TT>
file.

</P>
<P>
When CVS is accessing a remote repository,
the contents of <TT>`rcsinfo'</TT> at the time a directory
is first checked out will specify a template which does
not then change.  If you edit <TT>`rcsinfo'</TT> or its
templates, you may need to check out a new working
directory.

</P>


<H2><A NAME="SEC148" HREF="cvs_toc.html#TOC148">Ignoring files via cvsignore</A></H2>
<P>
<A NAME="IDX399"></A>
<A NAME="IDX400"></A>
<A NAME="IDX401"></A>

</P>
<P>
There are certain file names that frequently occur
inside your working copy, but that you don't want to
put under CVS control.  Examples are all the object
files that you get while you compile your sources.
Normally, when you run <SAMP>`cvs update'</SAMP>, it prints a
line for each file it encounters that it doesn't know
about (see section <A HREF="cvs_20.html#SEC134">update output</A>).

</P>
<P>
CVS has a list of files (or sh(1) file name patterns)
that it should ignore while running <CODE>update</CODE>,
<CODE>import</CODE> and <CODE>release</CODE>.
This list is constructed in the following way.

</P>

<UL>
<LI>

The list is initialized to include certain file name
patterns: names associated with CVS
administration, or with other common source control
systems; common names for patch files, object files,
archive files, and editor backup files; and other names
that are usually artifacts of assorted utilities.
Currently, the default list of ignored file name
patterns is:

<A NAME="IDX402"></A>
<A NAME="IDX403"></A>

<PRE>
    RCS     SCCS    CVS     CVS.adm
    RCSLOG  cvslog.*
    tags    TAGS
    .make.state     .nse_depinfo
    *~      #*      .#*     ,*      _$*     *$
    *.old   *.bak   *.BAK   *.orig  *.rej   .del-*
    *.a     *.olb   *.o     *.obj   *.so    *.exe
    *.Z     *.elc   *.ln  
    core
</PRE>

<LI>

The per-repository list in
<TT>`$CVSROOT/CVSROOT/cvsignore'</TT> is appended to
the list, if that file exists.

<LI>

The per-user list in <TT>`.cvsignore'</TT> in your home
directory is appended to the list, if it exists.

<LI>

Any entries in the environment variable
<CODE>$CVSIGNORE</CODE> is appended to the list.

<LI>

Any <SAMP>`-I'</SAMP> options given to CVS is appended.

<LI>

As CVS traverses through your directories, the contents
of any <TT>`.cvsignore'</TT> will be appended to the list.
The patterns found in <TT>`.cvsignore'</TT> are only valid
for the directory that contains them, not for
any sub-directories.
</UL>

<P>
In any of the 5 places listed above, a single
exclamation mark (<SAMP>`!'</SAMP>) clears the ignore list.
This can be used if you want to store any file which
normally is ignored by CVS.

</P>


<H2><A NAME="SEC149" HREF="cvs_toc.html#TOC149">The history file</A></H2>
<P>
<A NAME="IDX404"></A>
<A NAME="IDX405"></A>

</P>
<P>
The file <TT>`$CVSROOT/CVSROOT/history'</TT> is used
to log information for the <CODE>history</CODE> command
(see section <A HREF="cvs_20.html#SEC110">history--Show status of files and users</A>).  This file must be created to turn
on logging.  This is done automatically if the
<CODE>cvs init</CODE> command is used to set up the
repository (see section <A HREF="cvs_5.html#SEC23">Creating a repository</A>).

</P>
<P>
The file format of the <TT>`history'</TT> file is
documented only in comments in the CVS source
code, but generally programs should use the <CODE>cvs
history</CODE> command to access it anyway, in case the
format changes with future releases of CVS.

</P>


<H2><A NAME="SEC150" HREF="cvs_toc.html#TOC150">Expansions in administrative files</A></H2>

<P>
Sometimes in writing an administrative file, you might
want the file to be able to know various things based
on environment CVS is running in.  There are
several mechanisms to do that.

</P>
<P>
To find the home directory of the user running CVS
(from the <CODE>HOME</CODE> environment variable), use
<SAMP>`~'</SAMP> followed by <SAMP>`/'</SAMP> or the end of the line.
Likewise for the home directory of <VAR>user</VAR>, use
<SAMP>`~<VAR>user</VAR>'</SAMP>.  These variables are expanded on
the server machine, and don't get any resonable
expansion if pserver (see section <A HREF="cvs_5.html#SEC26">Direct connection with password authentication</A>)
is in used; therefore user variables (see below) may be
a better choice to customize behavior based on the user
running CVS.

</P>
<P>
One may want to know about various pieces of
information internal to CVS.  A CVS internal
variable has the syntax <CODE>${<VAR>variable</VAR>}</CODE>,
where <VAR>variable</VAR> starts with a letter and consists
of alphanumberic characters and <SAMP>`_'</SAMP>.  If the
character following <VAR>variable</VAR> is a
non-alphanumeric character other than <SAMP>`_'</SAMP>, the
<SAMP>`{'</SAMP> and <SAMP>`}'</SAMP> can be omitted.  The CVS
internal variables are:

</P>
<DL COMPACT>

<DT><CODE>CVSROOT</CODE>
<DD>
This is the value of the CVS root in use.
See section <A HREF="cvs_5.html#SEC15">The Repository</A>, for a description of the various
ways to specify this.

<DT><CODE>RCSBIN</CODE>
<DD>
This is the value CVS is using for where to find
RCS binaries.  See section <A HREF="cvs_20.html#SEC89">Global options</A>, for a
description of how to specify this.

<DT><CODE>CVSEDITOR</CODE>
<DD>
<DT><CODE>VISUAL</CODE>
<DD>
<DT><CODE>EDITOR</CODE>
<DD>
These all expand to the same value, which is the editor
that CVS is using.  See section <A HREF="cvs_20.html#SEC89">Global options</A>, for how
to specify this.

<DT><CODE>USER</CODE>
<DD>
Username of the user running CVS (on the CVS
server machine).
</DL>

<P>
If you want to pass a value to the administrative files
which the user that is running CVS can specify,
use a user variable.  To expand a user variable, the
administrative file contains
<CODE>${=<VAR>variable</VAR>}</CODE>.  To set a user variable,
specify the global option <SAMP>`-s'</SAMP> to CVS, with
argument <CODE><VAR>variable</VAR>=<VAR>value</VAR></CODE>.  It may be
particularly useful to specify this option via
<TT>`.cvsrc'</TT> (see section <A HREF="cvs_20.html#SEC88">Default options and the ~/.cvsrc file</A>).

</P>
<P>
For example, if you want the administrative file to
refer to a test directory you might create a user
variable <CODE>TESTDIR</CODE>.  Then if CVS is invoked
as <CODE>cvs -s TESTDIR=/work/local/tests</CODE>, and the
administrative file contains <CODE>sh
${=TESTDIR}/runtests</CODE>, then that string is expanded
to <CODE>sh /work/local/tests/runtests</CODE>.

</P>
<P>
All other strings containing <SAMP>`$'</SAMP> are reserved;
there is no way to quote a <SAMP>`$'</SAMP> character so that
<SAMP>`$'</SAMP> represents itself.

</P>
<P><HR><P>
Go to the <A HREF="cvs_1.html">first</A>, <A HREF="cvs_20.html">previous</A>, <A HREF="cvs_22.html">next</A>, <A HREF="cvs_25.html">last</A> section, <A HREF="cvs_toc.html">table of contents</A>.
</BODY>
</HTML>
