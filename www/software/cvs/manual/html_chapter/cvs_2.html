<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.52
     from ../texi/cvs.texinfo on 7 November 1998 -->

<TITLE>CVS--Concurrent Versions System - What is CVS?</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="cvs_1.html">first</A>, <A HREF="cvs_1.html">previous</A>, <A HREF="cvs_3.html">next</A>, <A HREF="cvs_25.html">last</A> section, <A HREF="cvs_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC5" HREF="cvs_toc.html#TOC5">What is CVS?</A></H1>
<P>
<A NAME="IDX12"></A>
<A NAME="IDX13"></A>
<A NAME="IDX14"></A>

</P>
<P>
CVS is a version control system.  Using it, you can
record the history of your source files.

</P>

<P>
For example, bugs sometimes creep in when
software is modified, and you might not detect the bug
until a long time after you make the modification.
With CVS, you can easily retrieve old versions to see
exactly which change caused the bug.  This can
sometimes be a big help.

</P>
<P>
You could of course save every version of every file
you have ever created.  This would
however waste an enormous amount of disk space.  CVS
stores all the versions of a file in a single file in a
clever way that only stores the differences between
versions.

</P>
<P>
CVS also helps you if you are part of a group of people working
on the same project.  It is all too easy to overwrite
each others' changes unless you are extremely careful.
Some editors, like GNU Emacs, try to make sure that
the same file is never modified by two people at the
same time.  Unfortunately, if someone is using another
editor, that safeguard will not work.  CVS solves this problem
by insulating the different developers from each other.  Every
developer works in his own directory, and CVS merges
the work when each developer is done.

</P>
<P>
<A NAME="IDX15"></A>
<A NAME="IDX16"></A>
<A NAME="IDX17"></A>
<A NAME="IDX18"></A>
CVS started out as a bunch of shell scripts written by
Dick Grune, posted to <CODE>comp.sources.unix</CODE> in the volume 6
release of December, 1986.  While no actual code from
these shell scripts is present in the current version
of CVS much of the CVS conflict resolution algorithms
come from them.

</P>
<P>
In April, 1989, Brian Berliner designed and coded CVS.
Jeff Polk later helped Brian with the design of the CVS
module and vendor branch support.

</P>
<P>
<A NAME="IDX19"></A>
You can get CVS via anonymous ftp from a number of
sites, for instance <TT>prep.ai.mit.edu</TT> in
<TT>`pub/gnu'</TT>.

</P>
<P>
<A NAME="IDX20"></A>
<A NAME="IDX21"></A>
<A NAME="IDX22"></A>
There is a mailing list, known as <CODE>info-cvs</CODE>,
devoted to CVS.  To subscribe or
unsubscribe 
send a message to
<CODE>info-cvs-request@prep.ai.mit.edu</CODE>.  Please be
specific about your email address.  As of May 1996,
subscription requests are handled by a busy human
being, so you cannot expect to be added or removed
immediately.  The usenet group
<CODE>comp.software.config-mgmt</CODE> is also a suitable
place for CVS discussions (along with other
configuration management systems).

</P>



<H2><A NAME="SEC6" HREF="cvs_toc.html#TOC6">CVS is not...</A></H2>

<P>
CVS can do a lot of things for you, but it does
not try to be everything for everyone.

</P>
<DL COMPACT>

<DT>CVS is not a build system.
<DD>
Though the structure of your repository and modules
file interact with your build system
(e.g. <TT>`Makefile'</TT>s), they are essentially
independent.

CVS does not dictate how you build anything.  It
merely stores files for retrieval in a tree structure
you devise.

CVS does not dictate how to use disk space in the
checked out working directories.  If you write your
<TT>`Makefile'</TT>s or scripts in every directory so they
have to know the relative positions of everything else,
you wind up requiring the entire repository to be
checked out.

If you modularize your work, and construct a build
system that will share files (via links, mounts,
<CODE>VPATH</CODE> in <TT>`Makefile'</TT>s, etc.), you can
arrange your disk usage however you like.

But you have to remember that <EM>any</EM> such system is
a lot of work to construct and maintain.  CVS does
not address the issues involved.

Of course, you should place the tools created to
support such a build system (scripts, <TT>`Makefile'</TT>s,
etc) under CVS.

Figuring out what files need to be rebuilt when
something changes is, again, something to be handled
outside the scope of CVS.  One traditional
approach is to use <CODE>make</CODE> for building, and use
some automated tool for generating the depencies which
<CODE>make</CODE> uses.

<DT>CVS is not a substitute for management.
<DD>
Your managers and project leaders are expected to talk
to you frequently enough to make certain you are aware
of schedules, merge points, branch names and release
dates.  If they don't, CVS can't help.

CVS is an instrument for making sources dance to
your tune.  But you are the piper and the composer.  No
instrument plays itself or writes its own music.

<DT>CVS is not a substitute for developer communication.
<DD>
When faced with conflicts within a single file, most
developers manage to resolve them without too much
effort.  But a more general definition of "conflict"
includes problems too difficult to solve without
communication between developers.

CVS cannot determine when simultaneous changes
within a single file, or across a whole collection of
files, will logically conflict with one another.  Its
concept of a <EM>conflict</EM> is purely textual, arising
when two changes to the same base file are near enough
to spook the merge (i.e. <CODE>diff3</CODE>) command.

CVS does not claim to help at all in figuring out
non-textual or distributed conflicts in program logic.

For example: Say you change the arguments to function
<CODE>X</CODE> defined in file <TT>`A'</TT>.  At the same time,
someone edits file <TT>`B'</TT>, adding new calls to
function <CODE>X</CODE> using the old arguments.  You are
outside the realm of CVS's competence.

Acquire the habit of reading specs and talking to your
peers.

<DT>CVS does not have change control
<DD>
Change control refers to a number of things.  First of
all it can mean <EM>bug-tracking</EM>, that is being able
to keep a database of reported bugs and the status of
each one (is it fixed?  in what release?  has the bug
submitter agreed that it is fixed?).  For interfacing
CVS to an external bug-tracking system, see the
<TT>`rcsinfo'</TT> and <TT>`editinfo'</TT> files
(see section <A HREF="cvs_21.html#SEC136">Reference manual for the Administrative files</A>).

Another aspect of change control is keeping track of
the fact that changes to several files were in fact
changed together as one logical change.  If you check
in several files in a single <CODE>cvs commit</CODE>
operation, CVS then forgets that those files were
checked in together, and the fact that they have the
same log message is the only thing tying them
together.  Keeping a GNU style <TT>`ChangeLog'</TT>
can help somewhat.

Another aspect of change control, in some systems, is
the ability to keep track of the status of each
change.  Some changes have been written by a developer,
others have been reviewed by a second developer, and so
on.  Generally, the way to do this with CVS is to
generate a diff (using <CODE>cvs diff</CODE> or <CODE>diff</CODE>)
and email it to someone who can then apply it using the
<CODE>patch</CODE> utility.  This is very flexible, but
depends on mechanisms outside CVS to make sure
nothing falls through the cracks.

<DT>CVS is not an automated testing program
<DD>
It should be possible to enforce mandatory use of a
testsuite using the <CODE>commitinfo</CODE> file.  I haven't
heard a lot about projects trying to do that or whether
there are subtle gotchas, however.

<DT>CVS does not have a builtin process model
<DD>
Some systems provide ways to ensure that changes or
releases go through various steps, with various
approvals as needed.  Generally, one can accomplish
this with CVS but it might be a little more work.
In some cases you'll want to use the <TT>`commitinfo'</TT>,
<TT>`loginfo'</TT>, <TT>`rcsinfo'</TT>, or <TT>`editinfo'</TT>
files, to require that certain steps be performed
before cvs will allow a checkin.  Also consider whether
features such as branches and tags can be used to
perform tasks such as doing work in a development tree
and then merging certain changes over to a stable tree
only once they have been proven.
</DL>

<P><HR><P>
Go to the <A HREF="cvs_1.html">first</A>, <A HREF="cvs_1.html">previous</A>, <A HREF="cvs_3.html">next</A>, <A HREF="cvs_25.html">last</A> section, <A HREF="cvs_toc.html">table of contents</A>.
</BODY>
</HTML>
