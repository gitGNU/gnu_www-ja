<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.52
     from ../texi/cvs.texinfo on 7 November 1998 -->

<TITLE>CVS--Concurrent Versions System - Wrappers</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="cvs_1.html">first</A>, <A HREF="cvs_130.html">previous</A>, <A HREF="cvs_132.html">next</A>, <A HREF="cvs_148.html">last</A> section, <A HREF="cvs_toc.html">table of contents</A>.
<P><HR><P>


<H2><A NAME="SEC138" HREF="cvs_toc.html#TOC138">The cvswrappers file</A></H2>
<P>
<A NAME="IDX371"></A>
<A NAME="IDX372"></A>
<A NAME="IDX373"></A>

</P>

<P>
Wrappers allow you to set a hook which transforms files on
their way in and out of CVS.  Most or all of the
wrappers features do not work with client/server CVS.

</P>
<P>
The file <TT>`cvswrappers'</TT> defines the script that will be
run on a file when its name matches a regular
expresion. There are two scripts that can be run on a
file or directory. One script is executed on the file/directory
before being checked into the repository (this is denoted
with the <CODE>-t</CODE> flag) and the other when the file is
checked out of the repository (this is denoted with the
<CODE>-f</CODE> flag)

</P>
<P>
The <TT>`cvswrappers'</TT> also has a <SAMP>`-m'</SAMP> option to
specify the merge methodology that should be used when
the file is updated.  <CODE>MERGE</CODE> means the usual
CVS behavior: try to merge the files (this
generally will not work for binary files).  <CODE>COPY</CODE>
means that <CODE>cvs update</CODE> will merely copy one
version over the other, and require the user using
mechanisms outside CVS, to insert any necessary
changes.
The <SAMP>`-m'</SAMP> wrapper option only affects behavior when
merging is done on update; it does not affect how files
are stored.  See See section <A HREF="cvs_81.html#SEC83">Handling binary files</A>, for more on
binary files.

</P>
<P>
The basic format of the file <TT>`cvswrappers'</TT> is:

</P>

<PRE>
wildcard     [option value][option value]...

where option is one of
-f           from cvs filter         value: path to filter
-t           to cvs filter           value: path to filter
-m           update methodology      value: MERGE or COPY
-k           keyword expansion       value: expansion mode

and value is a single-quote delimited value.
</PRE>


<PRE>
*.nib    -f 'unwrap %s' -t 'wrap %s %s' -m 'COPY'
*.c      -t 'indent %s %s'
</PRE>

<P>
The above example of a <TT>`cvswrappers'</TT> file
states that all files/directories that end with a <CODE>.nib</CODE>
should be filtered with the <TT>`wrap'</TT> program before
checking the file into the repository. The file should
be filtered though the <TT>`unwrap'</TT> program when the
file is checked out of the repository. The
<TT>`cvswrappers'</TT> file also states that a <CODE>COPY</CODE>
methodology should be used when updating the files in
the repository (that is no merging should be performed).

</P>
<P>
The last example line says that all files that end with
a <CODE>*.c</CODE> should be filtered with <TT>`indent'</TT>
before being checked into the repository. Unlike the previous
example no filtering of the <CODE>*.c</CODE> file is done when
it is checked out of the repository.
The <CODE>-t</CODE> filter is called with two arguments,
the first is the name of the file/directory to filter
and the second is the pathname to where the resulting
filtered file should be placed.

</P>
<P>
The <CODE>-f</CODE> filter is called with one argument,
which is the name of the file to filter from. The end
result of this filter will be a file in the users directory
that they can work on as they normally would.

</P>
<P>
For another example, the following command imports a
directory, treating files whose name ends in
<SAMP>`.exe'</SAMP> as binary:

</P>

<PRE>
cvs import -I ! -W "*.exe -k 'b'" first-dir vendortag reltag
</PRE>

<P><HR><P>
Go to the <A HREF="cvs_1.html">first</A>, <A HREF="cvs_130.html">previous</A>, <A HREF="cvs_132.html">next</A>, <A HREF="cvs_148.html">last</A> section, <A HREF="cvs_toc.html">table of contents</A>.
</BODY>
</HTML>
