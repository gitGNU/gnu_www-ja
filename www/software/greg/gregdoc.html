<HTML>
<HEAD>
<!-- Created by texi2html 1.56k from gregdoc on 12 February 2001 -->

<TITLE>Greg testing framework</TITLE>
</HEAD>
<BODY>
<H1>The Greg testing framework</H1>
<H2>for Greg Version 1.4</H2>
<H2>February 2001</H2>
<ADDRESS>Richard Frith-Macdonald &#60;<A HREF="mailto:rfm@gnu.org">rfm@gnu.org</A>&#62;</ADDRESS>
<P>
<P><HR><P>
<H1>Table of Contents</H1>
<UL>
<LI><A NAME="TOC1" HREF="gregdoc.html#SEC1">Copying</A>
<LI><A NAME="TOC2" HREF="gregdoc.html#SEC2">New in this release</A>
<LI><A NAME="TOC3" HREF="gregdoc.html#SEC3">Greg in brief</A>
<UL>
<LI><A NAME="TOC4" HREF="gregdoc.html#SEC4">How to run a Greg testsuite</A>
<LI><A NAME="TOC5" HREF="gregdoc.html#SEC5">A trivial example of a testcase</A>
<LI><A NAME="TOC6" HREF="gregdoc.html#SEC6">Why Greg does what it does</A>
<LI><A NAME="TOC7" HREF="gregdoc.html#SEC7">A POSIX conforming test framework</A>
</UL>
<LI><A NAME="TOC8" HREF="gregdoc.html#SEC8">Installing Greg</A>
<UL>
<UL>
<LI><A NAME="TOC9" HREF="gregdoc.html#SEC9">Requirements</A>
<LI><A NAME="TOC10" HREF="gregdoc.html#SEC10">Building</A>
<LI><A NAME="TOC11" HREF="gregdoc.html#SEC11">Problems</A>
</UL>
</UL>
<LI><A NAME="TOC12" HREF="gregdoc.html#SEC12">Using <TT>`greg'</TT></A>
<UL>
<LI><A NAME="TOC13" HREF="gregdoc.html#SEC13">Output</A>
<LI><A NAME="TOC14" HREF="gregdoc.html#SEC14">Files and directories</A>
<LI><A NAME="TOC15" HREF="gregdoc.html#SEC15">Embedded usage</A>
<LI><A NAME="TOC16" HREF="gregdoc.html#SEC16">Command-line usage</A>
</UL>
<LI><A NAME="TOC17" HREF="gregdoc.html#SEC17">Writing tests</A>
<UL>
<UL>
<LI><A NAME="TOC18" HREF="gregdoc.html#SEC18">getting started</A>
<LI><A NAME="TOC19" HREF="gregdoc.html#SEC19">types of testsuite</A>
<LI><A NAME="TOC20" HREF="gregdoc.html#SEC20">testsuite file layout</A>
<LI><A NAME="TOC21" HREF="gregdoc.html#SEC21">greg-expect-pass</A>
<LI><A NAME="TOC22" HREF="gregdoc.html#SEC22">greg-expect-fail</A>
<LI><A NAME="TOC23" HREF="gregdoc.html#SEC23">greg-testcase</A>
<LI><A NAME="TOC24" HREF="gregdoc.html#SEC24">Multiple testcases</A>
<LI><A NAME="TOC25" HREF="gregdoc.html#SEC25">External tests</A>
<UL>
<LI><A NAME="TOC26" HREF="gregdoc.html#SEC26">Starting a child process</A>
<LI><A NAME="TOC27" HREF="gregdoc.html#SEC27">Sending to a child process</A>
<LI><A NAME="TOC28" HREF="gregdoc.html#SEC28">Reading from a child process</A>
<LI><A NAME="TOC29" HREF="gregdoc.html#SEC29">A complete external test</A>
</UL>
</UL>
</UL>
<LI><A NAME="TOC30" HREF="gregdoc.html#SEC30">Index</A>
</UL>
<P><HR><P>


<H1><A NAME="SEC1" HREF="gregdoc.html#TOC1">Copying</A></H1>

<P>
See the file <TT>`COPYING.LIB'</TT>.




<H1><A NAME="SEC2" HREF="gregdoc.html#TOC2">New in this release</A></H1>
<P>
<A NAME="IDX1"></A>


<P>
New in 1.4



<UL>
<LI>

Updated to save/restore expect settings at start of a tool and end of a
tool so that they can be readily set up for the duration of a tool test.
<LI>

The default action on reading an end of file from a child is now to 
make the test FAIL rather than be unresolved.
<LI>

The default action on having a timeout when reading from a child is now to 
make the test FAIL rather than be unresolved.
<LI>

Added hooks for pre and post testcase procedures.
</UL>

<P>
New in 1.3



<UL>
<LI>

Add <CODE>greg-directory</CODE> to return the absolute path to the directory
in which the executing test script is located.
</UL>

<P>
New in 1.2



<UL>
<LI>

Permit the files in the <CODE>greg-files</CODE> variable to use the <TT>`.scm'</TT>
extension or not.
<LI>

Added <CODE>greg-paths</CODE> variable to permit direct running of named files
rather than using the DejaGNU-like tools directory structure.
<LI>

Alter the <TT>`greg'</TT> script to set the <CODE>greg-paths</CODE> variable to
contain any files listed on the command-line.
<LI>

Added <CODE>greg-expect-pass</CODE> and <CODE>greg-expect-fail</CODE> macros.
</UL>

<P>
New in 1.1



<UL>
<LI>

Changed from using GNU Library General Public License to the newer
GNU Lesser General Public License.
<LI>

Changed from using a compiled module (deprecated in guile) to using a
dynamic library for pty support.
</UL>

<P>
New in 1.0



<UL>
<LI>

Nothing really - a few very minor fixes - no bug reports, which is why I
decided to risk bumping the version number to 1.0 - presumably people will
now find hundreds of bugs...
<LI>

Updated to work with Guile and 1.3.4
</UL>

<P>
New in 0.7



<UL>
<LI>

Updated to work with Guile 1.3.2 and 1.3.3
<LI>

Updated to work on GNU/Linux systems with pts rather than ptys
<LI>

Improved configuration code
</UL>

<P>
New in 0.6



<UL>
<LI>

Converted makefiles to work without GNUstep
<LI>

Improved configuration code
<LI>

Improved documentation somewhat
<LI>

Updated to work with guile version 1.3
</UL>

<P>
New in 0.5



<UL>
<LI>

greg-testcase now returns a useful result.
<LI>

Fixed bug in creating child processes on some systems.
</UL>

<P>
New in 0.4



<UL>
<LI>

Allow an empty string as the program name for creating a child process -
in which case, we fork without execing to another program.
Modified Greg to allow <CODE>(quit)</CODE> to exit from the test system.
</UL>

<P>
New in 0.3



<UL>
<LI>

Improved installation - now checks for location of guile shell.
<LI>

Fixed a couple of minor errors in the documentation.
</UL>

<P>
New in 0.2



<UL>
<LI>

Ported to Unixware 2.1.3 - should work for any SysV4.2 based unix.
</UL>

<P>
General news


<P>
This release of Greg provides a test framework much like that of
DejaGNU, but also provides Guile modules to permit `embedded' testing of
applications that use Guile as a scripting language and libraries that
are directly accessible to Guile.


<P>
This release has been tested with Guile-1.3.4 and 1.3.3, it will certainly
not run on versions earlier than 1.3.1


<P>
Apologies to Guile/Scheme/Lisp programmers out there - I came to this from
Objective-C programming and taught myself during the four weeks that
I wrote GNUstep-Guile and Greg - so my code is probably really ugly - but it
does seem to work.


<P>
The code to run a child process in a pseudo-terminal works for
GNU/Linux and SysV4.2 systems - it probably needs work to make it
more portable -
Please email bugfixes and comments to &#60;bug-gnustep@gnu.org&#62; or directly to
me &#60;rfm@gnu.org&#62;




<H1><A NAME="SEC3" HREF="gregdoc.html#TOC3">Greg in brief</A></H1>
<P>
<A NAME="IDX2"></A>


<P>
Greg is a framework for testing other programs and libraries.
Its purpose is to provide a single front end for all tests and to
be a small, simple framework for writing tests.
Greg leverages off the Guile language to provide all the power (and more)
of other test frameworks with greater simplicity and ease of use.


<P>
The simplicity of the Greg framework makes it easy to write tests for
any program, but it was specifically written for use with GNUstep-Guile
to permit direct testing of the
<A HREF="http://www.gnustep.org/">GNUstep</A> libraries without the
necessity to run a separate driver program.


<P>
The core functionality of Greg is a Guile module which can be loaded
into any software with an embedded Guile interpreter.  Any program
which uses Guile as it's scripting language can therefore use Greg
to test itself directly!


<P>
For testing external programs, Greg provides a compiled module that may
be dynamically linked into Guile to permit you to run an application as
a child process on a pseudo-terminal.  In conjunction with the standard
Guile `expect' module, this lets you test external programs.


<P>
Also provided is <TT>`greg'</TT> - a Guile script to invoke the Greg test
framework in much the same way that <CODE>runtest</CODE> is used in DejaGNU.


<P>
All tests have the same output format (enforced by the <CODE>greg-testcase</CODE>
procedure).
Greg's output is designed to be both readable and readily parsed by other
software, so that it can be used as input to customised testing processes.


<P>
Greg provides most of the functionality of DejaGNU but is rather simpler.
It omits specific support for cross-platform/remote testing since this is
really rather trivial to add where required and tends to vary from site to
site so much that an attempt at a generic solution is pretty pointless.
What Greg does do, is provide hooks to let you easily introduce site
specific code for handling those sorts of situations.


<P>
The current version of Greg can normally be found on GNU ftp sites,
with documentation online at
<A HREF="http://www.gnu.org/software/greg/gregdoc.html">http://www.gnu.org/software/greg/gregdoc.html</A>


<P>
or, for the bleeding edge - availably by anonymous cvs as part of the
GNUstep-Guile package in the GNUstep project -


<P>
CVSROOT=":pserver:anoncvs@cvs.net-community.com:/gnustep"<BR>
export CVSROOT<BR>
cvs login (password is `anoncvs')<BR>
cvs -z3 checkout guile<BR>




<H2><A NAME="SEC4" HREF="gregdoc.html#TOC4">How to run a Greg testsuite</A></H2>
<P>
<A NAME="IDX3"></A>
<A NAME="IDX4"></A>
<A NAME="IDX5"></A>


<P>
<A NAME="IDX6"></A>
To run tests from an existing collection, try running



<PRE>
make check
</PRE>

<P>
<A NAME="IDX7"></A>
If the <CODE>check</CODE> target exists, it usually saves you some
trouble--for instance, it can set up any auxiliary programs or other
files needed by the tests.


<P>
Alternatively, if you are in the top-level source directory of an existing
testsuite (ie. there are subdirectories containing files with a <TT>`.scm'</TT>
extension), you can get the <TT>`greg'</TT> script to test all the tools in the
directory by typing  -



<PRE>
greg
</PRE>

<P>
Finally, if you just want to run the tests that are in a specific file
(or files), you can get the <TT>`greg'</TT> script to run them simply by
listing the files on the command line.



<PRE>
greg a-file-to-run another-file-to-run

or, for verbose output -

greg --verbose a-file-to-run another-file-to-run
</PRE>

<P>
If you have a test suite that is intended to be used for `embedded' testing -
You need to start the application to be tested, gain access to it's Guile
command line (or other guile interface) and enter the commands -



<PRE>
(use-modules (ice-9 greg))
(greg-test-all)
</PRE>



<H2><A NAME="SEC5" HREF="gregdoc.html#TOC5">A trivial example of a testcase</A></H2>

<P>
<A NAME="IDX8"></A>
Each Greg test is a Guile script; the tests vary widely in
complexity, depending on the nature of the tool and the feature tested.



<PRE>
;
; GNUstep-guile interface library test
;
; Create an object using the NSString [stringWithCString:] method and
; check that the resulting object is of the correct class.
;
(greg-testcase "The `stringWithCString:' method creates an NSString object" #t
(lambda ()
  (define obj ([] "NSString" stringWithCString: "Hello world"))
  (gstep-bool ([] obj isKindOfClass: ([] "NSString" class)))
))
</PRE>

<P>
Though brief, this example is a complete test.  It illustrates some of
the main features of Greg test scripts:



<UL>
<LI>

The test case does not deal with accessing the library - the Guile interpreter
in use is linked with the library.  If you were testing an external application
which needed to be started up as a child process running on a pseudo-terminal,
the process startup would have been performed in a separate <TT>`begin.grg'</TT>
script.

<LI>

You use the Guile programming language to write the script and, in this case,
the builtin macros and procedures (such as <CODE>gstep-bool</CODE> and <CODE>[]</CODE>
provided by the GNUstep-Guile library.

<LI>

Test cases use the procedure <CODE>greg-testcase</CODE> to record the test outcome.
You pass this procedure a string (`assertion') describing the testcase,
a boolean specifying the expected outcome, and a `thunk' (parameterless
procedure) that performs the actual test.<BR>
The `thunk' is normally a `lambda expression' - you can look these up in the
Guile/Scheme documentation  - or just follow the example.

<LI>

As much code as possible is placed inside the `thunk' passed to
<CODE>greg-testcase</CODE> so that, in the event of an error, the <CODE>greg-testcase</CODE>
procedure can trap it and report an unresolved test.<BR>
The code - 
<CODE>(define obj ([] "NSString" stringWithCString: "Hello world"))</CODE> could have
appeared outside the testcase, but that would have been less safe.

</UL>

<P>
 
Here is the same example in a slightly different form - using the
<CODE>greg-expect-pass</CODE> macro -



<PRE>
;
; GNUstep-guile interface library test
;
; Create an object using the NSString [stringWithCString:] method and
; check that the resulting object is of the correct class.
;
(greg-expect-pass "The `stringWithCString:' method creates an NSString object"
  (define obj ([] "NSString" stringWithCString: "Hello world"))
  (gstep-bool ([] obj isKindOfClass: ([] "NSString" class)))
)
</PRE>



<H2><A NAME="SEC6" HREF="gregdoc.html#TOC6">Why Greg does what it does</A></H2>
<P>
<A NAME="IDX9"></A>


<P>
Greg was written to support regression testing for the
<A HREF="http://www.gnustep.org/">GNUstep</A> libraries.
It was inspired by an earlier test framework (by Ovidiu Predescu) that used
DejaGNU along with a `driver' program (to make the calls to the library) and
a suite of TcL scripts to control the driver.


<P>
There were three main problems (inherent in the nature of DejaGNU) with that
approach -



<UL>

<LI>Writing/Debugging tests was a pain - errors in the TcL code of a testcase

could all too easily interfere with the TcL routines that interfaced to the
driver program.<BR>
Solution - use another language where errors in testcases are localised.

<LI>Writing/Debugging tests was a pain - you needed to attach gdb to the

driver program that was running as a child of the DejaGNU process in order
to debug errors in the driver/library under test.<BR>
Solution - `embedded testing' make the test framework and the code under
test part of the process, so it's easy to run the whole thing under gdb.

<LI>The driver program and TcL scripts required quite a bit of support

when adding new tests.<BR>
Solution - `embedded testing' we needed to remove the intermediary layers
and test as directly as possible.

</UL>

<P>
So, something different was required, a test framework in a safer, simpler
language that made it easy to create thin interfaces to libraries, so
simplifying the task of producing testcases.


<P>
Of course, the good points of DejaGNU needed to be retained - clear
output, Posix compliance, the ability to test separate programs as well
as libraries.


<P>
A couple of additional goals seemed worthwhile -



<UL>
<LI>Make the test framework flexible so that applications could easily

use it for self-testing.

<LI>Give the framework a similar structure to, and a user interface like

that of DejaGNU, so that people with a background in testing could easily
adopt it.
</UL>

<P>
Hopefully, Greg meets all its goals.




<H2><A NAME="SEC7" HREF="gregdoc.html#TOC7">A POSIX conforming test framework</A></H2>

<P>
<A NAME="IDX10"></A>
<A NAME="IDX11"></A>


<P>
This section is copied almost directly from the DejaGNU documentation
with minor modifications -


<P>
Greg is believed to conform to the POSIX standard for test frameworks.


<P>
POSIX standard 1003.3 defines what a testing framework needs to
provide, in order to permit the creation of POSIX conformance
test suites. This standard is primarily oriented to running POSIX
conformance tests, but its requirements also support testing of features
not related to POSIX conformance.


<P>
The POSIX documentation refers to <EM>assertions</EM>.  An assertion
is a description of behavior.  For example, if a standard says "The sun
shall shine", a corresponding assertion might be "The sun is
shining."  A test based on this assertion would pass or fail depending
on whether it is daytime or nighttime.  It is important to note that the
standard being tested is never 1003.3; the standard being tested is some
other standard, for which the assertions were written.


<P>
As there is no test suite to test <EM>testing frameworks</EM> for
POSIX 1003.3 conformance, verifying conformance to this standard is
done by repeatedly reading the standard and experimenting.  One of the
main things 1003.3 does specify is the set of allowed output messages,
and their definitions.  Four messages are supported for a required
feature of POSIX conforming systems, and a fifth for a conditional
feature. Greg supports the use of all five output messages; in this
sense a test suite that uses exactly these messages can be considered
POSIX conforming.  These definitions specify the output of a test
case:


<DL COMPACT>

<DT><CODE>PASS</CODE>
<DD>
<A NAME="IDX12"></A>
 
<A NAME="IDX13"></A>
A test has succeeded.  That is, it demonstrated that the assertion is true.

<A NAME="IDX14"></A>
<DT><CODE>UPASS</CODE>
<DD>
<A NAME="IDX15"></A>
POSIX 1003.3 does not incorporate the notion of unexpected passes,
so for strict POSIX, <CODE>PASS</CODE>, instead of <CODE>UPASS</CODE>, is returned
for test cases which were not expected to pass but did.  This means that
<CODE>PASS</CODE> is in some sense more ambiguous than if <CODE>UPASS</CODE> is also
used.

<DT><CODE>FAIL</CODE>
<DD>
<A NAME="IDX16"></A>
<A NAME="IDX17"></A>
A test <EM>has</EM> produced the bug it was intended to capture.  That is,
it has demonstrated that the assertion is false.  The <CODE>FAIL</CODE>
message is based on the test case only.  Other messages are used to
indicate a failure of the framework.

<A NAME="IDX18"></A>
<DT><CODE>XFAIL</CODE>
<DD>
<A NAME="IDX19"></A>
POSIX 1003.3 does not incorporate the notion of expected failures,
so for strict POSIX, <CODE>FAIL</CODE>, instead of <CODE>XFAIL</CODE>, is returned
for test cases which were expected to fail and did not.  This means that
<CODE>FAIL</CODE> is in some sense more ambiguous than if <CODE>XFAIL</CODE> is also
used.

<DT><CODE>UNRESOLVED</CODE>
<DD>
<A NAME="IDX20"></A>
<A NAME="IDX21"></A>
A test produced indeterminate results.  Usually, this means the test
executed in an unexpected fashion; this outcome requires that a human
being go over results, to determine if the test should have passed or
failed.  This message is also used for any test that requires human
intervention because it is beyond the abilities of the testing
framework.  Any unresolved test should resolved to <CODE>PASS</CODE> or
<CODE>FAIL</CODE> before a test run can be considered finished.

Note that for POSIX, each assertion must produce a test result
code.  If the test isn't actually run, it must produce <CODE>UNRESOLVED</CODE>
rather than just leaving that test out of the output.  With Greg this is
not a problem - any unexpected termination of a <CODE>greg-testcase</CODE>
procedure will produce <CODE>UNRESOLVED</CODE>.

Here are some of the ways a test may wind up <CODE>UNRESOLVED</CODE>:


<UL>
<LI>

A test's execution is interrupted.

<LI>

A test does not produce a clear result. This is usually because there
was a Guile exception thrown while processing the test.
This usually requires a human being to examine the output to
determine what really happened--and to improve the test case.

<LI>

A test depends on a previous test, which fails.

<LI>

The test was set up incorrectly and failed to produce a boolean value.
</UL>

<DT><CODE>UNTESTED</CODE>
<DD>
<A NAME="IDX22"></A>
A test was not run.  This is a placeholder, used when there is no
real test case yet.
</DL>

<P>
The only remaining output message left is intended to test features that
are specified by the applicable POSIX standard as conditional:


<DL COMPACT>

<DT><CODE>UNSUPPORTED</CODE>
<DD>
<A NAME="IDX23"></A>
There is no support for the tested case.  This may mean that a
conditional feature of an operating system, or of a compiler, is not
implemented.
</DL>
<P>
Greg uses the same output procedures to produce these messages for
all test suites, and these procedures are already known to conform to
POSIX 1003.3.  For a Greg test suite to conform to POSIX
1003.3, you must set the variable <CODE>greg-posix</CODE> to be true (or run
the <TT>`greg'</TT> command with the <CODE>--posix</CODE> flag).
Doing this will ensure that non-posix extensions are not used.




<H1><A NAME="SEC8" HREF="gregdoc.html#TOC8">Installing Greg</A></H1>
<P>
<A NAME="IDX24"></A>




<H3><A NAME="SEC9" HREF="gregdoc.html#TOC9">Requirements</A></H3>
<P>
<A NAME="IDX25"></A>


<P>
Greg needs to have Guile installed.  It should work with Guile-1.3
or later.
You need to have the <TT>`guile'</TT> program in your path in
order for the installation process to determine the proper locations
for things.


<P>
You can get Guile from any GNU ftp site.


<P>
The current version of Greg can normally be found on GNU ftp sites,
with documentation online at
<A HREF="http://www.gnu.org/software/greg/gregdoc.html">http://www.gnu.org/software/greg/gregdoc.html</A>


<P>
or, for the bleeding edge - availably by anonymous cvs from the
GNUstep project (<A HREF="http://www.gnustep.org/">http://www.gnustep.org/</A>) -


<P>
CVSROOT=":pserver:anoncvs@cvs.net-community.com:/gnustep"<BR>
export CVSROOT<BR>
cvs login (password is `anoncvs')<BR>
cvs -z3 checkout guile/Greg<BR>




<H3><A NAME="SEC10" HREF="gregdoc.html#TOC10">Building</A></H3>
<P>
<A NAME="IDX26"></A>


<P>
To build Greg - 


<P>
Type <CODE>./configure</CODE> in the main Greg directory to configure for
your system.


<P>
Once configuration is complete, go into the `Library' subdirectory and
type <CODE>make install</CODE> to build and install things.


<P>
You should end up with -


<P>
A dynamic library, which can be dynamically linked into Guile with
<CODE>
(if (not (feature? 'greg-pty))
    (dynamic-call "scm_init_greg" (dynamic-link "libgreg.so")))
</CODE>


<P>
a module defining Guile procedures and variables providing the main
test framework, which can be accessed using
<CODE>(use-modules (ice-9 greg))</CODE>,


<P>
and a Guile script that you can use to run tests from the unix
command-line (<TT>`greg'</TT>).


<P>
You <EM>MUST</EM> install Greg before you attempt to use it (or run it's
self-tests) because the Guile modules making it up must be in place in
the standard Guile directories before Greg can work.


<P>
Once Greg is installed, you can type <CODE>make check</CODE> in the Tests
directory to get Greg to test itself.


<P>
You can type <CODE>make</CODE> in the Documentation directory to build the
documentation in <EM>info</EM>, <EM>html</EM> and <EM>dvi</EM> formats.


<P>
NB.<BR>
You must have the <TT>`makeinfo'</TT> program installed to build the
documentation in info format <BR>
You must have the <TT>`texi2html'</TT> program installed to build the
documentation in html format <BR>
You must have the <TT>`texi2dvi'</TT> program installed to build the
documentation in dvi format <BR>




<H3><A NAME="SEC11" HREF="gregdoc.html#TOC11">Problems</A></H3>
<P>
<A NAME="IDX27"></A>
<A NAME="IDX28"></A>


<P>
Greg is quite simple, so there is not much to go wrong with it.
Of course, you must have a working copy of Guile installed, and you need
to make sure you ran the configure script to configure Greg for your system,
and installed Greg, but after that, most stuff should just work.


<P>
The single area where you are most likely to encounter problems is if you are
using Greg to test external programs run in a child process using the
<CODE>(greg-child)</CODE> procedure.



<UL>
<LI>

If you install Greg in a non-standard location, it's possible that guile
will not be able to find the <CODE>libgreg.so</CODE> dynamic library to load it.
In this case, you will need to change/set the <CODE>LD_LIBRARY_PATH</CODE>
environment variable (or whatever other environment variable your operating
system uses to list the places in which dynamic libraries may be found) to
include the directory in which the library has been installed.
<LI>

The C code for this procedure is quite system-dependent and
has only been tested on a few operating systems.
If you have problems with this, look at <TT>`greg.c'</TT> in the Library
directory.
</UL>

<P>
Please attempt to make a patch to fix things on your
operating-system and send it to me - &#60;rfm@gnu.org&#62; or to
&#60;bug-gnustep@gnu.org&#62;




<H1><A NAME="SEC12" HREF="gregdoc.html#TOC12">Using <TT>`greg'</TT></A></H1>
<P>
<A NAME="IDX29"></A>
<A NAME="IDX30"></A>


<P>
The Greg framework is designed to be used in two ways - as an embedded
system from within any application which is linked with the Guile library,
or stand-alone using the command-line <TT>`greg'</TT> driver script.
For both of these methods of usage the test cases are written the same
way and the expected output is the same.




<H2><A NAME="SEC13" HREF="gregdoc.html#TOC13">Output</A></H2>

<P>
While Greg may produce more verbose output in response to various settings,
the basic output of a test run is a series of lines describing the
success/failure state of each testcase encountered, followed by a
summary of all test cases.


<P>
In `normal' mode, only unexpected results are displayed, but in `verbose'
output mode, results for <EM>all</EM> results are displayed.


<P>
<TT>`greg'</TT> flags the outcome of each test case with a line consisting of
one of the following codes followed by a colon, a space, and then the
testcase description.


<DL COMPACT>

<DT><CODE>PASS</CODE>
<DD>
<A NAME="IDX31"></A>
<A NAME="IDX32"></A>
<A NAME="IDX33"></A>
The most desirable outcome: the test succeeded, and was expected to
succeed.

<DT><CODE>UPASS</CODE>
<DD>
<A NAME="IDX34"></A>
<A NAME="IDX35"></A>
<A NAME="IDX36"></A>
A pleasant kind of failure: a test was expected to fail, but succeeded.
This may indicate progress; inspect the test case to determine whether
you should amend it to stop expecting failure.

<DT><CODE>FAIL</CODE>
<DD>
<A NAME="IDX37"></A>
<A NAME="IDX38"></A>
<A NAME="IDX39"></A>
A test failed, although it was expected to succeed.  This may indicate
regress; inspect the test case and the failing software to locate the bug.

<DT><CODE>XFAIL</CODE>
<DD>
<A NAME="IDX40"></A>
<A NAME="IDX41"></A>
<A NAME="IDX42"></A>
A test failed, but it was expected to fail.  This result indicates no
change in a known bug.  If a test fails because the operating system
where the test runs lacks some facility required by the test, the
outcome is <CODE>UNSUPPORTED</CODE> instead.

<DT><CODE>UNRESOLVED</CODE>
<DD>
<A NAME="IDX43"></A>
<A NAME="IDX44"></A>
Output from a test requires manual inspection; the test suite could not
automatically determine the outcome.  For example, your tests can report
this outcome is when a test does not complete as expected.

<DT><CODE>UNTESTED</CODE>
<DD>
<A NAME="IDX45"></A>
<A NAME="IDX46"></A>
A test case is not yet complete, and in particular cannot yet produce a
<CODE>PASS</CODE> or <CODE>FAIL</CODE>.  You can also use this outcome in dummy
"tests" that note explicitly the absence of a real test case
for a particular property.

<DT><CODE>UNSUPPORTED</CODE>
<DD>
<A NAME="IDX47"></A>
<A NAME="IDX48"></A>
<A NAME="IDX49"></A>
A test depends on a conditionally available feature that does not exist
(in the configured testing environment).  For example, you can use this
outcome to report on a test case that does not work on a particular
target because its operating system support does not include a required
subroutine.
</DL>



<H2><A NAME="SEC14" HREF="gregdoc.html#TOC14">Files and directories</A></H2>
<P>
<A NAME="IDX50"></A>
<A NAME="IDX51"></A>


<P>
A Greg test run expects to find files and directories in a certain layout
(modeled on that used by DejaGNU) - though it is possible to override this
DejaGNU compatibility feature and simply run the tests in a list of files.


<P>
The test source directory (normally your current directory) is expected to
contain one or more <EM>tool directories</EM>.  Each tool directory
should contain one or more <EM>test scripts</EM>.  In fact any file in a
tool directory which has a <TT>`.scm'</TT> extension is assumed to be
a Guile test script.


<P>
When a normal Greg test run is done, Greg goes through each tool
directory in turn and loads each test script in turn.


<P>
You may set the Guile variable <CODE>greg-tools</CODE> or use the <CODE>--tool ...</CODE>
command-line option to specify a list of tools directories to use rather than
assuming that <EM>all</EM> subdirectories are tool directories.
If you do this, the tools are tested in the order in which they appear in
the list rather than the default order (ASCII sorted by name).


<P>
You may set the Guile variable <CODE>greg-files</CODE> or use the <CODE>--file ...</CODE>
command-line option to specify a list of file names to use rather than
assuming that <EM>all</EM> <TT>`.scm'</TT> files in each tool directory are
test scripts.
If you do this, the files are loaded in the order in which they appear in
the list.
You may omit the <TT>`.scm'</TT> extension from filenames and Greg will supply
it for you if necessary.


<P>
You may set the Guile variable <CODE>greg-paths</CODE> to specify a list
of test files to be run directly, or simply list the files to be run
on the command-line.


<P>
Doing this overrides the <CODE>greg-tools</CODE> and <CODE>greg-files</CODE> variables, and
simply runs the files you list in the order you list them.


<P>
<A NAME="IDX52"></A>
<A NAME="IDX53"></A>
<A NAME="IDX54"></A>
<A NAME="IDX55"></A>


<P>
As a (minor) complication to this simple layout, Greg permits the use of
<TT>`begin.grg'</TT> and <TT>`end.grg'</TT> scripts in both the main source directory
and in each tool directory.  These scripts permit you to add any
initialisation and cleanup code you want.  Typically (for non-embedded
testing) you would use a <TT>`begin.grg'</TT> script to start the application
to be tested.


<P>
If <TT>`begin.grg'</TT> exists in the main source directory, it will be loaded
before any tools are tested.


<P>
If <TT>`end.grg'</TT> exists in the main source directory, it will be loaded
after all the tools are tested.


<P>
If <TT>`begin.grg'</TT> exists in a tool directory, it will be loaded
before any test scripts in that directory are loaded.


<P>
If <TT>`end.grg'</TT> exists in a tool directory, it will be loaded
after all the test scripts in that directory are loaded.


<P>
NB. Even when you use the <CODE>greg-paths</CODE> variable to run one or more test
files directly, the <TT>`begin.grg'</TT> and <TT>`end.grg'</TT> files in your current
directory will be loaded.




<H2><A NAME="SEC15" HREF="gregdoc.html#TOC15">Embedded usage</A></H2>
<P>
<A NAME="IDX56"></A>
<A NAME="IDX57"></A>


<P>
Greg is designed primarily for embedded usage - any application that uses
Guile as it's scripting language should be able to use Greg to test itself.


<P>
To this end - Greg provides a Guile module containing definitions of
various procedures (used to run tests) and variables (used to modify the
behavior of a test run).


<P>
Before trying to use any part of Greg, You need to load the Greg module with
<CODE>(use-modules (ice-9 greg))</CODE>


<P>
<A NAME="IDX58"></A>
The main procedure to run Greg tests is <CODE>(greg-test-run)</CODE>.
You can use this to run tests in much the same way as the <TT>`greg'</TT> script
is used to run tests from the command-line.  The behavior of this
procedure is modified by setting the following top-level variables -


<P>
<A NAME="IDX59"></A>

<UL>

<LI>greg-debug

<A NAME="IDX60"></A>
<A NAME="IDX61"></A>
The <CODE>greg-debug</CODE> variable is a boolean used to determine whether to
output extra debug information.  The debug information is written to a
<TT>`.dbg'</TT> file.  Test scripts may use the <CODE>greg-dlog</CODE> procedure to
output debug information.

<LI>greg-files

<A NAME="IDX62"></A>
<A NAME="IDX63"></A>
The <CODE>greg-files</CODE> variable is a list of strings used to specify the names
of the test scripts to be run.  If this list is empty, all the files with the
<TT>`.scm'</TT> extension in a tool subdirectory are loaded.  If the list
contains names, the named scripts are loaded in the order in which they occur
in the list rather than the default order (ASCII sorted by name).<BR>
The exact names of scripts in this list will be used to match filenames,
and if no match is found a <TT>`.scm'</TT> extension will be added automatically
by Greg and a re-match attempted.

<LI>greg-obj-dir

<A NAME="IDX64"></A>
<A NAME="IDX65"></A>
The <CODE>greg-obj-dir</CODE> variable is a string naming the directory in which
Greg expects to find binaries to be run as child processes.<BR>
By default, this is the current directory (<CODE>.</CODE>).

<LI>greg-out-dir

<A NAME="IDX66"></A>
<A NAME="IDX67"></A>
The <CODE>greg-out-dir</CODE> variable is a string naming the directory in which
Greg will generate log and debug output files.<BR>
By default, this is the current directory (<CODE>.</CODE>).

<LI>greg-paths

<A NAME="IDX68"></A>
<A NAME="IDX69"></A>
The <CODE>greg-paths</CODE> variable is a list of pathname of files to be run.
This is used where you don't want to use the normal tools hierarchy
and need to test specific files explicitly.  The filenames are used exactly
as given.  If you use this variable, you should set the <CODE>greg-tools</CODE>
variable to an empty list.

<LI>greg-posix

<A NAME="IDX70"></A>
<A NAME="IDX71"></A>
The <CODE>greg-posix</CODE> variable is a boolean used to determine whether to
produce strict posix output, or permit non-posix extensions.

<LI>greg-src-dir

<A NAME="IDX72"></A>
<A NAME="IDX73"></A>
The <CODE>greg-src-dir</CODE> variable is a string naming the directory in which
Greg will look for tool subdirectories and where it expects to find
the main initialisation and cleanup scripts
(<TT>`begin.grg'</TT> and <TT>`end.grg'</TT>) for a test run.<BR>
By default, this is the current directory (<CODE>.</CODE>).

<LI>greg-tools

<A NAME="IDX74"></A>
<A NAME="IDX75"></A>
The <CODE>greg-tools</CODE> variable is a list of strings used to specify the names
of the tools to be tested (ie the names of the subdirectories of the main
source directory).  If this list is empty, all the subdirectories of the
main source directory (normally <CODE>.</CODE>) are assumed to be valid tool
directories.  If the list contains names, the named subdirectories are used
in the order in which they occur in the list.<BR>

<LI>greg-verbose

<A NAME="IDX76"></A>
<A NAME="IDX77"></A>
The <CODE>greg-verbose</CODE> variable is a number used to determine the level of
detail produced in the log output.  At zero (the default), only minimal
information is output (unexpected testcase results and a summary of the
number of testcases passed).  At one, the result of each testcase is reported
and a more detailed summary is output.  At two, entry and exit of tool
directories and test files is reported.

</UL>



<H2><A NAME="SEC16" HREF="gregdoc.html#TOC16">Command-line usage</A></H2>

<P>
<A NAME="IDX78"></A>
<A NAME="IDX79"></A>
<TT>`greg'</TT> is the executable test driver for Greg.  This is a Guile script
that you can use to run tests from the command line.
The command-line options that you can pass to <TT>`greg'</TT> are listed below.


<P>
<A NAME="IDX80"></A>
<A NAME="IDX81"></A>
<TT>`greg'</TT> returns an exit code of <CODE>1</CODE> if any test
has an unexpected result; otherwise (if all tests pass or fail as
expected) it returns <CODE>0</CODE> as the exit code.


<P>
This is the full set of command line options that <TT>`greg'</TT>
recognizes.


<P>
<A NAME="IDX82"></A>
<A NAME="IDX83"></A>
<A NAME="IDX84"></A>
<A NAME="IDX85"></A>

<PRE>
greg --tool <VAR>tool</VAR> ...
[ --debug ]
[ --file <VAR>script</VAR> ... ]
[ --help ]
[ --objdir <VAR>path</VAR> ]
[ --outdir <VAR>path</VAR> ]
[ --posix ]
[ --srcdir <VAR>path</VAR> ]
[ -v | --verbose ]  [ -V | --version ]
[ files to run ]
</PRE>

<DL COMPACT>

<DT><CODE>--tool <VAR>tool</VAR> ...</CODE>
<DD>
<A NAME="IDX86"></A>
<A NAME="IDX87"></A>
<VAR>tool</VAR> specifies what set of tests to run.  It provides a list of
subdirectories (each corresponding to a tool) in which test scripts
can be found.
Initialisation code (including executable tool startup) for each tool may
be placed in <TT>`begin.grg'</TT> in the appropriate tool subdirectory.
Cleanup code may be placed in <TT>`end.grg'</TT>.

For example, including <CODE>--tool gcc</CODE> on the <TT>`greg'</TT> command
line runs tests from the <CODE>gcc</CODE> subdirectory.

The order in which the tools are tested will be the same as the order in
which the tool names occur on the command line.

<DT><CODE>--file <VAR>script</VAR> ...</CODE>
<DD>
<A NAME="IDX88"></A>
<A NAME="IDX89"></A>
<A NAME="IDX90"></A>
Specify the names of testsuites to run.
By default, <TT>`greg'</TT> runs all tests for the tool, but you can
restrict it to particular testsuites by giving the names of the <TT>`.scm'</TT>
Guile scripts that control them.  You do not need to supply the
<TT>`.scm'</TT> file extension - it will be assumed.

<VAR>testsuite</VAR> may not include path information; use plain filenames.

The order in which the test scripts are run will be the same as the order in
which the script names occur on the command line.

<DT><CODE>--debug</CODE>
<DD>
<A NAME="IDX91"></A>
<A NAME="IDX92"></A>
<A NAME="IDX93"></A>
<A NAME="IDX94"></A>
Turns on the <CODE>expect</CODE> internal debugging output.  Debugging output
is displayed as part of the <TT>`greg'</TT> output, and logged to a file
called <TT>`tests.dbg'</TT>.  The extra debugging output does <EM>not</EM>
normally appear on standard output.

<DT><CODE>--help</CODE>
<DD>
<A NAME="IDX95"></A>
<A NAME="IDX96"></A>
<A NAME="IDX97"></A>
Prints out a short summary of the <TT>`greg'</TT> options, then exits
(even if you also specify other options).

<DT><CODE>--objdir <VAR>path</VAR></CODE>
<DD>
<A NAME="IDX98"></A>
<A NAME="IDX99"></A>
<A NAME="IDX100"></A>
<A NAME="IDX101"></A>
Use <VAR>path</VAR> as the top directory containing any auxiliary compiled
test code. This defaults to <TT>`.'</TT>.  Use this option to locate
pre-compiled test code.  You can normally prepare any auxiliary files
needed with <CODE>make</CODE>.

<DT><CODE>--outdir <VAR>path</VAR></CODE>
<DD>
<A NAME="IDX102"></A>
<A NAME="IDX103"></A>
<A NAME="IDX104"></A>
Write output logs in directory <VAR>path</VAR>.  The default is <CODE>.</CODE>, the
directory where you start <TT>`greg'</TT>.  This option affects only the
log and the debug files <TT>`<VAR>tool</VAR>.log'</TT> and
<TT>`<VAR>tool</VAR>.dbg'</TT>.

<DT><CODE>--srcdir <VAR>path</VAR></CODE>
<DD>
<A NAME="IDX105"></A>
<A NAME="IDX106"></A>
Use <VAR>path</VAR> as the top directory for test scripts to run.
<TT>`greg'</TT> looks in this directory for any subdirectory whose name
matches any toolname (specified with <CODE>--tool</CODE>).

<DT><CODE>--verbose</CODE>
<DD>
<DT><CODE>-v</CODE>
<DD>
<A NAME="IDX107"></A>
<A NAME="IDX108"></A>
<A NAME="IDX109"></A>
<A NAME="IDX110"></A>
By default, <TT>`greg'</TT> shows only the output of tests that produce unexpected
results; that is, tests with status <CODE>FAIL</CODE> (unexpected failure),
<CODE>UPASS</CODE> (unexpected success), or <CODE>ERROR</CODE> (a severe error in the test
case itself).
Specifying <CODE>--verbose</CODE> to see output for tests with status <CODE>PASS</CODE>
(success, as expected) and <CODE>XFAIL</CODE> (failure, as expected). It also
causes a more detailed summary to be displayed.<BR>
Specifying <CODE>--verbose</CODE> more than once causes more detail to be displayed.

<DT><CODE>--version</CODE>
<DD>
<DT><CODE>-V</CODE>
<DD>
<A NAME="IDX111"></A>
<A NAME="IDX112"></A>
<A NAME="IDX113"></A>
Prints out the version numbers of Greg, and Guile, then
exits without running any tests.

</DL>



<H1><A NAME="SEC17" HREF="gregdoc.html#TOC17">Writing tests</A></H1>
<P>
<A NAME="IDX114"></A>
<A NAME="IDX115"></A>




<H3><A NAME="SEC18" HREF="gregdoc.html#TOC18">getting started</A></H3>
<P>
<A NAME="IDX116"></A>


<P>
The simplest way to get started is to write a file (say <SAMP>`myTests'</SAMP>) and
type <CODE>greg --verbose myTests</CODE> to run the tests in it.


<P>
Your file might contain code like -



<PRE>
; A simple test that basic arithmetic works

(greg-expect-pass "one plus one is two"
  (eq? (+ 1 1) 2)
)

(greg-expect-pass "one minus one is zero"
  (eq? (- 1 1) 0)
)
</PRE>

<P>
And would produce output like -

<PRE>
PASS: one plus one is two
PASS: one minus one is zero

# of testcases attempted   2
# of expected passes       2
# of expected failures     0
# of unexpected passes     0
# of unexpected failures   0
# of unresolved testcases  0
# of unsupported testcases 0
# of untested testcases    0
</PRE>



<H3><A NAME="SEC19" HREF="gregdoc.html#TOC19">types of testsuite</A></H3>

<P>
There are three types of situation where Greg may be used as a test
framework -



<UL>

<LI>

Embedded testing <BR>

In this case, you have an application that uses Guile as it's scripting
language - so you have provided an interface between the internals of
your program and the Guile interpreter.

Your testcases can use that interface to test your program directly, and
you run the tests by loading the Greg framework and then doing
<CODE>(greg-test-run)</CODE>

A testsuite for <EM>embedded</EM> use does not normally need <TT>`begin.grg'</TT>
or <TT>`end.grg'</TT> since the application to be tested will be running the
tests on itself - so it doesn't need to control child processes.

<LI>

Library testing <BR>

When you want to test a library, you need to write a tiny program to
start up the Guile command-line interpreter with the library to be tested
inked in to the program via a via a set of stubs.  The resulting program
can then be used to run tests on the directly, just like normal embedded
testing.

There is a tool called G-Wrap (by Chris Lee), which will
generate stubs to import your library functions into Guile.  The home
page of this tool is at <A HREF="http://www.cs.cmu.edu/~chrislee/g-wrap/">http://www.cs.cmu.edu/~chrislee/g-wrap/</A>

For testing Objective-C libraries, you should use the GNUstep-Guile
interface library (documented online at
<A HREF="http://www.tiptree.demon.co.uk/gstep/guile/gstep_guile_toc.html">http://www.tiptree.demon.co.uk/gstep/guile/gstep_guile_toc.html</A>) which
provides a fairly complete interface between the Guile and Objective-C
languages (using the GNU objective-C runtime).

You can get hold of this as part of the GNUstep core package (from any GNU
ftp site) or, for the bleeding edge - by anonymous cvs as the
GNUstep-Guile package in the GNUstep project -


<PRE>
CVSROOT=":pserver:anoncvs@cvs.net-community.com:/gnustep"<BR>
export CVSROOT<BR>
cvs login (password is `anoncvs')<BR>
cvs -z3 checkout guile<BR>
</PRE>

<LI>

External testing<BR>

When you want to test an external program, you use Greg in much
the same way that you would use DejaGNU.  That is - you run the
program to be tested as a separate child process and your test cases
consist of Guile code to send commands to the child process and wait
for responses from it.

The child process is normally started by a <TT>`begin.grg'</TT> script
using the <CODE>(greg-child)</CODE> procedure, though it is of course possible
to start and stop child processes in each test script.

</UL>



<H3><A NAME="SEC20" HREF="gregdoc.html#TOC20">testsuite file layout</A></H3>

<P>
A <EM>testsuite</EM> for a tool is a directory containing one or more
test script files and (optionally) <TT>`begin.grg'</TT> and <TT>`end.grg'</TT>
files to handle initialisation and cleanup.


<P>
Each script file has a <TT>`.scm'</TT> extension and contains Guile (Scheme)
code, but you do not need to know much about the Guile programming
language to write most tests.


<P>
A script file will contain one or more testcases - each of which
constitutes a test of a single well defined feature of the tool
that the script is meant to test.  A testcase is always written
using the <CODE>greg-testcase</CODE> procedure, though this procedure could
be invoked by a convenience macro.




<H3><A NAME="SEC21" HREF="gregdoc.html#TOC21">greg-expect-pass</A></H3>
<P>
<A NAME="IDX117"></A>


<P>
The <CODE>greg-expect-pass</CODE> macro is a shorthand method of writing
the most usual sort of testcase - where a fragment of Guile code is
run and is expected to return a <CODE>true</CODE> result.
It passes an assertion and a fragment of Guile
code that performs a test to the <CODE>greg-testcase</CODE> procedure -

<PRE>
; A simple test that basic arithmetic works

(greg-expect-pass "one plus one is two" (eq? (+ 1 1) 2))

is equivalent to -

(greg-testcase "one plus one is two" #t
  (lambda ()
    (eq? (+ 1 1) 2)
  )
)
</PRE>



<H3><A NAME="SEC22" HREF="gregdoc.html#TOC22">greg-expect-fail</A></H3>
<P>
<A NAME="IDX118"></A>


<P>
The <CODE>greg-expect-fail</CODE> macro is a shorthand method of writing a testcase
to confirm that a known bug is still present in the code being tested.  Once
the bug is fixed, it would be altered to be a <CODE>greg-expect-pass</CODE> testcase.

<PRE>
; A test that basic arithmetic DOESN'T work!

(greg-expect-fail "one plus one is two" (eq? (+ 1 1) 2))

is equivalent to -

(greg-testcase "one plus one is two" #f
  (lambda ()
    (eq? (+ 1 1) 2)
  )
)
</PRE>



<H3><A NAME="SEC23" HREF="gregdoc.html#TOC23">greg-testcase</A></H3>
<P>
<A NAME="IDX119"></A>


<P>
The <CODE>greg-testcase</CODE> procedure takes three arguments -



<UL>
<LI>The assertion<BR>

This is a string describing the test to be performed.  It should take the
form of an assertion that is expected to hold true.

<LI>The expected outcome<BR>

This is a boolean value - <CODE>#t</CODE> if the test is expected to return
<CODE>#t</CODE> (ie. the assertion is expected to be proved correct), and
<CODE>#f</CODE> if the test is expected to return <CODE>#f</CODE> (ie. the assertion
is expected to be proved to be incorrect).

<LI>The test itself<BR>

This is a <EM>thunk</EM> (a Guile procedure that takes no arguments) and is
normally a <EM>lambda expression</EM>.  The return value of this procedure
should be <CODE>#t</CODE> if the assertion is proved correct, <CODE>#f</CODE> if it
is proved incorrect.
</UL>

<P>
The Guile programming language permits the thunk to return in four
ways -



<UL>
<LI>Return the boolean value - <CODE>#t</CODE><BR>

In which case, the test has succeeded, the assertion has proved correct,
and Greg will record either an expected success (PASS) or an unexpected
success (UPASS) depending on the expected outcome passed to
<CODE>greg-testcase</CODE>.

<LI>Return the boolean value - <CODE>#f</CODE><BR>

In which case, the test has failed, the assertion has proved incorrect,
and Greg will record either an expected failure (XFAIL) or an unexpected
failure (FAIL) depending on the expected outcome passed to
<CODE>greg-testcase</CODE>.

<LI>Return a non-boolean value<BR>

In which case, the test is unresolved (UNRESOLVED).

<LI>Throw an exception<BR>

In which case Greg's behavior depends on the exception thrown -

<UL>
<LI>'pass<BR>

Greg acts as if the test had returned the boolean <CODE>#t</CODE>
<LI>'fail<BR>

Greg acts as if the test had returned the boolean <CODE>#f</CODE>
<LI>'unsupported<BR>

Greg reports this case as unsupported (UNSUPPORTED)
<LI>'untested<BR>

Greg reports this case as untested (UNTESTED)
<LI>(quit)<BR>

If the script calls the <CODE>(quit)</CODE> primitive - an exception is raised.
In this special case, the test is reported as unresolved (UNRESOLVED) and
no further tests are executed.  The testrun is terminated.
<LI>any other exception<BR>

Greg reports this case as unresolved (UNRESOLVED)
</UL>

</UL>

<P>
As there are no other ways in which the thunk may be exited, it is
impossible for a testcase to produce a result that doesn't fit into the
framework (unless your testcase manages either to crash Guile or enter an
infinite loop - in which case you won't get <EM>any</EM> output).


<P>
The value returned by the <CODE>greg-testcase</CODE> procedure is a boolean -
<CODE>#t</CODE> if the test resulted in an expected pass, <CODE>#f</CODE> otherwise.<BR>
You can use this return value to make the execution of subsequent testcases 
dependent on the success of an earlier testcase.



<PRE>

;
; A testcase to check an instance of numeric addition
;
(greg-testcase "One plus One is two" #t
(lambda ()
  (eq? (+ 1 1 ) 2)
))

;
;  The above testcase will generate output -
;  `PASS: One plus One is two'
;
</PRE>

<P>
The system provides hooks for general purpose procedures that are
automatically called immediately before and after each testcase is
executed.  These procedures can be used to perform additional
logging or other housekeeping functions. -

<UL>
<LI>greg-case-begin

<A NAME="IDX120"></A>
The <CODE>greg-case-begin</CODE> variable is a hook for a procedure to be
executed immediately before each testcase.  It is initially defined
to be  <CODE>(lambda () ())</CODE> which does nothing except return an
unused empty list.  You can replace this with a procedure of your choice,
and use it to do any pre-test logging etc.  When this procedure is called,
<CODE>greg-case-name</CODE> will contain the name of the current testcase.

<LI>greg-case-end

<A NAME="IDX121"></A>
The <CODE>greg-case-end</CODE> variable is a hook for a procedure to be
executed immediately before each testcase.  It is initially defined
to be  <CODE>(lambda (result) ())</CODE> which does nothing except return an
unused empty list.  You can replace this with a procedure of your choice.
When this procedure is called, <CODE>greg-case-name</CODE> will contain the
name of the current testcase.
</UL>

<P>
While a testcase is executing (or in the <CODE>greg-case-begin</CODE> or
<CODE>greg-case-end</CODE> procedures) there are a number of public procedures
that may be used to obtain information about the system -



<UL>
<LI>greg-casename

<A NAME="IDX122"></A>
This procedure returns the name of the current testcase.  It is valid during
execution of the testcase and during the pre and post test procedures.

<LI>greg-directory

<A NAME="IDX123"></A>
The <CODE>greg-directory</CODE> procedure takes no arguments and simply returns
a string containing the absolute path name of the directory in which the
current testscript is located.  This value can be used where a testscript
wishes to load data from local files in order to support a test.
The string returned by this method includes a trailing slash character,
so to refer to a file located in the same directory as the testscript
simply by appending the fielname.
eg <CODE>(string-append (greg-directory) "foo")</CODE>

<LI>greg-filename

<A NAME="IDX124"></A>
This procedure returns the name of the current test file.  It is valid during
execution of the testcase and during the pre and post test procedures.

<LI>greg-toolname

<A NAME="IDX125"></A>
This procedure returns the name of the current test tool.  It is valid during
execution of the testcase and during the pre and post test procedures.

</UL>



<H3><A NAME="SEC24" HREF="gregdoc.html#TOC24">Multiple testcases</A></H3>
<P>
<A NAME="IDX126"></A>


<P>
It is normal to have more than one testcase in a file and this
produces no problems - the only thing to watch out for is communicating
information between testcases -


<P>
The scope of variables defined in the thunk in a <CODE>greg-testcase</CODE>
procedure call is that thunk - the variable will <EM>not</EM> be
visible to the next testcase.


<P>
So - to pass information from one testcase to the next it is necessary to
define variables that can be seen in each testcase.  The way to do this
is normally to define these variables at the start of the file and then
use the <CODE>set!</CODE> procedure within each testcase to set a value for a
variable to be passed to the next testcase.



<PRE>

(define arith-ok #f)

;
; A testcase to check an instance of numeric addition
;
(greg-testcase "One plus One is two" #t
(lambda ()
  (if (eq? (+ 1 1 ) 2)
    (begin (set! arith-ok #t) #t)
    #f)
))

;
; A testcase to check arithmetic - only supported if we have addition.
;
(greg-testcase "X multiplied by 2 is X plus X" #t
(lambda ()
  (if arith-ok
    (eq? (+ 1 1) (* 1 2))
    (throw 'unsupported))
))

</PRE>

<P>
Of course, if (as above) the only information you want to pass from a testcase
is whether the test succeeded or not, you can use the return value from the
<CODE>greg-testcase</CODE> procedure directly -



<PRE>

(if
  (greg-testcase "One plus One is two" #t
    (lambda ()
      (eq? (+ 1 1 ) 2)
    )
  )
  (greg-testcase "X multiplied by 2 is X plus X" #t
    (lambda ()
      (eq? (+ 1 1) (* 1 2))
    )
  )
  (greg-dlog "Arithmetic operations not supported\n")
)

</PRE>



<H3><A NAME="SEC25" HREF="gregdoc.html#TOC25">External tests</A></H3>
<P>
<A NAME="IDX127"></A>


<P>
When Greg is used to test an external application, you usually want to run
that application as a child process on a pseudo-terminal and handle tests
sending a sequence of commands to the application and reading anticipated
output from the application.




<H4><A NAME="SEC26" HREF="gregdoc.html#TOC26">Starting a child process</A></H4>
<P>
<A NAME="IDX128"></A>
<A NAME="IDX129"></A>


<P>
Greg provides the <CODE>greg-child</CODE> procedure to start up a child process
on a pseudo-terminal.  You would usually call this procedure in the
<TT>`begin.grg'</TT> file in your tool directory, but you could call it
at the start of each script to get a new child process for each script.


<P>
The <CODE>greg-child</CODE> procedure expects one argument (the name of
the program to be executed) followed by any number of additional
arguments which are the arguments to be passed to the child process.<BR>
If the program name does not begin with a slash, Greg will look in the
directory specified in <CODE>greg-obj-dir</CODE> to find it (by default the
current directory).<BR>
If you want your normal PATH to be searched for the program, you should
use -<BR>
<CODE>(greg-child "/bin/sh" "-c" "foo args")</CODE><BR>
to get the shell to execute program <TT>`foo'</TT> with arguments <CODE>args</CODE>.


<P>
The <CODE>greg-child</CODE> procedure will automatically close down the I/O
channels to any process previously started and wait for that process to
die.  If the old child process is badly behaved and will not die, this
can result in Greg hanging - in this case you may need to explicitly
kill the old child by another method before starting the new child
process (this is one of the uses of the <TT>`end.grg'</TT> script).


<P>
As a special case, you can use an empty string as the program name -
if you do this, another copy of the guile process will be created as
a child and the value returned by <CODE>greg-child</CODE> in the child process
will be a list containing the single number 0 (in the parent it will be
a list containing the input port, output port and process id of the child).
You can use this information to get the child copy of the process to 
be the program under test.  This is useful for embedded testing where you
want to test the I/O capabilities of the program.


<P>
NB. The <CODE>greg-child</CODE> procedure is implemented on top of the new
primitive <CODE>pty-child</CODE>.  This primitive is used to create a new child
process on the end of a pseudo-terminal.  Arguments and return values are
as for <CODE>greg-child</CODE>.



<UL>
<LI>

When successfully starting a new program a three item list is returned in the
parent - input port to read from the child, output port to write to the child,
process id of child.
<LI>

When returning in a child process because the program name was an empty string
a list of one item (zero) is returned.
<LI>

After a failure to create a child process, an empty list is returned.
</UL>



<H4><A NAME="SEC27" HREF="gregdoc.html#TOC27">Sending to a child process</A></H4>
<P>
<A NAME="IDX130"></A>
<A NAME="IDX131"></A>


<P>
The <CODE>greg-send</CODE> procedure is provided to send instructions to a
child process.  This procedure takes one or more string arguments and
sends them to the child process (if one exists).




<H4><A NAME="SEC28" HREF="gregdoc.html#TOC28">Reading from a child process</A></H4>
<P>
<A NAME="IDX132"></A>
<A NAME="IDX133"></A>


<P>
The <CODE>greg-recv</CODE> macro is used to read data from a child process.
This procedure actually provides a simple front-end to the <CODE>expect</CODE>
module.  You can use the <CODE>expect</CODE> module facilities directly if you
want more control than is offered by <CODE>greg-recv</CODE>.


<P>
The <CODE>greg-recv</CODE> macro expects one or more lists as arguments -
each list containing a string (a pattern to match)
and a result to return on a successful match.  The value returned by
<CODE>greg-recv</CODE> is the result for the pattern actually matched.<BR>
If no pattern is matched within the timeout period then an exception
is raised, causing the testcase to return a FAIL result
(unless you use <CODE>(set! expect-timeout-proc xxx)</CODE> to
override Gregs timeout handler.<BR>
If no pattern is matched before an end-of-file is read, then an exception
is raised, causing the testcase to return a FAIL result
(unless you use <CODE>(set! expect-eof-proc xxx)</CODE> to
override Gregs end-of-file handler.<BR>


<P>
NB. The <CODE>expect-timeout-proc</CODE> and <CODE>expect-eof-proc</CODE> are saved
when a tool is tarted, and restored when it ends ... so if you want to
make changes to these procedures in multiple tools, you must do so in the
<CODE>begin.grg</CODE> and <CODE>end.grg</CODE> files for each tool.


<P>
In addition to setting up the above expect procedures, Greg also sets
the <CODE>expect-timeout</CODE> variable to a 15 second timeout, and sets the
<CODE>expect-char-proc</CODE> to be <CODE>greg-dlog</CODE> so that data read from
the child process is logged as debug output by default.  You can of
course override this behavior in <CODE>begin.grg</CODE>.


<P>
The pattern matching is done with extended regular expressions,
usually with input split into lines so that a carat (^) at the start of an
expression matches the start of a line, and a dollar ($) matches the end
of a line.<BR>
This is convenient for testing programs that produce lines of output in
an expected format, as you can easily match the start and end of an
output line.


<P>
If you want to change this behavior to permit multi-line patterns and to
have the carat and dollar match the start of input and end of input
respectively, then you can use -

<PRE>
(set! expect-strings-compile-flags regexp/extended)
(set! expect-strings-exec-flags 0)
</PRE>

<P>
This pattern matching behavior is occasionally useful when you are
testing a program that produces output without clearly recognisable
individual lines.
NB. greg does not save and restore these values, so a change to them
effect all tools being tested until you change them back.




<H4><A NAME="SEC29" HREF="gregdoc.html#TOC29">A complete external test</A></H4>
<P>
<A NAME="IDX134"></A>

<PRE>
;
; Run an interactive shell as a child process
;
(greg-child "/bin/sh" "-i")

;
; Set the shell prompt
;
(greg-send "PS1='% '\n")   

;
; Now test that the shell echoes what we expect.
; If we have a timeout or an eof, we will get a failure result.
;
(greg-testcase "echo 'hello'" #t
  (lambda ()
    (greg-send "echo hello\n")  ; Get it to send us something
    (expect-strings
      ("hello\r\n% " #t)
    )
  )
)
</PRE>



<H1><A NAME="SEC30" HREF="gregdoc.html#TOC30">Index</A></H1>

<P>
Jump to:
<A HREF="#cindex_-">-</A>
-
<A HREF="#cindex_a">a</A>
-
<A HREF="#cindex_b">b</A>
-
<A HREF="#cindex_c">c</A>
-
<A HREF="#cindex_d">d</A>
-
<A HREF="#cindex_e">e</A>
-
<A HREF="#cindex_f">f</A>
-
<A HREF="#cindex_g">g</A>
-
<A HREF="#cindex_h">h</A>
-
<A HREF="#cindex_i">i</A>
-
<A HREF="#cindex_l">l</A>
-
<A HREF="#cindex_m">m</A>
-
<A HREF="#cindex_n">n</A>
-
<A HREF="#cindex_o">o</A>
-
<A HREF="#cindex_p">p</A>
-
<A HREF="#cindex_r">r</A>
-
<A HREF="#cindex_s">s</A>
-
<A HREF="#cindex_t">t</A>
-
<A HREF="#cindex_u">u</A>
-
<A HREF="#cindex_v">v</A>
-
<A HREF="#cindex_w">w</A>
-
<A HREF="#cindex_x">x</A>
<P>
<H2><A NAME="cindex_-">-</A></H2>
<DIR>
<LI><A HREF="gregdoc.html#IDX91"><CODE>--debug</CODE> (<TT>`greg'</TT> option)</A>
<LI><A HREF="gregdoc.html#IDX95"><CODE>--help</CODE> (<TT>`greg'</TT> option)</A>
<LI><A HREF="gregdoc.html#IDX98"><CODE>--objdir</CODE> (<TT>`greg'</TT> option)</A>
<LI><A HREF="gregdoc.html#IDX103"><CODE>--outdir</CODE> (<TT>`greg'</TT> option)</A>
<LI><A HREF="gregdoc.html#IDX106"><CODE>--srcdir</CODE> (<TT>`greg'</TT> option)</A>
<LI><A HREF="gregdoc.html#IDX87"><CODE>--tool</CODE> (<TT>`greg'</TT> option)</A>
<LI><A HREF="gregdoc.html#IDX107"><CODE>--verbose</CODE> (<TT>`greg'</TT> option)</A>
<LI><A HREF="gregdoc.html#IDX112"><CODE>--version</CODE> (<TT>`greg'</TT> option)</A>
<LI><A HREF="gregdoc.html#IDX108"><CODE>-v</CODE> (<TT>`greg'</TT> option)</A>
<LI><A HREF="gregdoc.html#IDX111"><CODE>-V</CODE> (<TT>`greg'</TT> option)</A>
</DIR>
<H2><A NAME="cindex_a">a</A></H2>
<DIR>
<LI><A HREF="gregdoc.html#IDX134">a complete external test</A>
<LI><A HREF="gregdoc.html#IDX21">ambiguity, required for POSIX</A>
<LI><A HREF="gregdoc.html#IDX101">auxiliary test programs</A>
</DIR>
<H2><A NAME="cindex_b">b</A></H2>
<DIR>
<LI><A HREF="gregdoc.html#IDX52">begin.grg</A>
<LI><A HREF="gregdoc.html#IDX26">building Greg</A>
</DIR>
<H2><A NAME="cindex_c">c</A></H2>
<DIR>
<LI><A HREF="gregdoc.html#IDX7"><CODE>check</CODE> makefile target</A>
<LI><A HREF="gregdoc.html#IDX54">cleanup</A>
<LI><A HREF="gregdoc.html#IDX82">command line options</A>
</DIR>
<H2><A NAME="cindex_d">d</A></H2>
<DIR>
<LI><A HREF="gregdoc.html#IDX92">debug log for test cases</A>
<LI><A HREF="gregdoc.html#IDX61">debug variable</A>
<LI><A HREF="gregdoc.html#IDX9">design goals</A>
<LI><A HREF="gregdoc.html#IDX51">directories and files</A>
</DIR>
<H2><A NAME="cindex_e">e</A></H2>
<DIR>
<LI><A HREF="gregdoc.html#IDX56">embedded usage</A>
<LI><A HREF="gregdoc.html#IDX53">end.grg</A>
<LI><A HREF="gregdoc.html#IDX8">example</A>
<LI><A HREF="gregdoc.html#IDX3">existing tests, running</A>
<LI><A HREF="gregdoc.html#IDX80">exit code from <TT>`greg'</TT></A>
<LI><A HREF="gregdoc.html#IDX41">expected failure</A>
<LI><A HREF="gregdoc.html#IDX127">external tests</A>
</DIR>
<H2><A NAME="cindex_f">f</A></H2>
<DIR>
<LI><A HREF="gregdoc.html#IDX16">FAIL</A>, <A HREF="gregdoc.html#IDX37">FAIL</A>
<LI><A HREF="gregdoc.html#IDX42">failing test, expected</A>
<LI><A HREF="gregdoc.html#IDX38">failing test, unexpected</A>
<LI><A HREF="gregdoc.html#IDX17">failure, POSIX definition</A>
<LI><A HREF="gregdoc.html#IDX50">files and directories</A>
<LI><A HREF="gregdoc.html#IDX63">files variable</A>
</DIR>
<H2><A NAME="cindex_g">g</A></H2>
<DIR>
<LI><A HREF="gregdoc.html#IDX116">getting started writing a test</A>
<LI><A HREF="gregdoc.html#IDX78"><TT>`greg'</TT> description</A>
<LI><A HREF="gregdoc.html#IDX81"><TT>`greg'</TT> exit code</A>
<LI><A HREF="gregdoc.html#IDX84"><TT>`greg'</TT> option list</A>
<LI><A HREF="gregdoc.html#IDX79">Greg test driver</A>
<LI><A HREF="gregdoc.html#IDX97"><TT>`greg'</TT>, listing options</A>
<LI><A HREF="gregdoc.html#IDX120">greg-case-begin</A>
<LI><A HREF="gregdoc.html#IDX121">greg-case-end</A>
<LI><A HREF="gregdoc.html#IDX122">greg-casename</A>
<LI><A HREF="gregdoc.html#IDX129">greg-child</A>
<LI><A HREF="gregdoc.html#IDX60">greg-debug</A>
<LI><A HREF="gregdoc.html#IDX123">greg-directory</A>
<LI><A HREF="gregdoc.html#IDX118">greg-expect-fail</A>
<LI><A HREF="gregdoc.html#IDX117">greg-expect-pass</A>
<LI><A HREF="gregdoc.html#IDX124">greg-filename</A>
<LI><A HREF="gregdoc.html#IDX62">greg-files</A>
<LI><A HREF="gregdoc.html#IDX64">greg-obj-dir</A>
<LI><A HREF="gregdoc.html#IDX66">greg-out-dir</A>
<LI><A HREF="gregdoc.html#IDX68">greg-paths</A>
<LI><A HREF="gregdoc.html#IDX70">greg-posix</A>
<LI><A HREF="gregdoc.html#IDX133">greg-recv</A>
<LI><A HREF="gregdoc.html#IDX131">greg-send</A>
<LI><A HREF="gregdoc.html#IDX72">greg-src-dir</A>
<LI><A HREF="gregdoc.html#IDX119">greg-testcase</A>
<LI><A HREF="gregdoc.html#IDX125">greg-toolname</A>
<LI><A HREF="gregdoc.html#IDX74">greg-tools</A>
<LI><A HREF="gregdoc.html#IDX76">greg-verbose</A>
</DIR>
<H2><A NAME="cindex_h">h</A></H2>
<DIR>
<LI><A HREF="gregdoc.html#IDX96">help with <TT>`greg'</TT></A>
</DIR>
<H2><A NAME="cindex_i">i</A></H2>
<DIR>
<LI><A HREF="gregdoc.html#IDX55">initialisation</A>
<LI><A HREF="gregdoc.html#IDX24">installing</A>
<LI><A HREF="gregdoc.html#IDX29">invoking</A>
</DIR>
<H2><A NAME="cindex_l">l</A></H2>
<DIR>
<LI><A HREF="gregdoc.html#IDX104">log files, where to write</A>
</DIR>
<H2><A NAME="cindex_m">m</A></H2>
<DIR>
<LI><A HREF="gregdoc.html#IDX6">make check</A>
<LI><A HREF="gregdoc.html#IDX57">module usage</A>
<LI><A HREF="gregdoc.html#IDX126">multiple testcases</A>
</DIR>
<H2><A NAME="cindex_n">n</A></H2>
<DIR>
<LI><A HREF="gregdoc.html#IDX90">naming tests to run</A>
<LI><A HREF="gregdoc.html#IDX1">News</A>
</DIR>
<H2><A NAME="cindex_o">o</A></H2>
<DIR>
<LI><A HREF="gregdoc.html#IDX65">obj-dir variable</A>
<LI><A HREF="gregdoc.html#IDX99">object directory</A>
<LI><A HREF="gregdoc.html#IDX85">option list, <TT>`greg'</TT></A>
<LI><A HREF="gregdoc.html#IDX83">options</A>
<LI><A HREF="gregdoc.html#IDX67">out-dir variable</A>
<LI><A HREF="gregdoc.html#IDX102">output directory</A>
<LI><A HREF="gregdoc.html#IDX110">output, additional</A>
<LI><A HREF="gregdoc.html#IDX2">overview</A>
</DIR>
<H2><A NAME="cindex_p">p</A></H2>
<DIR>
<LI><A HREF="gregdoc.html#IDX13">PASS</A>, <A HREF="gregdoc.html#IDX31">PASS</A>
<LI><A HREF="gregdoc.html#IDX69">paths variable</A>
<LI><A HREF="gregdoc.html#IDX10">POSIX conformance</A>
<LI><A HREF="gregdoc.html#IDX71">posix variable</A>
<LI><A HREF="gregdoc.html#IDX27">problems</A>
</DIR>
<H2><A NAME="cindex_r">r</A></H2>
<DIR>
<LI><A HREF="gregdoc.html#IDX132">reading from a child process</A>
<LI><A HREF="gregdoc.html#IDX25">requirements</A>
<LI><A HREF="gregdoc.html#IDX58">run test procedure</A>
<LI><A HREF="gregdoc.html#IDX30">running</A>
<LI><A HREF="gregdoc.html#IDX4">running tests</A>
</DIR>
<H2><A NAME="cindex_s">s</A></H2>
<DIR>
<LI><A HREF="gregdoc.html#IDX88">selecting a range of tests</A>
<LI><A HREF="gregdoc.html#IDX86">selecting tests for a tool</A>
<LI><A HREF="gregdoc.html#IDX130">sending to a child process</A>
<LI><A HREF="gregdoc.html#IDX105">source directory</A>
<LI><A HREF="gregdoc.html#IDX73">src-dir variable</A>
<LI><A HREF="gregdoc.html#IDX11">standard conformance: POSIX 1003.3</A>
<LI><A HREF="gregdoc.html#IDX128">starting a child process</A>
<LI><A HREF="gregdoc.html#IDX12">success, POSIX definition</A>
<LI><A HREF="gregdoc.html#IDX32">successful test</A>
<LI><A HREF="gregdoc.html#IDX35">successful test, unexpected</A>
</DIR>
<H2><A NAME="cindex_t">t</A></H2>
<DIR>
<LI><A HREF="gregdoc.html#IDX93">test cases, debug log</A>
<LI><A HREF="gregdoc.html#IDX100">test programs, auxiliary</A>
<LI><A HREF="gregdoc.html#IDX39">test, failing</A>
<LI><A HREF="gregdoc.html#IDX33">test, successful</A>
<LI><A HREF="gregdoc.html#IDX44">test, unresolved outcome</A>
<LI><A HREF="gregdoc.html#IDX49">test, unsupported</A>
<LI><A HREF="gregdoc.html#IDX115">testcase</A>
<LI><A HREF="gregdoc.html#IDX5">tests, running</A>
<LI><A HREF="gregdoc.html#IDX89">tests, running specifically</A>
<LI><A HREF="gregdoc.html#IDX94"><TT>`tests.dbg'</TT> file</A>
<LI><A HREF="gregdoc.html#IDX75">tools variable</A>
<LI><A HREF="gregdoc.html#IDX28">troubleshooting</A>
<LI><A HREF="gregdoc.html#IDX109">turning on output</A>
</DIR>
<H2><A NAME="cindex_u">u</A></H2>
<DIR>
<LI><A HREF="gregdoc.html#IDX36">unexpected success</A>
<LI><A HREF="gregdoc.html#IDX20">UNRESOLVED</A>, <A HREF="gregdoc.html#IDX43">UNRESOLVED</A>
<LI><A HREF="gregdoc.html#IDX23">UNSUPPORTED</A>, <A HREF="gregdoc.html#IDX47">UNSUPPORTED</A>
<LI><A HREF="gregdoc.html#IDX48">unsupported test</A>
<LI><A HREF="gregdoc.html#IDX22">UNTESTED</A>, <A HREF="gregdoc.html#IDX45">UNTESTED</A>
<LI><A HREF="gregdoc.html#IDX46">untested properties</A>
<LI><A HREF="gregdoc.html#IDX15">UPASS</A>, <A HREF="gregdoc.html#IDX34">UPASS</A>
<LI><A HREF="gregdoc.html#IDX14">UPASS, avoiding for POSIX</A>
</DIR>
<H2><A NAME="cindex_v">v</A></H2>
<DIR>
<LI><A HREF="gregdoc.html#IDX59">variables</A>
<LI><A HREF="gregdoc.html#IDX77">verbose variable</A>
<LI><A HREF="gregdoc.html#IDX113">version numbers</A>
</DIR>
<H2><A NAME="cindex_w">w</A></H2>
<DIR>
<LI><A HREF="gregdoc.html#IDX114">writing tests</A>
</DIR>
<H2><A NAME="cindex_x">x</A></H2>
<DIR>
<LI><A HREF="gregdoc.html#IDX19">XFAIL</A>, <A HREF="gregdoc.html#IDX40">XFAIL</A>
<LI><A HREF="gregdoc.html#IDX18">XFAIL, avoiding for POSIX</A>
</DIR>



<P>
Return to <A HREF="/home.html">GNU's home page</A>.
<P>

Please send FSF &amp; GNU inquiries &amp; questions to 

<A HREF="mailto:gnu@gnu.org"><EM>gnu@gnu.org</EM></A>.
There are also <A HREF="/home.html#ContactInfo">other ways to
contact</A> the FSF.
<P>

Please send comments on these web pages to

<A HREF="mailto:webmasters@gnu.org"><EM>webmasters@gnu.org</EM></A>,
send other questions to
<A HREF="mailto:gnu@gnu.org"><EM>gnu@gnu.org</EM></A>.
<P>
Copyright (C) 2000 Free Software Foundation, Inc.
<P>
Verbatim copying and distribution of this entire article is
permitted in any medium, provided this notice is preserved.


<P><HR><P>
This document was generated on 12 February 2001 using
<A HREF="http://wwwinfo.cern.ch/dis/texi2html/">texi2html</A>&nbsp;1.56k.
</BODY>
</HTML>
