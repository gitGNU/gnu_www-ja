<html lang="en">
<head>
<title>GNU MP 4.1</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name=description content="How to install and use the GNU multiple precision arithmetic library, version 4.1.">
<meta name=generator content="makeinfo 4.2">
<link href="http://www.gnu.org/software/texinfo/" rel=generator-home>
<!--
This manual describes how to install and use the GNU multiple precision
arithmetic library, version 4.1.

<p>Copyright 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
Free Software Foundation, Inc.

<p>Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.1 or any later
version published by the Free Software Foundation; with no Invariant Sections,
with the Front-Cover Texts being "A GNU Manual", and with the Back-Cover
Texts being "You have freedom to copy and modify this GNU Manual, like GNU
software".  A copy of the license is included in <a href="GNU-Free-Documentation-License.html#GNU%20Free%20Documentation%20License">GNU Free Documentation License</a>.-->
</head>
<body>
<p>
Node:<a name="BSD%20Compatible%20Functions">BSD Compatible Functions</a>,
Next:<a rel=next accesskey=n href="Custom-Allocation.html#Custom%20Allocation">Custom Allocation</a>,
Previous:<a rel=previous accesskey=p href="C---Class-Interface.html#C++%20Class%20Interface">C++ Class Interface</a>,
Up:<a rel=up accesskey=u href="index.html#Top">Top</a>
<hr><br>

<h2>Berkeley MP Compatible Functions</h2>

<p>These functions are intended to be fully compatible with the Berkeley MP
library which is available on many BSD derived U*ix systems.  The
<code>--enable-mpbsd</code> option must be used when building GNU MP to make these
available (see <a href="Installing-GMP.html#Installing%20GMP">Installing GMP</a>).

<p>The original Berkeley MP library has a usage restriction: you cannot use the
same variable as both source and destination in a single function call.  The
compatible functions in GNU MP do not share this restriction--inputs and
outputs may overlap.

<p>It is not recommended that new programs are written using these functions. 
Apart from the incomplete set of functions, the interface for initializing
<code>MINT</code> objects is more error prone, and the <code>pow</code> function collides
with <code>pow</code> in <code>libm.a</code>.

<p>Include the header <code>mp.h</code> to get the definition of the necessary types and
functions.  If you are on a BSD derived system, make sure to include GNU
<code>mp.h</code> if you are going to link the GNU <code>libmp.a</code> to your program. 
This means that you probably need to give the <code>-I&lt;dir&gt;</code> option to the
compiler, where <code>&lt;dir&gt;</code> is the directory where you have GNU <code>mp.h</code>.

<p>
<table width="100%">
<tr>
<td align="left">MINT * <b>itom</b><i> (signed short int <var>initial_value</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Allocate an integer consisting of a <code>MINT</code> object and dynamic limb space. 
Initialize the integer to <var>initial_value</var>.  Return a pointer to the
<code>MINT</code> object. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">MINT * <b>xtom</b><i> (char *<var>initial_value</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Allocate an integer consisting of a <code>MINT</code> object and dynamic limb space. 
Initialize the integer from <var>initial_value</var>, a hexadecimal,
null-terminated C string.  Return a pointer to the <code>MINT</code> object. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>move</b><i> (MINT *<var>src</var>, MINT *<var>dest</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>dest</var> to <var>src</var> by copying.  Both variables must be previously
initialized. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>madd</b><i> (MINT *<var>src_1</var>, MINT *<var>src_2</var>, MINT *<var>destination</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Add <var>src_1</var> and <var>src_2</var> and put the sum in <var>destination</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>msub</b><i> (MINT *<var>src_1</var>, MINT *<var>src_2</var>, MINT *<var>destination</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Subtract <var>src_2</var> from <var>src_1</var> and put the difference in
<var>destination</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mult</b><i> (MINT *<var>src_1</var>, MINT *<var>src_2</var>, MINT *<var>destination</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Multiply <var>src_1</var> and <var>src_2</var> and put the product in <var>destination</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mdiv</b><i> (MINT *<var>dividend</var>, MINT *<var>divisor</var>, MINT *<var>quotient</var>, MINT *<var>remainder</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>sdiv</b><i> (MINT *<var>dividend</var>, signed short int <var>divisor</var>, MINT *<var>quotient</var>, signed short int *<var>remainder</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>quotient</var> to <var>dividend</var>/<var>divisor</var>, and <var>remainder</var> to
<var>dividend</var> mod <var>divisor</var>.  The quotient is rounded towards zero; the
remainder has the same sign as the dividend unless it is zero.

<p>Some implementations of these functions work differently--or not at all--for
negative arguments. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>msqrt</b><i> (MINT *<var>op</var>, MINT *<var>root</var>, MINT *<var>remainder</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>root</var> to the truncated integer part
of the square root of <var>op</var>, like <code>mpz_sqrt</code>.  Set <var>remainder</var> to
<var>op</var>-<var>root</var>*<var>root</var>, i.e. 
zero if <var>op</var> is a perfect square.

<p>If <var>root</var> and <var>remainder</var> are the same variable, the results are
undefined. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>pow</b><i> (MINT *<var>base</var>, MINT *<var>exp</var>, MINT *<var>mod</var>, MINT *<var>dest</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>dest</var> to (<var>base</var> raised to <var>exp</var>) modulo <var>mod</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>rpow</b><i> (MINT *<var>base</var>, signed short int <var>exp</var>, MINT *<var>dest</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>dest</var> to <var>base</var> raised to <var>exp</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>gcd</b><i> (MINT *<var>op1</var>, MINT *<var>op2</var>, MINT *<var>res</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>res</var> to the greatest common divisor of <var>op1</var> and <var>op2</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>mcmp</b><i> (MINT *<var>op1</var>, MINT *<var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Compare <var>op1</var> and <var>op2</var>.  Return a positive value if <var>op1</var> &gt;
<var>op2</var>, zero if <var>op1</var> = <var>op2</var>, and a negative value if <var>op1</var> &lt;
<var>op2</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>min</b><i> (MINT *<var>dest</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Input a decimal string from <code>stdin</code>, and put the read integer in
<var>dest</var>.  SPC and TAB are allowed in the number string, and are ignored. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mout</b><i> (MINT *<var>src</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Output <var>src</var> to <code>stdout</code>, as a decimal string.  Also output a newline. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">char * <b>mtox</b><i> (MINT *<var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Convert <var>op</var> to a hexadecimal string, and return a pointer to the string. 
The returned string is allocated using the default memory allocation function,
<code>malloc</code> by default.  It will be <code>strlen(str)+1</code> bytes, that being
exactly enough for the string and null-terminator. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mfree</b><i> (MINT *<var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
De-allocate, the space used by <var>op</var>.  <strong>This function should only be
passed a value returned by <code>itom</code> or <code>xtom</code>.</strong>
</td></tr>
</table>

</body></html>

