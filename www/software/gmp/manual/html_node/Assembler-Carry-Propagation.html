<html lang="en">
<head>
<title>GNU MP 4.1</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name=description content="How to install and use the GNU multiple precision arithmetic library, version 4.1.">
<meta name=generator content="makeinfo 4.2">
<link href="http://www.gnu.org/software/texinfo/" rel=generator-home>
<!--
This manual describes how to install and use the GNU multiple precision
arithmetic library, version 4.1.

<p>Copyright 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
Free Software Foundation, Inc.

<p>Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.1 or any later
version published by the Free Software Foundation; with no Invariant Sections,
with the Front-Cover Texts being "A GNU Manual", and with the Back-Cover
Texts being "You have freedom to copy and modify this GNU Manual, like GNU
software".  A copy of the license is included in <a href="GNU-Free-Documentation-License.html#GNU%20Free%20Documentation%20License">GNU Free Documentation License</a>.-->
</head>
<body>
<p>
Node:<a name="Assembler%20Carry%20Propagation">Assembler Carry Propagation</a>,
Next:<a rel=next accesskey=n href="Assembler-Cache-Handling.html#Assembler%20Cache%20Handling">Assembler Cache Handling</a>,
Previous:<a rel=previous accesskey=p href="Assembler-Basics.html#Assembler%20Basics">Assembler Basics</a>,
Up:<a rel=up accesskey=u href="Assembler-Coding.html#Assembler%20Coding">Assembler Coding</a>
<hr><br>

<h4>Carry Propagation</h4>

<p>The problem that presents most challenges in GMP is propagating carries from
one limb to the next.  In functions like <code>mpn_addmul_1</code> and
<code>mpn_add_n</code>, carries are the only dependencies between limb operations.

<p>On processors with carry flags, a straightforward CISC style <code>adc</code> is
generally best.  AMD K6 <code>mpn_addmul_1</code> however is an example of an
unusual set of circumstances where a branch works out better.

<p>On RISC processors generally an add and compare for overflow is used.  This
sort of thing can be seen in <code>mpn/generic/aors_n.c</code>.  Some carry
propagation schemes require 4 instructions, meaning at least 4 cycles per
limb, but other schemes may use just 1 or 2.  On wide superscalar processors
performance may be completely determined by the number of dependent
instructions between carry-in and carry-out for each limb.

<p>On vector processors good use can be made of the fact that a carry bit only
very rarely propagates more than one limb.  When adding a single bit to a
limb, there's only a carry out if that limb was <code>0xFF...FF</code> which on
random data will be only 1 in 2^mp_bits_per_limb.  <code>mpn/cray/add_n.c</code> is an example of this, it adds
all limbs in parallel, adds one set of carry bits in parallel and then only
rarely needs to fall through to a loop propagating further carries.

<p>On the x86s, GCC (as of version 2.95.2) doesn't generate particularly good code
for the RISC style idioms that are necessary to handle carry bits in
C.  Often conditional jumps are generated where <code>adc</code> or <code>sbb</code> forms
would be better.  And so unfortunately almost any loop involving carry bits
needs to be coded in assembler for best results.

</body></html>

