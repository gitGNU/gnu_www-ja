<html lang="en">
<head>
<title>GNU MP 4.1</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name=description content="How to install and use the GNU multiple precision arithmetic library, version 4.1.">
<meta name=generator content="makeinfo 4.2">
<link href="http://www.gnu.org/software/texinfo/" rel=generator-home>
<!--
This manual describes how to install and use the GNU multiple precision
arithmetic library, version 4.1.

<p>Copyright 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
Free Software Foundation, Inc.

<p>Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.1 or any later
version published by the Free Software Foundation; with no Invariant Sections,
with the Front-Cover Texts being "A GNU Manual", and with the Back-Cover
Texts being "You have freedom to copy and modify this GNU Manual, like GNU
software".  A copy of the license is included in <a href="GNU-Free-Documentation-License.html#GNU%20Free%20Documentation%20License">GNU Free Documentation License</a>.-->
</head>
<body>
<p>
Node:<a name="Integer%20Division">Integer Division</a>,
Next:<a rel=next accesskey=n href="Integer-Exponentiation.html#Integer%20Exponentiation">Integer Exponentiation</a>,
Previous:<a rel=previous accesskey=p href="Integer-Arithmetic.html#Integer%20Arithmetic">Integer Arithmetic</a>,
Up:<a rel=up accesskey=u href="Integer-Functions.html#Integer%20Functions">Integer Functions</a>
<hr><br>

<h3>Division Functions</h3>

<p>Division is undefined if the divisor is zero.  Passing a zero divisor to the
division or modulo functions (including the modular powering functions
<code>mpz_powm</code> and <code>mpz_powm_ui</code>), will cause an intentional division by
zero.  This lets a program handle arithmetic exceptions in these functions the
same way as for normal C <code>int</code> arithmetic.

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpz_cdiv_q</b><i> (mpz_t <var>q</var>, mpz_t <var>n</var>, mpz_t <var>d</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpz_cdiv_r</b><i> (mpz_t <var>r</var>, mpz_t <var>n</var>, mpz_t <var>d</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpz_cdiv_qr</b><i> (mpz_t <var>q</var>, mpz_t <var>r</var>, mpz_t <var>n</var>, mpz_t <var>d</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<tr>
<td align="left">unsigned long int <b>mpz_cdiv_q_ui</b><i> (mpz_t <var>q</var>, mpz_t <var>n</var>, unsigned&nbsp;long&nbsp;int&nbsp;<var>d</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">unsigned long int <b>mpz_cdiv_r_ui</b><i> (mpz_t <var>r</var>, mpz_t <var>n</var>, unsigned&nbsp;long&nbsp;int&nbsp;<var>d</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">unsigned long int <b>mpz_cdiv_qr_ui</b><i> (mpz_t <var>q</var>, mpz_t <var>r</var>, mpz_t&nbsp;<var>n</var>, unsigned&nbsp;long&nbsp;int&nbsp;<var>d</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">unsigned long int <b>mpz_cdiv_ui</b><i> (mpz_t <var>n</var>, unsigned&nbsp;long&nbsp;int&nbsp;<var>d</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<tr>
<td align="left">void <b>mpz_cdiv_q_2exp</b><i> (mpz_t <var>q</var>, mpz_t <var>n</var>, unsigned&nbsp;long&nbsp;int&nbsp;<var>b</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpz_cdiv_r_2exp</b><i> (mpz_t <var>r</var>, mpz_t <var>n</var>, unsigned&nbsp;long&nbsp;int&nbsp;<var>b</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpz_fdiv_q</b><i> (mpz_t <var>q</var>, mpz_t <var>n</var>, mpz_t <var>d</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpz_fdiv_r</b><i> (mpz_t <var>r</var>, mpz_t <var>n</var>, mpz_t <var>d</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpz_fdiv_qr</b><i> (mpz_t <var>q</var>, mpz_t <var>r</var>, mpz_t <var>n</var>, mpz_t <var>d</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<tr>
<td align="left">unsigned long int <b>mpz_fdiv_q_ui</b><i> (mpz_t <var>q</var>, mpz_t <var>n</var>, unsigned&nbsp;long&nbsp;int&nbsp;<var>d</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">unsigned long int <b>mpz_fdiv_r_ui</b><i> (mpz_t <var>r</var>, mpz_t <var>n</var>, unsigned&nbsp;long&nbsp;int&nbsp;<var>d</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">unsigned long int <b>mpz_fdiv_qr_ui</b><i> (mpz_t <var>q</var>, mpz_t <var>r</var>, mpz_t&nbsp;<var>n</var>, unsigned&nbsp;long&nbsp;int&nbsp;<var>d</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">unsigned long int <b>mpz_fdiv_ui</b><i> (mpz_t <var>n</var>, unsigned&nbsp;long&nbsp;int&nbsp;<var>d</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<tr>
<td align="left">void <b>mpz_fdiv_q_2exp</b><i> (mpz_t <var>q</var>, mpz_t <var>n</var>, unsigned&nbsp;long&nbsp;int&nbsp;<var>b</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpz_fdiv_r_2exp</b><i> (mpz_t <var>r</var>, mpz_t <var>n</var>, unsigned&nbsp;long&nbsp;int&nbsp;<var>b</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpz_tdiv_q</b><i> (mpz_t <var>q</var>, mpz_t <var>n</var>, mpz_t <var>d</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpz_tdiv_r</b><i> (mpz_t <var>r</var>, mpz_t <var>n</var>, mpz_t <var>d</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpz_tdiv_qr</b><i> (mpz_t <var>q</var>, mpz_t <var>r</var>, mpz_t <var>n</var>, mpz_t <var>d</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<tr>
<td align="left">unsigned long int <b>mpz_tdiv_q_ui</b><i> (mpz_t <var>q</var>, mpz_t <var>n</var>, unsigned&nbsp;long&nbsp;int&nbsp;<var>d</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">unsigned long int <b>mpz_tdiv_r_ui</b><i> (mpz_t <var>r</var>, mpz_t <var>n</var>, unsigned&nbsp;long&nbsp;int&nbsp;<var>d</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">unsigned long int <b>mpz_tdiv_qr_ui</b><i> (mpz_t <var>q</var>, mpz_t <var>r</var>, mpz_t&nbsp;<var>n</var>, unsigned&nbsp;long&nbsp;int&nbsp;<var>d</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">unsigned long int <b>mpz_tdiv_ui</b><i> (mpz_t <var>n</var>, unsigned&nbsp;long&nbsp;int&nbsp;<var>d</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<tr>
<td align="left">void <b>mpz_tdiv_q_2exp</b><i> (mpz_t <var>q</var>, mpz_t <var>n</var>, unsigned&nbsp;long&nbsp;int&nbsp;<var>b</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpz_tdiv_r_2exp</b><i> (mpz_t <var>r</var>, mpz_t <var>n</var>, unsigned&nbsp;long&nbsp;int&nbsp;<var>b</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<br><p>
<p>Divide <var>n</var> by <var>d</var>, forming a quotient <var>q</var> and/or remainder
<var>r</var>.  For the <code>2exp</code> functions, <var>d</var>=2^<var>b</var>. 
The rounding is in three styles, each suiting different applications.

<ul>
<li><code>cdiv</code> rounds <var>q</var> up towards +infinity, and <var>r</var> will
have the opposite sign to <var>d</var>.  The <code>c</code> stands for "ceil".

<li><code>fdiv</code> rounds <var>q</var> down towards -infinity, and
<var>r</var> will have the same sign as <var>d</var>.  The <code>f</code> stands for
"floor".

<li><code>tdiv</code> rounds <var>q</var> towards zero, and <var>r</var> will have the same sign
as <var>n</var>.  The <code>t</code> stands for "truncate". 
</ul>

<p>In all cases <var>q</var> and <var>r</var> will satisfy
<var>n</var>=<var>q</var>*<var>d</var>+<var>r</var>, and
<var>r</var> will satisfy 0&lt;=abs(<var>r</var>)&lt;abs(<var>d</var>).

<p>The <code>q</code> functions calculate only the quotient, the <code>r</code> functions
only the remainder, and the <code>qr</code> functions calculate both.  Note that for
<code>qr</code> the same variable cannot be passed for both <var>q</var> and <var>r</var>, or
results will be unpredictable.

<p>For the <code>ui</code> variants the return value is the remainder, and in fact
returning the remainder is all the <code>div_ui</code> functions do.  For
<code>tdiv</code> and <code>cdiv</code> the remainder can be negative, so for those the
return value is the absolute value of the remainder.

<p>The <code>2exp</code> functions are right shifts and bit masks, but of course
rounding the same as the other functions.  For positive <var>n</var> both
<code>mpz_fdiv_q_2exp</code> and <code>mpz_tdiv_q_2exp</code> are simple bitwise right
shifts.  For negative <var>n</var>, <code>mpz_fdiv_q_2exp</code> is effectively an
arithmetic right shift treating <var>n</var> as twos complement the same as the
bitwise logical functions do, whereas <code>mpz_tdiv_q_2exp</code> effectively
treats <var>n</var> as sign and magnitude. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpz_mod</b><i> (mpz_t <var>r</var>, mpz_t <var>n</var>, mpz_t <var>d</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">unsigned long int <b>mpz_mod_ui</b><i> (mpz_t <var>r</var>, mpz_t <var>n</var>, unsigned&nbsp;long&nbsp;int&nbsp;<var>d</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>r</var> to <var>n</var> <code>mod</code> <var>d</var>.  The sign of the divisor is
ignored; the result is always non-negative.

<p><code>mpz_mod_ui</code> is identical to <code>mpz_fdiv_r_ui</code> above, returning the
remainder as well as setting <var>r</var>.  See <code>mpz_fdiv_ui</code> above if only
the return value is wanted. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpz_divexact</b><i> (mpz_t <var>q</var>, mpz_t <var>n</var>, mpz_t <var>d</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpz_divexact_ui</b><i> (mpz_t <var>q</var>, mpz_t <var>n</var>, unsigned long <var>d</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>q</var> to <var>n</var>/<var>d</var>.  These functions produce correct results only
when it is known in advance that <var>d</var> divides <var>n</var>.

<p>These routines are much faster than the other division functions, and are the
best choice when exact division is known to occur, for example reducing a
rational to lowest terms. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>mpz_divisible_p</b><i> (mpz_t <var>n</var>, mpz_t <var>d</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">int <b>mpz_divisible_ui_p</b><i> (mpz_t <var>n</var>, unsigned long int <var>d</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">int <b>mpz_divisible_2exp_p</b><i> (mpz_t <var>n</var>, unsigned long int <var>b</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Return non-zero if <var>n</var> is exactly divisible by <var>d</var>, or in the case of
<code>mpz_divisible_2exp_p</code> by 2^<var>b</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>mpz_congruent_p</b><i> (mpz_t <var>n</var>, mpz_t <var>c</var>, mpz_t <var>d</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">int <b>mpz_congruent_ui_p</b><i> (mpz_t <var>n</var>, unsigned long int <var>c</var>, unsigned long int <var>d</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">int <b>mpz_congruent_2exp_p</b><i> (mpz_t <var>n</var>, mpz_t <var>c</var>, unsigned long int <var>b</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Return non-zero if <var>n</var> is congruent to <var>c</var> modulo <var>d</var>, or in the
case of <code>mpz_congruent_2exp_p</code> modulo 2^<var>b</var>. 
</td></tr>
</table>

</body></html>

