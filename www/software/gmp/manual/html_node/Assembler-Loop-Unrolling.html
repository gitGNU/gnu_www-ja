<html lang="en">
<head>
<title>GNU MP 4.1</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name=description content="How to install and use the GNU multiple precision arithmetic library, version 4.1.">
<meta name=generator content="makeinfo 4.2">
<link href="http://www.gnu.org/software/texinfo/" rel=generator-home>
<!--
This manual describes how to install and use the GNU multiple precision
arithmetic library, version 4.1.

<p>Copyright 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
Free Software Foundation, Inc.

<p>Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.1 or any later
version published by the Free Software Foundation; with no Invariant Sections,
with the Front-Cover Texts being "A GNU Manual", and with the Back-Cover
Texts being "You have freedom to copy and modify this GNU Manual, like GNU
software".  A copy of the license is included in <a href="GNU-Free-Documentation-License.html#GNU%20Free%20Documentation%20License">GNU Free Documentation License</a>.-->
</head>
<body>
<p>
Node:<a name="Assembler%20Loop%20Unrolling">Assembler Loop Unrolling</a>,
Previous:<a rel=previous accesskey=p href="Assembler-Software-Pipelining.html#Assembler%20Software%20Pipelining">Assembler Software Pipelining</a>,
Up:<a rel=up accesskey=u href="Assembler-Coding.html#Assembler%20Coding">Assembler Coding</a>
<hr><br>

<h4>Loop Unrolling</h4>

<p>Loop unrolling consists of replicating code so that several limbs are
processed in each loop.  At a minimum this reduces loop overheads by a
corresponding factor, but it can also allow better register usage, for example
alternately using one register combination and then another.  Judicious use of
<code>m4</code> macros can help avoid lots of duplication in the source code.

<p>Unrolling is commonly done to a power of 2 multiple so the number of unrolled
loops and the number of remaining limbs can be calculated with a shift and
mask.  But other multiples can be used too, just by subtracting each <var>n</var>
limbs processed from a counter and waiting for less than <var>n</var> remaining (or
offsetting the counter by <var>n</var> so it goes negative when there's less than
<var>n</var> remaining).

<p>The limbs not a multiple of the unrolling can be handled in various ways, for
example

<ul>
<li>A simple loop at the end (or the start) to process the excess.  Care will be
wanted that it isn't too much slower than the unrolled part.

<li>A set of binary tests, for example after an 8-limb unrolling, test for 4 more
limbs to process, then a further 2 more or not, and finally 1 more or not. 
This will probably take more code space than a simple loop.

<li>A <code>switch</code> statement, providing separate code for each possible excess,
for example an 8-limb unrolling would have separate code for 0 remaining, 1
remaining, etc, up to 7 remaining.  This might take a lot of code, but may be
the best way to optimize all cases in combination with a deep pipelined loop.

<li>A computed jump into the middle of the loop, thus making the first iteration
handle the excess.  This should make times smoothly increase with size, which
is attractive, but setups for the jump and adjustments for pointers can be
tricky and could become quite difficult in combination with deep pipelining. 
</ul>

<p>One way to write the setups and finishups for a pipelined unrolled loop is
simply to duplicate the loop at the start and the end, then delete
instructions at the start which have no valid antecedents, and delete
instructions at the end whose results are unwanted.  Sizes not a multiple of
the unrolling can then be handled as desired.

</body></html>

