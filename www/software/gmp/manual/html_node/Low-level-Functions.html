<html lang="en">
<head>
<title>GNU MP 4.1</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name=description content="How to install and use the GNU multiple precision arithmetic library, version 4.1.">
<meta name=generator content="makeinfo 4.2">
<link href="http://www.gnu.org/software/texinfo/" rel=generator-home>
<!--
This manual describes how to install and use the GNU multiple precision
arithmetic library, version 4.1.

<p>Copyright 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
Free Software Foundation, Inc.

<p>Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.1 or any later
version published by the Free Software Foundation; with no Invariant Sections,
with the Front-Cover Texts being "A GNU Manual", and with the Back-Cover
Texts being "You have freedom to copy and modify this GNU Manual, like GNU
software".  A copy of the license is included in <a href="GNU-Free-Documentation-License.html#GNU%20Free%20Documentation%20License">GNU Free Documentation License</a>.-->
</head>
<body>
<p>
Node:<a name="Low-level%20Functions">Low-level Functions</a>,
Next:<a rel=next accesskey=n href="Random-Number-Functions.html#Random%20Number%20Functions">Random Number Functions</a>,
Previous:<a rel=previous accesskey=p href="Floating-point-Functions.html#Floating-point%20Functions">Floating-point Functions</a>,
Up:<a rel=up accesskey=u href="index.html#Top">Top</a>
<hr><br>

<h2>Low-level Functions</h2>

<p>This chapter describes low-level GMP functions, used to implement the
high-level GMP functions, but also intended for time-critical user code.

<p>These functions start with the prefix <code>mpn_</code>.

<p>The <code>mpn</code> functions are designed to be as fast as possible, <strong>not</strong>
to provide a coherent calling interface.  The different functions have somewhat
similar interfaces, but there are variations that make them hard to use.  These
functions do as little as possible apart from the real multiple precision
computation, so that no time is spent on things that not all callers need.

<p>A source operand is specified by a pointer to the least significant limb and a
limb count.  A destination operand is specified by just a pointer.  It is the
responsibility of the caller to ensure that the destination has enough space
for storing the result.

<p>With this way of specifying operands, it is possible to perform computations on
subranges of an argument, and store the result into a subrange of a
destination.

<p>A common requirement for all functions is that each source area needs at least
one limb.  No size argument may be zero.  Unless otherwise stated, in-place
operations are allowed where source and destination are the same, but not where
they only partly overlap.

<p>The <code>mpn</code> functions are the base for the implementation of the
<code>mpz_</code>, <code>mpf_</code>, and <code>mpq_</code> functions.

<p>This example adds the number beginning at <var>s1p</var> and the number beginning at
<var>s2p</var> and writes the sum at <var>destp</var>.  All areas have <var>n</var> limbs.

<br><pre>cy = mpn_add_n (destp, s1p, s2p, n)
</pre>

<p>In the notation used here, a source operand is identified by the pointer to
the least significant limb, and the limb count in braces.  For example,
{<var>s1p</var>, <var>s1n</var>}.

<p>
<table width="100%">
<tr>
<td align="left">mp_limb_t <b>mpn_add_n</b><i> (mp_limb_t *<var>rp</var>, const mp_limb_t *<var>s1p</var>, const mp_limb_t *<var>s2p</var>, mp_size_t <var>n</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Add {<var>s1p</var>, <var>n</var>} and {<var>s2p</var>, <var>n</var>}, and write the <var>n</var>
least significant limbs of the result to <var>rp</var>.  Return carry, either 0 or
1.

<p>This is the lowest-level function for addition.  It is the preferred function
for addition, since it is written in assembly for most CPUs.  For addition of
a variable to itself (i.e., <var>s1p</var> equals <var>s2p</var>, use <code>mpn_lshift</code>
with a count of 1 for optimal speed. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">mp_limb_t <b>mpn_add_1</b><i> (mp_limb_t *<var>rp</var>, const mp_limb_t *<var>s1p</var>, mp_size_t <var>n</var>, mp_limb_t <var>s2limb</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Add {<var>s1p</var>, <var>n</var>} and <var>s2limb</var>, and write the <var>n</var> least
significant limbs of the result to <var>rp</var>.  Return carry, either 0 or 1. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">mp_limb_t <b>mpn_add</b><i> (mp_limb_t *<var>rp</var>, const mp_limb_t *<var>s1p</var>, mp_size_t <var>s1n</var>, const mp_limb_t *<var>s2p</var>, mp_size_t <var>s2n</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Add {<var>s1p</var>, <var>s1n</var>} and {<var>s2p</var>, <var>s2n</var>}, and write the
<var>s1n</var> least significant limbs of the result to <var>rp</var>.  Return carry,
either 0 or 1.

<p>This function requires that <var>s1n</var> is greater than or equal to <var>s2n</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">mp_limb_t <b>mpn_sub_n</b><i> (mp_limb_t *<var>rp</var>, const mp_limb_t *<var>s1p</var>, const mp_limb_t *<var>s2p</var>, mp_size_t <var>n</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Subtract {<var>s2p</var>, <var>n</var>} from {<var>s1p</var>, <var>n</var>}, and write the
<var>n</var> least significant limbs of the result to <var>rp</var>.  Return borrow,
either 0 or 1.

<p>This is the lowest-level function for subtraction.  It is the preferred
function for subtraction, since it is written in assembly for most CPUs. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">mp_limb_t <b>mpn_sub_1</b><i> (mp_limb_t *<var>rp</var>, const mp_limb_t *<var>s1p</var>, mp_size_t <var>n</var>, mp_limb_t <var>s2limb</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Subtract <var>s2limb</var> from {<var>s1p</var>, <var>n</var>}, and write the <var>n</var> least
significant limbs of the result to <var>rp</var>.  Return borrow, either 0 or 1. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">mp_limb_t <b>mpn_sub</b><i> (mp_limb_t *<var>rp</var>, const mp_limb_t *<var>s1p</var>, mp_size_t <var>s1n</var>, const mp_limb_t *<var>s2p</var>, mp_size_t <var>s2n</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Subtract {<var>s2p</var>, <var>s2n</var>} from {<var>s1p</var>, <var>s1n</var>}, and write the
<var>s1n</var> least significant limbs of the result to <var>rp</var>.  Return borrow,
either 0 or 1.

<p>This function requires that <var>s1n</var> is greater than or equal to
<var>s2n</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpn_mul_n</b><i> (mp_limb_t *<var>rp</var>, const mp_limb_t *<var>s1p</var>, const mp_limb_t *<var>s2p</var>, mp_size_t <var>n</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Multiply {<var>s1p</var>, <var>n</var>} and {<var>s2p</var>, <var>n</var>}, and write the
2*<var>n</var>-limb result to <var>rp</var>.

<p>The destination has to have space for 2*<var>n</var> limbs, even if the product's
most significant limb is zero. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">mp_limb_t <b>mpn_mul_1</b><i> (mp_limb_t *<var>rp</var>, const mp_limb_t *<var>s1p</var>, mp_size_t <var>n</var>, mp_limb_t <var>s2limb</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Multiply {<var>s1p</var>, <var>n</var>} by <var>s2limb</var>, and write the <var>n</var> least
significant limbs of the product to <var>rp</var>.  Return the most significant
limb of the product.  {<var>s1p</var>, <var>n</var>} and {<var>rp</var>, <var>n</var>} are
allowed to overlap provided <var>rp</var> &lt;= <var>s1p</var>.

<p>This is a low-level function that is a building block for general
multiplication as well as other operations in GMP.  It is written in assembly
for most CPUs.

<p>Don't call this function if <var>s2limb</var> is a power of 2; use <code>mpn_lshift</code>
with a count equal to the logarithm of <var>s2limb</var> instead, for optimal speed. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">mp_limb_t <b>mpn_addmul_1</b><i> (mp_limb_t *<var>rp</var>, const mp_limb_t *<var>s1p</var>, mp_size_t <var>n</var>, mp_limb_t <var>s2limb</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Multiply {<var>s1p</var>, <var>n</var>} and <var>s2limb</var>, and add the <var>n</var> least
significant limbs of the product to {<var>rp</var>, <var>n</var>} and write the result
to <var>rp</var>.  Return the most significant limb of the product, plus carry-out
from the addition.

<p>This is a low-level function that is a building block for general
multiplication as well as other operations in GMP.  It is written in assembly
for most CPUs. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">mp_limb_t <b>mpn_submul_1</b><i> (mp_limb_t *<var>rp</var>, const mp_limb_t *<var>s1p</var>, mp_size_t <var>n</var>, mp_limb_t <var>s2limb</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Multiply {<var>s1p</var>, <var>n</var>} and <var>s2limb</var>, and subtract the <var>n</var>
least significant limbs of the product from {<var>rp</var>, <var>n</var>} and write the
result to <var>rp</var>.  Return the most significant limb of the product, minus
borrow-out from the subtraction.

<p>This is a low-level function that is a building block for general
multiplication and division as well as other operations in GMP.  It is written
in assembly for most CPUs. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">mp_limb_t <b>mpn_mul</b><i> (mp_limb_t *<var>rp</var>, const mp_limb_t *<var>s1p</var>, mp_size_t <var>s1n</var>, const mp_limb_t *<var>s2p</var>, mp_size_t <var>s2n</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Multiply {<var>s1p</var>, <var>s1n</var>} and {<var>s2p</var>, <var>s2n</var>}, and write the
result to <var>rp</var>.  Return the most significant limb of the result.

<p>The destination has to have space for <var>s1n</var> + <var>s2n</var> limbs, even if the
result might be one limb smaller.

<p>This function requires that <var>s1n</var> is greater than or equal to
<var>s2n</var>.  The destination must be distinct from both input operands. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpn_tdiv_qr</b><i> (mp_limb_t *<var>qp</var>, mp_limb_t *<var>rp</var>, mp_size_t <var>qxn</var>, const mp_limb_t *<var>np</var>, mp_size_t <var>nn</var>, const mp_limb_t *<var>dp</var>, mp_size_t <var>dn</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Divide {<var>np</var>, <var>nn</var>} by {<var>dp</var>, <var>dn</var>} and put the quotient
at {<var>qp</var>, <var>nn</var>-<var>dn</var>+1} and the remainder at {<var>rp</var>,
<var>dn</var>}.  The quotient is rounded towards 0.

<p>No overlap is permitted between arguments.  <var>nn</var> must be greater than or
equal to <var>dn</var>.  The most significant limb of <var>dp</var> must be non-zero. 
The <var>qxn</var> operand must be zero. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">mp_limb_t <b>mpn_divrem</b><i> (mp_limb_t *<var>r1p</var>, mp_size_t <var>qxn</var>, mp_limb_t *<var>rs2p</var>, mp_size_t <var>rs2n</var>, const mp_limb_t *<var>s3p</var>, mp_size_t <var>s3n</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
[This function is obsolete.  Please call <code>mpn_tdiv_qr</code> instead for best
performance.]

<p>Divide {<var>rs2p</var>, <var>rs2n</var>} by {<var>s3p</var>, <var>s3n</var>}, and write the
quotient at <var>r1p</var>, with the exception of the most significant limb, which
is returned.  The remainder replaces the dividend at <var>rs2p</var>; it will be
<var>s3n</var> limbs long (i.e., as many limbs as the divisor).

<p>In addition to an integer quotient, <var>qxn</var> fraction limbs are developed, and
stored after the integral limbs.  For most usages, <var>qxn</var> will be zero.

<p>It is required that <var>rs2n</var> is greater than or equal to <var>s3n</var>.  It is
required that the most significant bit of the divisor is set.

<p>If the quotient is not needed, pass <var>rs2p</var> + <var>s3n</var> as <var>r1p</var>.  Aside
from that special case, no overlap between arguments is permitted.

<p>Return the most significant limb of the quotient, either 0 or 1.

<p>The area at <var>r1p</var> needs to be <var>rs2n</var> - <var>s3n</var> + <var>qxn</var>
limbs large. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">mp_limb_t <b>mpn_divrem_1</b><i> (mp_limb_t *<var>r1p</var>, mp_size_t <var>qxn</var>, mp_limb_t&nbsp;*<var>s2p</var>, mp_size_t <var>s2n</var>, mp_limb_t <var>s3limb</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">mp_limb_t <b>mpn_divmod_1</b><i> (mp_limb_t *<var>r1p</var>, mp_limb_t *<var>s2p</var>, mp_size_t&nbsp;<var>s2n</var>, mp_limb_t&nbsp;<var>s3limb</var>)
</i></td>
<td align="right">Macro</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Divide {<var>s2p</var>, <var>s2n</var>} by <var>s3limb</var>, and write the quotient at
<var>r1p</var>.  Return the remainder.

<p>The integer quotient is written to {<var>r1p</var>+<var>qxn</var>, <var>s2n</var>} and in
addition <var>qxn</var> fraction limbs are developed and written to {<var>r1p</var>,
<var>qxn</var>}.  Either or both <var>s2n</var> and <var>qxn</var> can be zero.  For most
usages, <var>qxn</var> will be zero.

<p><code>mpn_divmod_1</code> exists for upward source compatibility and is simply a
macro calling <code>mpn_divrem_1</code> with a <var>qxn</var> of 0.

<p>The areas at <var>r1p</var> and <var>s2p</var> have to be identical or completely
separate, not partially overlapping. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">mp_limb_t <b>mpn_divmod</b><i> (mp_limb_t *<var>r1p</var>, mp_limb_t *<var>rs2p</var>, mp_size_t <var>rs2n</var>, const mp_limb_t *<var>s3p</var>, mp_size_t <var>s3n</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
[This function is obsolete.  Please call <code>mpn_tdiv_qr</code> instead for best
performance.] 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">mp_limb_t <b>mpn_divexact_by3</b><i> (mp_limb_t *<var>rp</var>, mp_limb_t *<var>sp</var>, mp_size_t&nbsp;<var>n</var>)
</i></td>
<td align="right">Macro</td>
</tr>

<tr>
<td align="left">mp_limb_t <b>mpn_divexact_by3c</b><i> (mp_limb_t *<var>rp</var>, mp_limb_t *<var>sp</var>, mp_size_t&nbsp;<var>n</var>, mp_limb_t <var>carry</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Divide {<var>sp</var>, <var>n</var>} by 3, expecting it to divide exactly, and writing
the result to {<var>rp</var>, <var>n</var>}.  If 3 divides exactly, the return value is
zero and the result is the quotient.  If not, the return value is non-zero and
the result won't be anything useful.

<p><code>mpn_divexact_by3c</code> takes an initial carry parameter, which can be the
return value from a previous call, so a large calculation can be done piece by
piece from low to high.  <code>mpn_divexact_by3</code> is simply a macro calling
<code>mpn_divexact_by3c</code> with a 0 carry parameter.

<p>These routines use a multiply-by-inverse and will be faster than
<code>mpn_divrem_1</code> on CPUs with fast multiplication but slow division.

<p>The source a, result q, size n, initial carry i,
and return value c satisfy c*b^n + a-i = 3*q, where
b=2^mp_bits_per_limb.  The
return c is always 0, 1 or 2, and the initial carry i must also
be 0, 1 or 2 (these are both borrows really).  When c=0 clearly
q=(a-i)/3.  When c!=0, the remainder (a-i) mod
3 is given by 3-c, because b == 1 mod 3 (when
<code>mp_bits_per_limb</code> is even, which is always so currently). 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">mp_limb_t <b>mpn_mod_1</b><i> (mp_limb_t *<var>s1p</var>, mp_size_t <var>s1n</var>, mp_limb_t <var>s2limb</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Divide {<var>s1p</var>, <var>s1n</var>} by <var>s2limb</var>, and return the remainder. 
<var>s1n</var> can be zero. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">mp_limb_t <b>mpn_bdivmod</b><i> (mp_limb_t *<var>rp</var>, mp_limb_t *<var>s1p</var>, mp_size_t <var>s1n</var>, const mp_limb_t *<var>s2p</var>, mp_size_t <var>s2n</var>, unsigned long int <var>d</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
This function puts the low
floor(<var>d</var>/<code>mp_bits_per_limb</code>) limbs of <var>q</var> =
{<var>s1p</var>, <var>s1n</var>}/{<var>s2p</var>, <var>s2n</var>} mod 2^<var>d</var> at
<var>rp</var>, and returns the high <var>d</var> mod <code>mp_bits_per_limb</code> bits of
<var>q</var>.

<p>{<var>s1p</var>, <var>s1n</var>} - <var>q</var> * {<var>s2p</var>, <var>s2n</var>} mod 2^(<var>s1n</var>*<code>mp_bits_per_limb</code>) is placed at <var>s1p</var>.  Since the
low floor(<var>d</var>/<code>mp_bits_per_limb</code>) limbs of this
difference are zero, it is possible to overwrite the low limbs at <var>s1p</var>
with this difference, provided <var>rp</var> &lt;= <var>s1p</var>.

<p>This function requires that <var>s1n</var> * <code>mp_bits_per_limb</code>
&gt;= <var>D</var>, and that {<var>s2p</var>, <var>s2n</var>} is odd.

<p><strong>This interface is preliminary.  It might change incompatibly in future
revisions.</strong>
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">mp_limb_t <b>mpn_lshift</b><i> (mp_limb_t *<var>rp</var>, const mp_limb_t *<var>sp</var>, mp_size_t <var>n</var>, unsigned int <var>count</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Shift {<var>sp</var>, <var>n</var>} left by <var>count</var> bits, and write the result to
{<var>rp</var>, <var>n</var>}.  The bits shifted out at the left are returned in the
least significant <var>count</var> bits of the return value (the rest of the return
value is zero).

<p><var>count</var> must be in the range 1 to <code>mp_bits_per_limb</code>-1.  The
regions {<var>sp</var>, <var>n</var>} and {<var>rp</var>, <var>n</var>} may overlap, provided
<var>rp</var> &gt;= <var>sp</var>.

<p>This function is written in assembly for most CPUs. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">mp_limb_t <b>mpn_rshift</b><i> (mp_limb_t *<var>rp</var>, const mp_limb_t *<var>sp</var>, mp_size_t <var>n</var>, unsigned int <var>count</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Shift {<var>sp</var>, <var>n</var>} right by <var>count</var> bits, and write the result to
{<var>rp</var>, <var>n</var>}.  The bits shifted out at the right are returned in the
most significant <var>count</var> bits of the return value (the rest of the return
value is zero).

<p><var>count</var> must be in the range 1 to <code>mp_bits_per_limb</code>-1.  The
regions {<var>sp</var>, <var>n</var>} and {<var>rp</var>, <var>n</var>} may overlap, provided
<var>rp</var> &lt;= <var>sp</var>.

<p>This function is written in assembly for most CPUs. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>mpn_cmp</b><i> (const mp_limb_t *<var>s1p</var>, const mp_limb_t *<var>s2p</var>, mp_size_t <var>n</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Compare {<var>s1p</var>, <var>n</var>} and {<var>s2p</var>, <var>n</var>} and return a
positive value if <var>s1</var> &gt; <var>s2</var>, 0 if they are equal, or a
negative value if <var>s1</var> &lt; <var>s2</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">mp_size_t <b>mpn_gcd</b><i> (mp_limb_t *<var>rp</var>, mp_limb_t *<var>s1p</var>, mp_size_t <var>s1n</var>, mp_limb_t *<var>s2p</var>, mp_size_t <var>s2n</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set {<var>rp</var>, <var>retval</var>} to the greatest common divisor of {<var>s1p</var>,
<var>s1n</var>} and {<var>s2p</var>, <var>s2n</var>}.  The result can be up to <var>s2n</var>
limbs, the return value is the actual number produced.  Both source operands
are destroyed.

<p>{<var>s1p</var>, <var>s1n</var>} must have at least as many bits as {<var>s2p</var>,
<var>s2n</var>}.  {<var>s2p</var>, <var>s2n</var>} must be odd.  Both operands must have
non-zero most significant limbs.  No overlap is permitted between {<var>s1p</var>,
<var>s1n</var>} and {<var>s2p</var>, <var>s2n</var>}. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">mp_limb_t <b>mpn_gcd_1</b><i> (const mp_limb_t *<var>s1p</var>, mp_size_t <var>s1n</var>, mp_limb_t <var>s2limb</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Return the greatest common divisor of {<var>s1p</var>, <var>s1n</var>} and
<var>s2limb</var>.  Both operands must be non-zero. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">mp_size_t <b>mpn_gcdext</b><i> (mp_limb_t *<var>r1p</var>, mp_limb_t *<var>r2p</var>, mp_size_t *<var>r2n</var>, mp_limb_t *<var>s1p</var>, mp_size_t <var>s1n</var>, mp_limb_t *<var>s2p</var>, mp_size_t <var>s2n</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Calculate the greatest common divisor of {<var>s1p</var>, <var>s1n</var>} and
{<var>s2p</var>, <var>s2n</var>}.  Store the gcd at {<var>r1p</var>, <var>retval</var>} and
the first cofactor at {<var>r2p</var>, *<var>r2n</var>}, with *<var>r2n</var> negative if
the cofactor is negative.  <var>r1p</var> and <var>r2p</var> should each have room for
<var>s1n</var>+1 limbs, but the return value and value stored through
<var>r2n</var> indicate the actual number produced.

<p>{<var>s1p</var>, <var>s1n</var>} &gt;= {<var>s2p</var>, <var>s2n</var>} is required,
and both must be non-zero.  The regions {<var>s1p</var>, <var>s1n</var>+1} and
{<var>s2p</var>, <var>s2n</var>+1} are destroyed (i.e. the operands plus an
extra limb past the end of each).

<p>The cofactor <var>r1</var> will satisfy <var>r2</var>*<var>s1</var>
+ <var>k</var>*<var>s2</var> = <var>r1</var>.  The second cofactor <var>k</var> is not calculated
but can easily be obtained from (<var>r1</var> -
<var>r2</var>*<var>s1</var>) / <var>s2</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">mp_size_t <b>mpn_sqrtrem</b><i> (mp_limb_t *<var>r1p</var>, mp_limb_t *<var>r2p</var>, const mp_limb_t *<var>sp</var>, mp_size_t <var>n</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Compute the square root of {<var>sp</var>, <var>n</var>} and put the result at
{<var>r1p</var>, ceil(<var>n</var>/2)} and the remainder at {<var>r2p</var>,
<var>retval</var>}.  <var>r2p</var> needs space for <var>n</var> limbs, but the return value
indicates how many are produced.

<p>The most significant limb of {<var>sp</var>, <var>n</var>} must be non-zero.  The
areas {<var>r1p</var>, ceil(<var>n</var>/2)} and {<var>sp</var>, <var>n</var>} must
be completely separate.  The areas {<var>r2p</var>, <var>n</var>} and {<var>sp</var>,
<var>n</var>} must be either identical or completely separate.

<p>If the remainder is not wanted then <var>r2p</var> can be <code>NULL</code>, and in this
case the return value is zero or non-zero according to whether the remainder
would have been zero or non-zero.

<p>A return value of zero indicates a perfect square.  See also
<code>mpz_perfect_square_p</code>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">mp_size_t <b>mpn_get_str</b><i> (unsigned char *<var>str</var>, int <var>base</var>, mp_limb_t *<var>s1p</var>, mp_size_t <var>s1n</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Convert {<var>s1p</var>, <var>s1n</var>} to a raw unsigned char array at <var>str</var> in
base <var>base</var>, and return the number of characters produced.  There may be
leading zeros in the string.  The string is not in ASCII; to convert it to
printable format, add the ASCII codes for <code>0</code> or <code>A</code>, depending on
the base and range.

<p>The most significant limb of the input {<var>s1p</var>, <var>s1n</var>} must be
non-zero.  The input {<var>s1p</var>, <var>s1n</var>} is clobbered, except when
<var>base</var> is a power of 2, in which case it's unchanged.

<p>The area at <var>str</var> has to have space for the largest possible number
represented by a <var>s1n</var> long limb array, plus one extra character. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">mp_size_t <b>mpn_set_str</b><i> (mp_limb_t *<var>rp</var>, const char *<var>str</var>, size_t <var>strsize</var>, int <var>base</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Convert bytes {<var>str</var>,<var>strsize</var>} in the given <var>base</var> to limbs at
<var>rp</var>.

<p><var>str</var>[0] is the most significant byte and
<var>str</var>[<var>strsize</var>-1] is the least significant.  Each byte should
be a value in the range 0 to <var>base</var>-1, not an ASCII character. 
<var>base</var> can vary from 2 to 256.

<p>The return value is the number of limbs written to <var>rp</var>.  If the most
significant input byte is non-zero then the high limb at <var>rp</var> will be
non-zero, and only that exact number of limbs will be required there.

<p>If the most significant input byte is zero then there may be high zero limbs
written to <var>rp</var> and included in the return value.

<p><var>strsize</var> must be at least 1, and no overlap is permitted between
{<var>str</var>,<var>strsize</var>} and the result at <var>rp</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">unsigned long int <b>mpn_scan0</b><i> (const mp_limb_t *<var>s1p</var>, unsigned long int <var>bit</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Scan <var>s1p</var> from bit position <var>bit</var> for the next clear bit.

<p>It is required that there be a clear bit within the area at <var>s1p</var> at or
beyond bit position <var>bit</var>, so that the function has something to return. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">unsigned long int <b>mpn_scan1</b><i> (const mp_limb_t *<var>s1p</var>, unsigned long int <var>bit</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Scan <var>s1p</var> from bit position <var>bit</var> for the next set bit.

<p>It is required that there be a set bit within the area at <var>s1p</var> at or
beyond bit position <var>bit</var>, so that the function has something to return. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpn_random</b><i> (mp_limb_t *<var>r1p</var>, mp_size_t <var>r1n</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpn_random2</b><i> (mp_limb_t *<var>r1p</var>, mp_size_t <var>r1n</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Generate a random number of length <var>r1n</var> and store it at <var>r1p</var>.  The
most significant limb is always non-zero.  <code>mpn_random</code> generates
uniformly distributed limb data, <code>mpn_random2</code> generates long strings of
zeros and ones in the binary representation.

<p><code>mpn_random2</code> is intended for testing the correctness of the <code>mpn</code>
routines. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">unsigned long int <b>mpn_popcount</b><i> (const mp_limb_t *<var>s1p</var>, mp_size_t <var>n</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Count the number of set bits in {<var>s1p</var>, <var>n</var>}. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">unsigned long int <b>mpn_hamdist</b><i> (const mp_limb_t *<var>s1p</var>, const mp_limb_t *<var>s2p</var>, mp_size_t <var>n</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Compute the hamming distance between {<var>s1p</var>, <var>n</var>} and {<var>s2p</var>,
<var>n</var>}. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>mpn_perfect_square_p</b><i> (const mp_limb_t *<var>s1p</var>, mp_size_t <var>n</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Return non-zero iff {<var>s1p</var>, <var>n</var>} is a perfect square. 
</td></tr>
</table>

<br><p>
<h3>Nails</h3>

<p><strong>Everything in this section is highly experimental and may disappear or
be subject to incompatible changes in a future version of GMP.</strong>

<p>Nails are an experimental feature whereby a few bits are left unused at the
top of each <code>mp_limb_t</code>.  This can significantly improve carry handling
on some processors.

<p>All the <code>mpn</code> functions accepting limb data will expect the nail bits to
be zero on entry, and will return data with the nails similarly all zero. 
This applies both to limb vectors and to single limb arguments.

<p>Nails can be enabled by configuring with <code>--enable-nails</code>.  By default
the number of bits will be chosen according to what suits the host processor,
but a particular number can be selected with <code>--enable-nails=N</code>.

<p>At the mpn level, a nail build is neither source nor binary compatible with a
non-nail build, strictly speaking.  But programs acting on limbs only through
the mpn functions are likely to work equally well with either build, and
judicious use of the definitions below should make any program compatible with
either build, at the source level.

<p>For the higher level routines, meaning <code>mpz</code> etc, a nail build should be
fully source and binary compatible with a non-nail build.

<p>
<table width="100%">
<tr>
<td align="left"><b>GMP_NAIL_BITS</b><i>
</i></td>
<td align="right">Macro</td>
</tr>

<tr>
<td align="left"><b>GMP_NUMB_BITS</b><i>
</i></td>
<td align="right">Macro</td>
</tr>

<tr>
<td align="left"><b>GMP_LIMB_BITS</b><i>
</i></td>
<td align="right">Macro</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
<code>GMP_NAIL_BITS</code> is the number of nail bits, or 0 when nails are not in
use.  <code>GMP_NUMB_BITS</code> is the number of data bits in a limb. 
<code>GMP_LIMB_BITS</code> is the total number of bits in an <code>mp_limb_t</code>.  In
all cases

<br><pre>GMP_LIMB_BITS == GMP_NAIL_BITS + GMP_NUMB_BITS
</pre>
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left"><b>GMP_NAIL_MASK</b><i>
</i></td>
<td align="right">Macro</td>
</tr>

<tr>
<td align="left"><b>GMP_NUMB_MASK</b><i>
</i></td>
<td align="right">Macro</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Bit masks for the nail and number parts of a limb.  <code>GMP_NAIL_MASK</code> is 0
when nails are not in use.

<p><code>GMP_NAIL_MASK</code> is not often needed, since the nail part can be obtained
with <code>x &gt;&gt; GMP_NUMB_BITS</code>, and that means one less large constant, which
can help various RISC chips. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left"><b>GMP_NUMB_MAX</b><i>
</i></td>
<td align="right">Macro</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The maximum value that can be stored in the number part of a limb.  This is
the same as <code>GMP_NUMB_MASK</code>, but can be used for clarity when doing
comparisons rather than bit-wise operations. 
</td></tr>
</table>

<p>The term "nails" comes from finger or toe nails, which are at the ends of a
limb (arm or leg).  "numb" is short for number, but is also how the
developers felt after trying for a long time to come up with sensible names
for these things.

<p>In the future (the distant future most likely) a non-zero nail might be
permitted, giving non-unique representations for numbers in a limb vector. 
This would help vector processors since carries would only ever need to
propagate one or two limbs.

</body></html>

