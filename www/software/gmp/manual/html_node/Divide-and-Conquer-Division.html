<html lang="en">
<head>
<title>GNU MP 4.1</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name=description content="How to install and use the GNU multiple precision arithmetic library, version 4.1.">
<meta name=generator content="makeinfo 4.2">
<link href="http://www.gnu.org/software/texinfo/" rel=generator-home>
<!--
This manual describes how to install and use the GNU multiple precision
arithmetic library, version 4.1.

<p>Copyright 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
Free Software Foundation, Inc.

<p>Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.1 or any later
version published by the Free Software Foundation; with no Invariant Sections,
with the Front-Cover Texts being "A GNU Manual", and with the Back-Cover
Texts being "You have freedom to copy and modify this GNU Manual, like GNU
software".  A copy of the license is included in <a href="GNU-Free-Documentation-License.html#GNU%20Free%20Documentation%20License">GNU Free Documentation License</a>.-->
</head>
<body>
<p>
Node:<a name="Divide%20and%20Conquer%20Division">Divide and Conquer Division</a>,
Next:<a rel=next accesskey=n href="Exact-Division.html#Exact%20Division">Exact Division</a>,
Previous:<a rel=previous accesskey=p href="Basecase-Division.html#Basecase%20Division">Basecase Division</a>,
Up:<a rel=up accesskey=u href="Division-Algorithms.html#Division%20Algorithms">Division Algorithms</a>
<hr><br>

<h4>Divide and Conquer Division</h4>

<p>For divisors larger than <code>DIV_DC_THRESHOLD</code>, division is done by dividing. 
Or to be precise by a recursive divide and conquer algorithm based on work by
Moenck and Borodin, Jebelean, and Burnikel and Ziegler (see <a href="References.html#References">References</a>).

<p>The algorithm consists essentially of recognising that a 2NxN division
can be done with the basecase division algorithm (see <a href="Basecase-Division.html#Basecase%20Division">Basecase Division</a>),
but using N/2 limbs as a base, not just a single limb.  This way the
multiplications that arise are (N/2)x(N/2) and can take advantage of
Karatsuba and higher multiplication algorithms (see <a href="Multiplication-Algorithms.html#Multiplication%20Algorithms">Multiplication Algorithms</a>).  The "digits" of the quotient are formed by recursive
Nx(N/2) divisions.

<p>If the (N/2)x(N/2) multiplies are done with a basecase multiplication
then the work is about the same as a basecase division, but with more function
call overheads and with some subtractions separated from the multiplies. 
These overheads mean that it's only when N/2 is above
<code>MUL_KARATSUBA_THRESHOLD</code> that divide and conquer is of use.

<p><code>DIV_DC_THRESHOLD</code> is based on the divisor size N, so it will be somewhere
above twice <code>MUL_KARATSUBA_THRESHOLD</code>, but how much above depends on the
CPU.  An optimized <code>mpn_mul_basecase</code> can lower <code>DIV_DC_THRESHOLD</code> a
little by offering a ready-made advantage over repeated <code>mpn_submul_1</code>
calls.

<p>Divide and conquer is asymptotically O(M(N)*log(N)) where
M(N) is the time for an NxN multiplication done with FFTs.  The
actual time is a sum over multiplications of the recursed sizes, as can be
seen near the end of section 2.2 of Burnikel and Ziegler.  For example, within
the Toom-3 range, divide and conquer is 2.63*M(N).  With higher
algorithms the M(N) term improves and the multiplier tends to log(N).  In practice, at moderate to large sizes, a 2NxN division
is about 2 to 4 times slower than an NxN multiplication.

<p>Newton's method used for division is asymptotically O(M(N)) and should
therefore be superior to divide and conquer, but it's believed this would only
be for large to very large N.

</body></html>

