<html lang="en">
<head>
<title>GNU MP 4.1</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name=description content="How to install and use the GNU multiple precision arithmetic library, version 4.1.">
<meta name=generator content="makeinfo 4.2">
<link href="http://www.gnu.org/software/texinfo/" rel=generator-home>
<!--
This manual describes how to install and use the GNU multiple precision
arithmetic library, version 4.1.

<p>Copyright 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
Free Software Foundation, Inc.

<p>Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.1 or any later
version published by the Free Software Foundation; with no Invariant Sections,
with the Front-Cover Texts being "A GNU Manual", and with the Back-Cover
Texts being "You have freedom to copy and modify this GNU Manual, like GNU
software".  A copy of the license is included in <a href="GNU-Free-Documentation-License.html#GNU%20Free%20Documentation%20License">GNU Free Documentation License</a>.-->
</head>
<body>
<p>
Node:<a name="Number%20Theoretic%20Functions">Number Theoretic Functions</a>,
Next:<a rel=next accesskey=n href="Integer-Comparisons.html#Integer%20Comparisons">Integer Comparisons</a>,
Previous:<a rel=previous accesskey=p href="Integer-Roots.html#Integer%20Roots">Integer Roots</a>,
Up:<a rel=up accesskey=u href="Integer-Functions.html#Integer%20Functions">Integer Functions</a>
<hr><br>

<h3>Number Theoretic Functions</h3>

<p>
<table width="100%">
<tr>
<td align="left">int <b>mpz_probab_prime_p</b><i> (mpz_t <var>n</var>, int <var>reps</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Determine whether <var>n</var> is prime.  Return 2 if <var>n</var> is definitely prime,
return 1 if <var>n</var> is probably prime (without being certain), or return 0 if
<var>n</var> is definitely composite.

<p>This function does some trial divisions, then some Miller-Rabin probabilistic
primality tests.  <var>reps</var> controls how many such tests are done, 5 to 10 is
a reasonable number, more will reduce the chances of a composite being
returned as "probably prime".

<p>Miller-Rabin and similar tests can be more properly called compositeness
tests.  Numbers which fail are known to be composite but those which pass
might be prime or might be composite.  Only a few composites pass, hence those
which pass are considered probably prime. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpz_nextprime</b><i> (mpz_t <var>rop</var>, mpz_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>rop</var> to the next prime greater than <var>op</var>.

<p>This function uses a probabilistic algorithm to identify primes.  For
practical purposes it's adequate, the chance of a composite passing will be
extremely small. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpz_gcd</b><i> (mpz_t <var>rop</var>, mpz_t <var>op1</var>, mpz_t <var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>rop</var> to the greatest common divisor of <var>op1</var> and <var>op2</var>. 
The result is always positive even if one or both input operands
are negative. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">unsigned long int <b>mpz_gcd_ui</b><i> (mpz_t <var>rop</var>, mpz_t <var>op1</var>, unsigned long int <var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Compute the greatest common divisor of <var>op1</var> and <var>op2</var>.  If
<var>rop</var> is not <code>NULL</code>, store the result there.

<p>If the result is small enough to fit in an <code>unsigned long int</code>, it is
returned.  If the result does not fit, 0 is returned, and the result is equal
to the argument <var>op1</var>.  Note that the result will always fit if <var>op2</var>
is non-zero. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpz_gcdext</b><i> (mpz_t <var>g</var>, mpz_t <var>s</var>, mpz_t <var>t</var>, mpz_t <var>a</var>, mpz_t <var>b</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>g</var> to the greatest common divisor of <var>a</var> and <var>b</var>, and in
addition set <var>s</var> and <var>t</var> to coefficients satisfying
<var>a</var>*<var>s</var> + <var>b</var>*<var>t</var> = <var>g</var>. 
<var>g</var> is always positive, even if one or both of <var>a</var> and <var>b</var> are
negative.

<p>If <var>t</var> is <code>NULL</code> then that value is not computed. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpz_lcm</b><i> (mpz_t <var>rop</var>, mpz_t <var>op1</var>, mpz_t <var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpz_lcm_ui</b><i> (mpz_t <var>rop</var>, mpz_t <var>op1</var>, unsigned long <var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>rop</var> to the least common multiple of <var>op1</var> and <var>op2</var>. 
<var>rop</var> is always positive, irrespective of the signs of <var>op1</var> and
<var>op2</var>.  <var>rop</var> will be zero if either <var>op1</var> or <var>op2</var> is zero. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>mpz_invert</b><i> (mpz_t <var>rop</var>, mpz_t <var>op1</var>, mpz_t <var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Compute the inverse of <var>op1</var> modulo <var>op2</var> and put the result in
<var>rop</var>.  If the inverse exists, the return value is non-zero and <var>rop</var>
will satisfy 0 &lt;= <var>rop</var> &lt; <var>op2</var>.  If an inverse doesn't exist
the return value is zero and <var>rop</var> is undefined. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>mpz_jacobi</b><i> (mpz_t <var>a</var>, mpz_t <var>b</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Calculate the Jacobi symbol (<var>a</var>/<var>b</var>).  This is defined only for <var>b</var> odd. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>mpz_legendre</b><i> (mpz_t <var>a</var>, mpz_t <var>p</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Calculate the Legendre symbol (<var>a</var>/<var>p</var>).  This is defined only for <var>p</var> an odd positive
prime, and for such <var>p</var> it's identical to the Jacobi symbol. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>mpz_kronecker</b><i> (mpz_t <var>a</var>, mpz_t <var>b</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">int <b>mpz_kronecker_si</b><i> (mpz_t <var>a</var>, long <var>b</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">int <b>mpz_kronecker_ui</b><i> (mpz_t <var>a</var>, unsigned long <var>b</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">int <b>mpz_si_kronecker</b><i> (long <var>a</var>, mpz_t <var>b</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">int <b>mpz_ui_kronecker</b><i> (unsigned long <var>a</var>, mpz_t <var>b</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Calculate the Jacobi symbol (<var>a</var>/<var>b</var>) with the Kronecker extension (a/2)=(2/a) when a odd, or
(a/2)=0 when a even.

<p>When <var>b</var> is odd the Jacobi symbol and Kronecker symbol are
identical, so <code>mpz_kronecker_ui</code> etc can be used for mixed
precision Jacobi symbols too.

<p>For more information see Henri Cohen section 1.4.2 (see <a href="References.html#References">References</a>),
or any number theory textbook.  See also the example program
<code>demos/qcn.c</code> which uses <code>mpz_kronecker_ui</code>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">unsigned long int <b>mpz_remove</b><i> (mpz_t <var>rop</var>, mpz_t <var>op</var>, mpz_t <var>f</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Remove all occurrences of the factor <var>f</var> from <var>op</var> and store the
result in <var>rop</var>.  Return the multiplicity of <var>f</var> in <var>op</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpz_fac_ui</b><i> (mpz_t <var>rop</var>, unsigned long int <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>rop</var> to <var>op</var>!, the factorial of <var>op</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpz_bin_ui</b><i> (mpz_t <var>rop</var>, mpz_t <var>n</var>, unsigned long int <var>k</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpz_bin_uiui</b><i> (mpz_t <var>rop</var>, unsigned long int <var>n</var>, unsigned&nbsp;long&nbsp;int&nbsp;<var>k</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Compute the binomial coefficient <var>n</var> over
<var>k</var> and store the result in <var>rop</var>.  Negative values of <var>n</var> are
supported by <code>mpz_bin_ui</code>, using the identity
bin(-n,k) = (-1)^k * bin(n+k-1,k), see Knuth volume 1 section 1.2.6
part G. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpz_fib_ui</b><i> (mpz_t <var>fn</var>, unsigned long int <var>n</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpz_fib2_ui</b><i> (mpz_t <var>fn</var>, mpz_t <var>fnsub1</var>, unsigned long int <var>n</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
<code>mpz_fib_ui</code> sets <var>fn</var> to to F[n], the <var>n</var>'th Fibonacci
number.  <code>mpz_fib2_ui</code> sets <var>fn</var> to F[n], and <var>fnsub1</var> to
F[n-1].

<p>These functions are designed for calculating isolated Fibonacci numbers.  When
a sequence of values is wanted it's best to start with <code>mpz_fib2_ui</code> and
iterate the defining F[n+1]=F[n]+F[n-1] or
similar. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpz_lucnum_ui</b><i> (mpz_t <var>ln</var>, unsigned long int <var>n</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpz_lucnum2_ui</b><i> (mpz_t <var>ln</var>, mpz_t <var>lnsub1</var>, unsigned long int <var>n</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
<code>mpz_lucnum_ui</code> sets <var>ln</var> to to L[n], the <var>n</var>'th Lucas
number.  <code>mpz_lucnum2_ui</code> sets <var>ln</var> to L[n], and <var>lnsub1</var>
to L[n-1].

<p>These functions are designed for calculating isolated Lucas numbers.  When a
sequence of values is wanted it's best to start with <code>mpz_lucnum2_ui</code> and
iterate the defining L[n+1]=L[n]+L[n-1] or
similar.

<p>The Fibonacci numbers and Lucas numbers are related sequences, so it's never
necessary to call both <code>mpz_fib2_ui</code> and <code>mpz_lucnum2_ui</code>.  The
formulas for going from Fibonacci to Lucas can be found in <a href="Lucas-Numbers-Algorithm.html#Lucas%20Numbers%20Algorithm">Lucas Numbers Algorithm</a>, the reverse is straightforward too. 
</td></tr>
</table>

</body></html>

