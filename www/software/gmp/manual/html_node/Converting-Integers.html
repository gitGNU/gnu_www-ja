<html lang="en">
<head>
<title>GNU MP 4.1</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name=description content="How to install and use the GNU multiple precision arithmetic library, version 4.1.">
<meta name=generator content="makeinfo 4.2">
<link href="http://www.gnu.org/software/texinfo/" rel=generator-home>
<!--
This manual describes how to install and use the GNU multiple precision
arithmetic library, version 4.1.

<p>Copyright 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
Free Software Foundation, Inc.

<p>Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.1 or any later
version published by the Free Software Foundation; with no Invariant Sections,
with the Front-Cover Texts being "A GNU Manual", and with the Back-Cover
Texts being "You have freedom to copy and modify this GNU Manual, like GNU
software".  A copy of the license is included in <a href="GNU-Free-Documentation-License.html#GNU%20Free%20Documentation%20License">GNU Free Documentation License</a>.-->
</head>
<body>
<p>
Node:<a name="Converting%20Integers">Converting Integers</a>,
Next:<a rel=next accesskey=n href="Integer-Arithmetic.html#Integer%20Arithmetic">Integer Arithmetic</a>,
Previous:<a rel=previous accesskey=p href="Simultaneous-Integer-Init---Assign.html#Simultaneous%20Integer%20Init%20&amp;%20Assign">Simultaneous Integer Init & Assign</a>,
Up:<a rel=up accesskey=u href="Integer-Functions.html#Integer%20Functions">Integer Functions</a>
<hr><br>

<h3>Conversion Functions</h3>

<p>This section describes functions for converting GMP integers to standard C
types.  Functions for converting <em>to</em> GMP integers are described in
<a href="Assigning-Integers.html#Assigning%20Integers">Assigning Integers</a> and <a href="I-O-of-Integers.html#I%2fO%20of%20Integers">I/O of Integers</a>.

<p>
<table width="100%">
<tr>
<td align="left">unsigned long int <b>mpz_get_ui</b><i> (mpz_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Return the value of <var>op</var> as an <code>unsigned long</code>.

<p>If <var>op</var> is too big to fit an <code>unsigned long</code> then just the least
significant bits that do fit are returned.  The sign of <var>op</var> is ignored,
only the absolute value is used. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">signed long int <b>mpz_get_si</b><i> (mpz_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
If <var>op</var> fits into a <code>signed long int</code> return the value of <var>op</var>. 
Otherwise return the least significant part of <var>op</var>, with the same sign
as <var>op</var>.

<p>If <var>op</var> is too big to fit in a <code>signed long int</code>, the returned
result is probably not very useful.  To find out if the value will fit, use
the function <code>mpz_fits_slong_p</code>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">double <b>mpz_get_d</b><i> (mpz_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Convert <var>op</var> to a <code>double</code>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">double <b>mpz_get_d_2exp</b><i> (signed long int *<var>exp</var>, mpz_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Find <var>d</var> and <var>exp</var> such that <var>d</var> times 2
raised to <var>exp</var>, with 0.5&lt;=abs(<var>d</var>)&lt;1, is a good
approximation to <var>op</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">char * <b>mpz_get_str</b><i> (char *<var>str</var>, int <var>base</var>, mpz_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Convert <var>op</var> to a string of digits in base <var>base</var>.  The base may vary
from 2 to 36.

<p>If <var>str</var> is <code>NULL</code>, the result string is allocated using the current
allocation function (see <a href="Custom-Allocation.html#Custom%20Allocation">Custom Allocation</a>).  The block will be
<code>strlen(str)+1</code> bytes, that being exactly enough for the string and
null-terminator.

<p>If <var>str</var> is not <code>NULL</code>, it should point to a block of storage large
enough for the result, that being <code>mpz_sizeinbase (<var>op</var>, <var>base</var>)
+ 2</code>.  The two extra bytes are for a possible minus sign, and the
null-terminator.

<p>A pointer to the result string is returned, being either the allocated block,
or the given <var>str</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">mp_limb_t <b>mpz_getlimbn</b><i> (mpz_t <var>op</var>, mp_size_t <var>n</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Return limb number <var>n</var> from <var>op</var>.  The sign of <var>op</var> is ignored,
just the absolute value is used.  The least significant limb is number 0.

<p><code>mpz_size</code> can be used to find how many limbs make up <var>op</var>. 
<code>mpz_getlimbn</code> returns zero if <var>n</var> is outside the range 0 to
<code>mpz_size(<var>op</var>)-1</code>. 
</td></tr>
</table>

</body></html>

