<html lang="en">
<head>
<title>GNU MP 4.1</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name=description content="How to install and use the GNU multiple precision arithmetic library, version 4.1.">
<meta name=generator content="makeinfo 4.2">
<link href="http://www.gnu.org/software/texinfo/" rel=generator-home>
<!--
This manual describes how to install and use the GNU multiple precision
arithmetic library, version 4.1.

<p>Copyright 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
Free Software Foundation, Inc.

<p>Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.1 or any later
version published by the Free Software Foundation; with no Invariant Sections,
with the Front-Cover Texts being "A GNU Manual", and with the Back-Cover
Texts being "You have freedom to copy and modify this GNU Manual, like GNU
software".  A copy of the license is included in <a href="GNU-Free-Documentation-License.html#GNU%20Free%20Documentation%20License">GNU Free Documentation License</a>.-->
</head>
<body>
<p>
Node:<a name="Assembler%20Floating%20Point">Assembler Floating Point</a>,
Next:<a rel=next accesskey=n href="Assembler-SIMD-Instructions.html#Assembler%20SIMD%20Instructions">Assembler SIMD Instructions</a>,
Previous:<a rel=previous accesskey=p href="Assembler-Cache-Handling.html#Assembler%20Cache%20Handling">Assembler Cache Handling</a>,
Up:<a rel=up accesskey=u href="Assembler-Coding.html#Assembler%20Coding">Assembler Coding</a>
<hr><br>

<h4>Floating Point</h4>

<p>Floating point arithmetic is used in GMP for multiplications on CPUs with poor
integer multipliers.  It's mostly useful for <code>mpn_mul_1</code>,
<code>mpn_addmul_1</code> and <code>mpn_submul_1</code> on 64-bit machines, and
<code>mpn_mul_basecase</code> on both 32-bit and 64-bit machines.

<p>With IEEE 53-bit double precision floats, integer multiplications producing up
to 53 bits will give exact results.  Breaking a 64x64 multiplication
into eight 16x32-&gt;48 bit pieces is convenient.  With
some care though six 21x32-&gt;53 bit products can be
used, if one of the lower two 21-bit pieces also uses the sign bit.

<p>For the <code>mpn_mul_1</code> family of functions on a 64-bit machine, the
invariant single limb is split at the start, into 3 or 4 pieces.  Inside the
loop, the bignum operand is split into 32-bit pieces.  Fast conversion of
these unsigned 32-bit pieces to floating point is highly machine-dependent. 
In some cases, reading the data into the integer unit, zero-extending to
64-bits, then transferring to the floating point unit back via memory is the
only option.

<p>Converting partial products back to 64-bit limbs is usually best done as a
signed conversion.  Since all values are smaller than 2^53, signed
and unsigned are the same, but most processors lack unsigned conversions.

<br><p>
<br><p>
<p>Here is a diagram showing 16x32 bit products for an <code>mpn_mul_1</code> or
<code>mpn_addmul_1</code> with a 64-bit limb.  The single limb operand V is split
into four 16-bit parts.  The multi-limb operand U is split in the loop into
two 32-bit parts.

<br><pre>                +---+---+---+---+
                |v48|v32|v16|v00|    V operand
                +---+---+---+---+

                +-------+---+---+
            x   |  u32  |  u00  |    U operand (one limb)
                +---------------+

---------------------------------

                    +-----------+
                    | u00 x v00 |    p00    48-bit products
                    +-----------+
                +-----------+
                | u00 x v16 |        p16
                +-----------+
            +-----------+
            | u00 x v32 |            p32
            +-----------+
        +-----------+
        | u00 x v48 |                p48
        +-----------+
            +-----------+
            | u32 x v00 |            r32
            +-----------+
        +-----------+
        | u32 x v16 |                r48
        +-----------+
    +-----------+
    | u32 x v32 |                    r64
    +-----------+
+-----------+
| u32 x v48 |                        r80
+-----------+
</pre>

<p>p32 and r32 can be summed using floating-point addition, and
likewise p48 and r48.  p00 and p16 can be summed
with r64 and r80 from the previous iteration.

<p>For each loop then, four 49-bit quantities are transfered to the integer unit,
aligned as follows,

<br><pre>|-----64bits----|-----64bits----|
                   +------------+
                   | p00 + r64' |    i00
                   +------------+
               +------------+
               | p16 + r80' |        i16
               +------------+
           +------------+
           | p32 + r32  |            i32
           +------------+
       +------------+
       | p48 + r48  |                i48
       +------------+
</pre>

<p>The challenge then is to sum these efficiently and add in a carry limb,
generating a low 64-bit result limb and a high 33-bit carry limb (i48
extends 33 bits into the high half).

</body></html>

