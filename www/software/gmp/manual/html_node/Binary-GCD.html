<html lang="en">
<head>
<title>GNU MP 4.1</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name=description content="How to install and use the GNU multiple precision arithmetic library, version 4.1.">
<meta name=generator content="makeinfo 4.2">
<link href="http://www.gnu.org/software/texinfo/" rel=generator-home>
<!--
This manual describes how to install and use the GNU multiple precision
arithmetic library, version 4.1.

<p>Copyright 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
Free Software Foundation, Inc.

<p>Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.1 or any later
version published by the Free Software Foundation; with no Invariant Sections,
with the Front-Cover Texts being "A GNU Manual", and with the Back-Cover
Texts being "You have freedom to copy and modify this GNU Manual, like GNU
software".  A copy of the license is included in <a href="GNU-Free-Documentation-License.html#GNU%20Free%20Documentation%20License">GNU Free Documentation License</a>.-->
</head>
<body>
<p>
Node:<a name="Binary%20GCD">Binary GCD</a>,
Next:<a rel=next accesskey=n href="Accelerated-GCD.html#Accelerated%20GCD">Accelerated GCD</a>,
Previous:<a rel=previous accesskey=p href="Greatest-Common-Divisor-Algorithms.html#Greatest%20Common%20Divisor%20Algorithms">Greatest Common Divisor Algorithms</a>,
Up:<a rel=up accesskey=u href="Greatest-Common-Divisor-Algorithms.html#Greatest%20Common%20Divisor%20Algorithms">Greatest Common Divisor Algorithms</a>
<hr><br>

<h4>Binary GCD</h4>

<p>At small sizes GMP uses an O(N^2) binary style GCD.  This is described
in many textbooks, for example Knuth section 4.5.2 algorithm B.  It simply
consists of successively reducing operands a and b using
gcd(a,b) = gcd(min(a,b),abs(a-b)), and also that if
a and b are first made odd then abs(a-b) is even and
factors of two can be discarded.

<p>Variants like letting a-b become negative and doing a different next
step are of interest only as far as they suit particular CPUs, since on small
operands it's machine dependent factors that determine performance.

<p>The Euclidean GCD algorithm, as per Knuth algorithms E and A, reduces using
a mod b but this has so far been found to be slower everywhere.  One
reason the binary method does well is that the implied quotient at each step
is usually small, so often only one or two subtractions are needed to get the
same effect as a division.  Quotients 1, 2 and 3 for example occur 67.7% of
the time, see Knuth section 4.5.3 Theorem E.

<p>When the implied quotient is large, meaning b is much smaller than
a, then a division is worthwhile.  This is the basis for the initial
a mod b reductions in <code>mpn_gcd</code> and <code>mpn_gcd_1</code> (the latter
for both Nx1 and 1x1 cases).  But after that initial reduction,
big quotients occur too rarely to make it worth checking for them.

</body></html>

