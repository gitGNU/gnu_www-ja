<html lang="en">
<head>
<title>GNU MP 4.1</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name=description content="How to install and use the GNU multiple precision arithmetic library, version 4.1.">
<meta name=generator content="makeinfo 4.2">
<link href="http://www.gnu.org/software/texinfo/" rel=generator-home>
<!--
This manual describes how to install and use the GNU multiple precision
arithmetic library, version 4.1.

<p>Copyright 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
Free Software Foundation, Inc.

<p>Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.1 or any later
version published by the Free Software Foundation; with no Invariant Sections,
with the Front-Cover Texts being "A GNU Manual", and with the Back-Cover
Texts being "You have freedom to copy and modify this GNU Manual, like GNU
software".  A copy of the license is included in <a href="GNU-Free-Documentation-License.html#GNU%20Free%20Documentation%20License">GNU Free Documentation License</a>.-->
</head>
<body>
<p>
Node:<a name="Radix%20to%20Binary">Radix to Binary</a>,
Previous:<a rel=previous accesskey=p href="Binary-to-Radix.html#Binary%20to%20Radix">Binary to Radix</a>,
Up:<a rel=up accesskey=u href="Radix-Conversion-Algorithms.html#Radix%20Conversion%20Algorithms">Radix Conversion Algorithms</a>
<hr><br>

<h4>Radix to Binary</h4>

<p>Conversions from a power-of-2 radix into binary use a simple and fast
O(N) bitwise concatenation algorithm.

<p>Conversions from other radices use one of two algorithms.  Sizes below
<code>SET_STR_THRESHOLD</code> use a basic O(N^2) method.  Groups of n
digits are converted to limbs, where n is the biggest power of the base
b which will fit in a limb, then those groups are accumulated into the
result by multiplying by b^n and adding.  This saves multi-precision
operations, as per Knuth section 4.4 part E (see <a href="References.html#References">References</a>).  Some
special case code is provided for decimal, giving the compiler a chance to
optimize multiplications by 10.

<p>Above <code>SET_STR_THRESHOLD</code> a sub-quadratic algorithm is used.  First
groups of n digits are converted into limbs.  Then adjacent limbs are
combined into limb pairs with x*b^n+y, where x and y
are the limbs.  Adjacent limb pairs are combined into quads similarly with
x*b^(2n)+y.  This continues until a single block remains, that
being the result.

<p>The advantage of this method is that the multiplications for each x are
big blocks, allowing Karatsuba and higher algorithms to be used.  But the cost
of calculating the powers b^(n*2^i) must be overcome. 
<code>SET_STR_THRESHOLD</code> usually ends up quite big, around 5000 digits, and on
some processors much bigger still.

<p><code>SET_STR_THRESHOLD</code> is based on the input digits (and tuned for decimal),
though it might be better based on a limb count, so as to be independent of
the base.  But that sort of count isn't used by the base case and so would
need some sort of initial calculation or estimate.

<p>The main reason <code>SET_STR_THRESHOLD</code> is so much bigger than the
corresponding <code>GET_STR_PRECOMPUTE_THRESHOLD</code> is that <code>mpn_mul_1</code> is
much faster than <code>mpn_divrem_1</code> (often by a factor of 10, or more).

</body></html>

