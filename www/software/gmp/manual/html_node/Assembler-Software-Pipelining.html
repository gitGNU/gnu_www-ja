<html lang="en">
<head>
<title>GNU MP 4.1</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name=description content="How to install and use the GNU multiple precision arithmetic library, version 4.1.">
<meta name=generator content="makeinfo 4.2">
<link href="http://www.gnu.org/software/texinfo/" rel=generator-home>
<!--
This manual describes how to install and use the GNU multiple precision
arithmetic library, version 4.1.

<p>Copyright 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
Free Software Foundation, Inc.

<p>Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.1 or any later
version published by the Free Software Foundation; with no Invariant Sections,
with the Front-Cover Texts being "A GNU Manual", and with the Back-Cover
Texts being "You have freedom to copy and modify this GNU Manual, like GNU
software".  A copy of the license is included in <a href="GNU-Free-Documentation-License.html#GNU%20Free%20Documentation%20License">GNU Free Documentation License</a>.-->
</head>
<body>
<p>
Node:<a name="Assembler%20Software%20Pipelining">Assembler Software Pipelining</a>,
Next:<a rel=next accesskey=n href="Assembler-Loop-Unrolling.html#Assembler%20Loop%20Unrolling">Assembler Loop Unrolling</a>,
Previous:<a rel=previous accesskey=p href="Assembler-SIMD-Instructions.html#Assembler%20SIMD%20Instructions">Assembler SIMD Instructions</a>,
Up:<a rel=up accesskey=u href="Assembler-Coding.html#Assembler%20Coding">Assembler Coding</a>
<hr><br>

<h4>Software Pipelining</h4>

<p>Software pipelining consists of scheduling instructions around the branch
point in a loop.  For example a loop taking a checksum of an array of limbs
might have a load and an add, but the load wouldn't be for that add, rather
for the one next time around the loop.  Each load then is effectively
scheduled back in the previous iteration, allowing latency to be hidden.

<p>Naturally this is wanted only when doing things like loads or multiplies that
take a few cycles to complete, and only where a CPU has multiple functional
units so that other work can be done while waiting.

<p>A pipeline with several stages will have a data value in progress at each
stage and each loop iteration moves them along one stage.  This is like
juggling.

<p>Within the loop some moves between registers may be necessary to have the
right values in the right places for each iteration.  Loop unrolling can help
this, with each unrolled block able to use different registers for different
values, even if some shuffling is still needed just before going back to the
top of the loop.

</body></html>

