<html lang="en">
<head>
<title>GNU MP 4.1</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name=description content="How to install and use the GNU multiple precision arithmetic library, version 4.1.">
<meta name=generator content="makeinfo 4.2">
<link href="http://www.gnu.org/software/texinfo/" rel=generator-home>
<!--
This manual describes how to install and use the GNU multiple precision
arithmetic library, version 4.1.

<p>Copyright 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
Free Software Foundation, Inc.

<p>Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.1 or any later
version published by the Free Software Foundation; with no Invariant Sections,
with the Front-Cover Texts being "A GNU Manual", and with the Back-Cover
Texts being "You have freedom to copy and modify this GNU Manual, like GNU
software".  A copy of the license is included in <a href="#GNU%20Free%20Documentation%20License">GNU Free Documentation License</a>.-->
</head>
<body>
<h1>GNU MP 4.1</h1>
<p><hr>
Node:<a name="Top">Top</a>,
Next:<a rel=next accesskey=n href="#Copying">Copying</a>,
Previous:<a rel=previous accesskey=p href="#dir">(dir)</a>,
Up:<a rel=up accesskey=u href="#dir">(dir)</a>
<br>

<h2>GNU MP</h2>

This manual describes how to install and use the GNU multiple precision
arithmetic library, version 4.1.

<p>Copyright 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
Free Software Foundation, Inc.

<p>Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.1 or any later
version published by the Free Software Foundation; with no Invariant Sections,
with the Front-Cover Texts being "A GNU Manual", and with the Back-Cover
Texts being "You have freedom to copy and modify this GNU Manual, like GNU
software".  A copy of the license is included in <a href="#GNU%20Free%20Documentation%20License">GNU Free Documentation License</a>.
<br><p>
<ul>
<li><a accesskey=1 href="#Copying">Copying</a>:                     GMP Copying Conditions (LGPL). 
<li><a accesskey=2 href="#Introduction%20to%20GMP">Introduction to GMP</a>:         Brief introduction to GNU MP. 
<li><a accesskey=3 href="#Installing%20GMP">Installing GMP</a>:              How to configure and compile the GMP library. 
<li><a accesskey=4 href="#GMP%20Basics">GMP Basics</a>:                  What every GMP user should know. 
<li><a accesskey=5 href="#Reporting%20Bugs">Reporting Bugs</a>:              How to usefully report bugs. 
<li><a accesskey=6 href="#Integer%20Functions">Integer Functions</a>:           Functions for arithmetic on signed integers. 
<li><a accesskey=7 href="#Rational%20Number%20Functions">Rational Number Functions</a>:   Functions for arithmetic on rational numbers. 
<li><a accesskey=8 href="#Floating-point%20Functions">Floating-point Functions</a>:    Functions for arithmetic on floats. 
<li><a accesskey=9 href="#Low-level%20Functions">Low-level Functions</a>:         Fast functions for natural numbers. 
<li><a href="#Random%20Number%20Functions">Random Number Functions</a>:     Functions for generating random numbers. 
<li><a href="#Formatted%20Output">Formatted Output</a>:            <code>printf</code> style output. 
<li><a href="#Formatted%20Input">Formatted Input</a>:             <code>scanf</code> style input. 
<li><a href="#C++%20Class%20Interface">C++ Class Interface</a>:         Class wrappers around GMP types. 
<li><a href="#BSD%20Compatible%20Functions">BSD Compatible Functions</a>:    All functions found in BSD MP. 
<li><a href="#Custom%20Allocation">Custom Allocation</a>:           How to customize the internal allocation. 
<li><a href="#Language%20Bindings">Language Bindings</a>:           Using GMP from other languages. 
<li><a href="#Algorithms">Algorithms</a>:                  What happens behind the scenes. 
<li><a href="#Internals">Internals</a>:                   How values are represented behind the scenes.

<p>
</p><li><a href="#Contributors">Contributors</a>: 	       Who brings your this library? 
<li><a href="#References">References</a>:                  Some useful papers and books to read. 
<li><a href="#GNU%20Free%20Documentation%20License">GNU Free Documentation License</a>: 
<li><a href="#Concept%20Index">Concept Index</a>: 
<li><a href="#Function%20Index">Function Index</a>: 
</ul>

<p><hr>
Node:<a name="Copying">Copying</a>,
Next:<a rel=next accesskey=n href="#Introduction%20to%20GMP">Introduction to GMP</a>,
Previous:<a rel=previous accesskey=p href="#Top">Top</a>,
Up:<a rel=up accesskey=u href="#Top">Top</a>
<br>

<h2>GNU MP Copying Conditions</h2>

<p>This library is <dfn>free</dfn>; this means that everyone is free to use it and
free to redistribute it on a free basis.  The library is not in the public
domain; it is copyrighted and there are restrictions on its distribution, but
these restrictions are designed to permit everything that a good cooperating
citizen would want to do.  What is not allowed is to try to prevent others
from further sharing any version of this library that they might get from
you.

<p>Specifically, we want to make sure that you have the right to give away copies
of the library, that you receive source code or else can get it if you want
it, that you can change this library or use pieces of it in new free programs,
and that you know you can do these things.

<p>To make sure that everyone has such rights, we have to forbid you to deprive
anyone else of these rights.  For example, if you distribute copies of the GNU
MP library, you must give the recipients all the rights that you have.  You
must make sure that they, too, receive or can get the source code.  And you
must tell them their rights.

<p>Also, for our own protection, we must make certain that everyone finds out
that there is no warranty for the GNU MP library.  If it is modified by
someone else and passed on, we want their recipients to know that what they
have is not what we distributed, so that any problems introduced by others
will not reflect on our reputation.

<p>The precise conditions of the license for the GNU MP library are found in the
Lesser General Public License version 2.1 that accompanies the source code,
see <code>COPYING.LIB</code>.  Certain demonstration programs are provided under the
terms of the plain General Public License version 2, see <code>COPYING</code>.

<p><hr>
Node:<a name="Introduction%20to%20GMP">Introduction to GMP</a>,
Next:<a rel=next accesskey=n href="#Installing%20GMP">Installing GMP</a>,
Previous:<a rel=previous accesskey=p href="#Copying">Copying</a>,
Up:<a rel=up accesskey=u href="#Top">Top</a>
<br>

<h2>Introduction to GNU MP</h2>

<p>GNU MP is a portable library written in C for arbitrary precision arithmetic
on integers, rational numbers, and floating-point numbers.  It aims to provide
the fastest possible arithmetic for all applications that need higher
precision than is directly supported by the basic C types.

<p>Many applications use just a few hundred bits of precision; but some
applications may need thousands or even millions of bits.  GMP is designed to
give good performance for both, by choosing algorithms based on the sizes of
the operands, and by carefully keeping the overhead at a minimum.

<p>The speed of GMP is achieved by using fullwords as the basic arithmetic type,
by using sophisticated algorithms, by including carefully optimized assembly
code for the most common inner loops for many different CPUs, and by a general
emphasis on speed (as opposed to simplicity or elegance).

<p>There is carefully optimized assembly code for these CPUs:
ARM,
DEC Alpha 21064, 21164, and 21264,
AMD 29000,
AMD K6, K6-2 and Athlon,
Hitachi SuperH and SH-2,
HPPA 1.0, 1.1 and 2.0,
Intel Pentium, Pentium Pro/II/III, Pentium 4, generic x86,
Intel IA-64, i960,
Motorola MC68000, MC68020, MC88100, and MC88110,
Motorola/IBM PowerPC 32 and 64,
National NS32000,
IBM POWER,
MIPS R3000, R4000,
SPARCv7, SuperSPARC, generic SPARCv8, UltraSPARC,
DEC VAX,
and
Zilog Z8000. 
Some optimizations also for
Cray vector systems,
Clipper,
IBM ROMP (RT),
and
Pyramid AP/XP.

<p>There is a mailing list for GMP users.  To join it, send a mail to
<a href="mailto:gmp-request@swox.com">gmp-request@swox.com</a> with the word <code>subscribe</code> in the message
<strong>body</strong> (not in the subject line).

<p>For up-to-date information on GMP, please see the GMP web pages at

<br><pre><a href="http://swox.com/gmp/">http://swox.com/gmp/</a>
</pre>

<p>The latest version of the library is available at

<br><pre><a href="ftp://ftp.gnu.org/gnu/gmp">ftp://ftp.gnu.org/gnu/gmp</a>
</pre>

<p>Many sites around the world mirror <code>ftp.gnu.org</code>, please use a mirror
near you, see <a href="http://www.gnu.org/order/ftp.html">http://www.gnu.org/order/ftp.html</a> for a full list.

<h3>How to use this Manual</h3>

<p>Everyone should read <a href="#GMP%20Basics">GMP Basics</a>.  If you need to install the library
yourself, then read <a href="#Installing%20GMP">Installing GMP</a>.  If you have a system with multiple
ABIs, then read <a href="#ABI%20and%20ISA">ABI and ISA</a>, for the compiler options that must be used
on applications.

<p>The rest of the manual can be used for later reference, although it is
probably a good idea to glance through it.

<p><hr>
Node:<a name="Installing%20GMP">Installing GMP</a>,
Next:<a rel=next accesskey=n href="#GMP%20Basics">GMP Basics</a>,
Previous:<a rel=previous accesskey=p href="#Introduction%20to%20GMP">Introduction to GMP</a>,
Up:<a rel=up accesskey=u href="#Top">Top</a>
<br>

<h2>Installing GMP</h2>

<p>GMP has an autoconf/automake/libtool based configuration system.  On a
Unix-like system a basic build can be done with

<br><pre>./configure
make
</pre>

<p>Some self-tests can be run with

<br><pre>make check
</pre>

<p>And you can install (under <code>/usr/local</code> by default) with

<br><pre>make install
</pre>

<p>If you experience problems, please report them to <a href="mailto:bug-gmp@gnu.org">bug-gmp@gnu.org</a>. 
See <a href="#Reporting%20Bugs">Reporting Bugs</a>, for information on what to include in useful bug
reports.

<ul>
<li><a accesskey=1 href="#Build%20Options">Build Options</a>: 
<li><a accesskey=2 href="#ABI%20and%20ISA">ABI and ISA</a>: 
<li><a accesskey=3 href="#Notes%20for%20Package%20Builds">Notes for Package Builds</a>: 
<li><a accesskey=4 href="#Notes%20for%20Particular%20Systems">Notes for Particular Systems</a>: 
<li><a accesskey=5 href="#Known%20Build%20Problems">Known Build Problems</a>: 
</ul>

<p><hr>
Node:<a name="Build%20Options">Build Options</a>,
Next:<a rel=next accesskey=n href="#ABI%20and%20ISA">ABI and ISA</a>,
Previous:<a rel=previous accesskey=p href="#Installing%20GMP">Installing GMP</a>,
Up:<a rel=up accesskey=u href="#Installing%20GMP">Installing GMP</a>
<br>

<h3>Build Options</h3>

<p>All the usual autoconf configure options are available, run <code>./configure
--help</code> for a summary.  The file <code>INSTALL.autoconf</code> has some generic
installation information too.

<dl>
<dt>Non-Unix Systems
<dd>
<code>configure</code> requires various Unix-like tools.  On an MS-DOS system DJGPP
can be used, and on MS Windows Cygwin or MINGW can be used,

<br><pre><a href="http://www.cygnus.com/cygwin">http://www.cygnus.com/cygwin</a>
<a href="http://www.delorie.com/djgpp">http://www.delorie.com/djgpp</a>
<a href="http://www.mingw.org">http://www.mingw.org</a>
</pre>

<p>The <code>macos</code> directory contains an unsupported port to MacOS 9 on Power
Macintosh, see <code>macos/README</code>.  Note that MacOS X "Darwin" should use
the normal Unix-style <code>./configure</code>.

<p>It might be possible to build without the help of <code>configure</code>, certainly
all the code is there, but unfortunately you'll be on your own.

<br><dt>Build Directory
<dd>
To compile in a separate build directory, <code>cd</code> to that directory, and
prefix the configure command with the path to the GMP source directory.  For
example

<br><pre>cd /my/build/dir
/my/sources/gmp-4.1/configure
</pre>

<p>Not all <code>make</code> programs have the necessary features (<code>VPATH</code>) to
support this.  In particular, SunOS and Slowaris <code>make</code> have bugs that
make them unable to build in a separate directory.  Use GNU <code>make</code>
instead.

<br><dt><code>--disable-shared</code>, <code>--disable-static</code>
<dd>
By default both shared and static libraries are built (where possible), but
one or other can be disabled.  Shared libraries result in smaller executables
and permit code sharing between separate running processes, but on some CPUs
are slightly slower, having a small cost on each function call.

<br><dt>Native Compilation, <code>--build=CPU-VENDOR-OS</code>
<dd>
For normal native compilation, the system can be specified with
<code>--build</code>.  By default <code>./configure</code> uses the output from running
<code>./config.guess</code>.  On some systems <code>./config.guess</code> can determine
the exact CPU type, on others it will be necessary to give it explicitly.  For
example,

<br><pre>./configure --build=ultrasparc-sun-solaris2.7
</pre>

<p>In all cases the <code>OS</code> part is important, since it controls how libtool
generates shared libraries.  Running <code>./config.guess</code> is the simplest way
to see what it should be, if you don't know already.

<br><dt>Cross Compilation, <code>--host=CPU-VENDOR-OS</code>
<dd>
When cross-compiling, the system used for compiling is given by <code>--build</code>
and the system where the library will run is given by <code>--host</code>.  For
example when using a FreeBSD Athlon system to build GNU/Linux m68k binaries,

<br><pre>./configure --build=athlon-pc-freebsd3.5 --host=m68k-mac-linux-gnu
</pre>

<p>Compiler tools are sought first with the host system type as a prefix.  For
example <code>m68k-mac-linux-gnu-ranlib</code> is tried, then plain
<code>ranlib</code>.  This makes it possible for a set of cross-compiling tools
to co-exist with native tools.  The prefix is the argument to <code>--host</code>,
and this can be an alias, such as <code>m68k-linux</code>.  But note that tools
don't have to be setup this way, it's enough to just have a <code>PATH</code> with a
suitable cross-compiling <code>cc</code> etc.

<p>Compiling for a different CPU in the same family as the build system is a form
of cross-compilation, though very possibly this would merely be special
options on a native compiler.  In any case <code>./configure</code> avoids depending
on being able to run code on the build system, which is important when
creating binaries for a newer CPU since they very possibly won't run on the
build system.

<p>In all cases the compiler must be able to produce an executable (of whatever
format) from a standard C <code>main</code>.  Although only object files will go to
make up <code>libgmp</code>, <code>./configure</code> uses linking tests for various
purposes, such as determining what functions are available on the host system.

<p>Currently a warning is given unless an explicit <code>--build</code> is used when
cross-compiling, because it may not be possible to correctly guess the build
system type if the <code>PATH</code> has only a cross-compiling <code>cc</code>.

<p>Note that the <code>--target</code> option is not appropriate for GMP.  It's for use
when building compiler tools, with <code>--host</code> being where they will run,
and <code>--target</code> what they'll produce code for.  Ordinary programs or
libraries like GMP are only interested in the <code>--host</code> part, being where
they'll run.  (Some past versions of GMP used <code>--target</code> incorrectly.)

<br><dt>CPU types
<dd>
In general, if you want a library that runs as fast as possible, you should
configure GMP for the exact CPU type your system uses.  However, this may mean
the binaries won't run on older members of the family, and might run slower on
other members, older or newer.  The best idea is always to build GMP for the
exact machine type you intend to run it on.

<p>The following CPUs have specific support.  See <code>configure.in</code> for details
of what code and compiler options they select.

<ul>

<li>Alpha:
<code>alpha</code>,
<code>alphaev5</code>,
<code>alphaev56</code>,
<code>alphapca56</code>,
<code>alphapca57</code>,
<code>alphaev6</code>,
<code>alphaev67</code>,
<code>alphaev68</code>

<li>Cray:
<code>c90</code>,
<code>j90</code>,
<code>t90</code>,
<code>sv1</code>

<li>HPPA:
<code>hppa1.0</code>,
<code>hppa1.1</code>,
<code>hppa2.0</code>,
<code>hppa2.0n</code>,
<code>hppa2.0w</code>

<li>MIPS:
<code>mips</code>,
<code>mips3</code>,
<code>mips64</code>

<li>Motorola:
<code>m68k</code>,
<code>m68000</code>,
<code>m68010</code>,
<code>m68020</code>,
<code>m68030</code>,
<code>m68040</code>,
<code>m68060</code>,
<code>m68302</code>,
<code>m68360</code>,
<code>m88k</code>,
<code>m88110</code>

<li>POWER:
<code>power</code>,
<code>power1</code>,
<code>power2</code>,
<code>power2sc</code>

<li>PowerPC:
<code>powerpc</code>,
<code>powerpc64</code>,
<code>powerpc401</code>,
<code>powerpc403</code>,
<code>powerpc405</code>,
<code>powerpc505</code>,
<code>powerpc601</code>,
<code>powerpc602</code>,
<code>powerpc603</code>,
<code>powerpc603e</code>,
<code>powerpc604</code>,
<code>powerpc604e</code>,
<code>powerpc620</code>,
<code>powerpc630</code>,
<code>powerpc740</code>,
<code>powerpc7400</code>,
<code>powerpc7450</code>,
<code>powerpc750</code>,
<code>powerpc801</code>,
<code>powerpc821</code>,
<code>powerpc823</code>,
<code>powerpc860</code>,

<li>SPARC:
<code>sparc</code>,
<code>sparcv8</code>,
<code>microsparc</code>,
<code>supersparc</code>,
<code>sparcv9</code>,
<code>ultrasparc</code>,
<code>ultrasparc2</code>,
<code>ultrasparc2i</code>,
<code>ultrasparc3</code>,
<code>sparc64</code>

<li>80x86 family:
<code>i386</code>,
<code>i486</code>,
<code>i586</code>,
<code>pentium</code>,
<code>pentiummmx</code>,
<code>pentiumpro</code>,
<code>pentium2</code>,
<code>pentium3</code>,
<code>pentium4</code>,
<code>k6</code>,
<code>k62</code>,
<code>k63</code>,
<code>athlon</code>

<li>Other:
<code>a29k</code>,
<code>arm</code>,
<code>clipper</code>,
<code>i960</code>,
<code>ns32k</code>,
<code>pyramid</code>,
<code>sh</code>,
<code>sh2</code>,
<code>vax</code>,
<code>z8k</code>
</ul>

<p>CPUs not listed will use generic C code.

<br><dt>Generic C Build
<dd>
If some of the assembly code causes problems, or if otherwise desired, the
generic C code can be selected with CPU <code>none</code>.  For example,

<br><pre>./configure --host=none-unknown-freebsd3.5
</pre>

<p>Note that this will run quite slowly, but it should be portable and should at
least make it possible to get something running if all else fails.

<br><dt><code>ABI</code>
<dd>
On some systems GMP supports multiple ABIs (application binary interfaces),
meaning data type sizes and calling conventions.  By default GMP chooses the
best ABI available, but a particular ABI can be selected.  For example

<br><pre>./configure --host=mips64-sgi-irix6 ABI=n32
</pre>

<p>See <a href="#ABI%20and%20ISA">ABI and ISA</a>, for the available choices on relevant CPUs, and what
applications need to do.

<br><dt><code>CC</code>, <code>CFLAGS</code>
<dd>
By default the C compiler used is chosen from among some likely candidates,
with <code>gcc</code> normally preferred if it's present.  The usual
<code>CC=whatever</code> can be passed to <code>./configure</code> to choose something
different.

<p>For some systems, default compiler flags are set based on the CPU and
compiler.  The usual <code>CFLAGS="-whatever"</code> can be passed to
<code>./configure</code> to use something different or to set good flags for systems
GMP doesn't otherwise know.

<p>The <code>CC</code> and <code>CFLAGS</code> used are printed during <code>./configure</code>,
and can be found in each generated <code>Makefile</code>.  This is the easiest way
to check the defaults when considering changing or adding something.

<p>Note that when <code>CC</code> and <code>CFLAGS</code> are specified on a system
supporting multiple ABIs it's important to give an explicit
<code>ABI=whatever</code>, since GMP can't determine the ABI just from the flags and
won't be able to select the correct assembler code.

<p>If just <code>CC</code> is selected then normal default <code>CFLAGS</code> for that
compiler will be used (if GMP recognises it).  For example <code>CC=gcc</code> can
be used to force the use of GCC, with default flags (and default ABI).

<br><dt><code>CPPFLAGS</code>
<dd>
Any flags like <code>-D</code> defines or <code>-I</code> includes required by the
preprocessor should be set in <code>CPPFLAGS</code> rather than <code>CFLAGS</code>. 
Compiling is done with both <code>CPPFLAGS</code> and <code>CFLAGS</code>, but
preprocessing uses just <code>CPPFLAGS</code>.  This distinction is because most
preprocessors won't accept all the flags the compiler does.  Preprocessing is
done separately in some configure tests, and in the <code>ansi2knr</code> support
for K&amp;R compilers.

<br><dt>C++ Support, <code>--enable-cxx</code>
<dd>C++ support in GMP can be enabled with <code>--enable-cxx</code>, in which case a
C++ compiler will be required.  As a convenience <code>--enable-cxx=detect</code>
can be used to enable C++ support only if a compiler can be found.  The C++
support consists of a library <code>libgmpxx.la</code> and header file
<code>gmpxx.h</code>.

<p>A separate <code>libgmpxx.la</code> has been adopted rather than having C++ objects
within <code>libgmp.la</code> in order to ensure dynamic linked C programs aren't
bloated by a dependency on the C++ standard library, and to avoid any chance
that the C++ compiler could be required when linking plain C programs.

<p><code>libgmpxx.la</code> will use certain internals from <code>libgmp.la</code> and can
only be expected to work with <code>libgmp.la</code> from the same GMP version. 
Future changes to the relevant internals will be accompanied by renaming, so a
mismatch will cause unresolved symbols rather than perhaps mysterious
misbehaviour.

<p>In general <code>libgmpxx.la</code> will be usable only with the C++ compiler that
built it, since name mangling and runtime support are usually incompatible
between different compilers.

<br><dt><code>CXX</code>, <code>CXXFLAGS</code>
<dd>When C++ support is enabled, the C++ compiler and its flags can be set with
variables <code>CXX</code> and <code>CXXFLAGS</code> in the usual way.  The default for
<code>CXX</code> is the first compiler that works from a list of likely candidates,
with <code>g++</code> normally preferred when available.  The default for
<code>CXXFLAGS</code> is to try <code>CFLAGS</code>, <code>CFLAGS</code> without <code>-g</code>, then
for <code>g++</code> either <code>-g -O2</code> or <code>-O2</code>, or for other compilers
<code>-g</code> or nothing.  Trying <code>CFLAGS</code> this way is convenient when using
<code>gcc</code> and <code>g++</code> together, since the flags for <code>gcc</code> will
usually suit <code>g++</code>.

<p>It's important that the C and C++ compilers match, meaning their startup and
runtime support routines are compatible and that they generate code in the
same ABI (if there's a choice of ABIs on the system).  <code>./configure</code>
isn't currently able to check these things very well itself, so for that
reason <code>--disable-cxx</code> is the default, to avoid a build failure due to a
compiler mismatch.  Perhaps this will change in the future.

<p>Incidentally, it's normally not good enough to set <code>CXX</code> to the same as
<code>CC</code>.  Although <code>gcc</code> for instance recognises <code>foo.cc</code> as
C++ code, only <code>g++</code> will invoke the linker the right way when
building an executable or shared library from object files.

<br><dt>Temporary Memory, <code>--enable-alloca=&lt;choice&gt;</code>
<dd>

<p>GMP allocates temporary workspace using one of the following three methods,
which can be selected with for instance
<code>--enable-alloca=malloc-reentrant</code>.

<ul>
<li><code>alloca</code> - C library or compiler builtin. 
<li><code>malloc-reentrant</code> - the heap, in a re-entrant fashion. 
<li><code>malloc-notreentrant</code> - the heap, with global variables. 
</ul>

<p>For convenience, the following choices are also available. 
<code>--disable-alloca</code> is the same as <code>--enable-alloca=no</code>.

<ul>
<li><code>yes</code> - a synonym for <code>alloca</code>. 
<li><code>no</code> - a synonym for <code>malloc-reentrant</code>. 
<li><code>reentrant</code> - <code>alloca</code> if available, otherwise
<code>malloc-reentrant</code>.  This is the default. 
<li><code>notreentrant</code> - <code>alloca</code> if available, otherwise
<code>malloc-notreentrant</code>. 
</ul>

<p><code>alloca</code> is reentrant and fast, and is recommended, but when working with
large numbers it can overflow the available stack space, in which case one of
the two malloc methods will need to be used.  Alternately it might be possible
to increase available stack with <code>limit</code>, <code>ulimit</code> or
<code>setrlimit</code>, or under DJGPP with <code>stubedit</code> or
<code>_stklen</code>.  Note that depending on the system the only indication of
stack overflow might be a segmentation violation.

<p><code>malloc-reentrant</code> is, as the name suggests, reentrant and thread safe,
but <code>malloc-notreentrant</code> is faster and should be used if reentrancy is
not required.

<p>The two malloc methods in fact use the memory allocation functions selected by
<code>mp_set_memory_functions</code>, these being <code>malloc</code> and friends by
default.  See <a href="#Custom%20Allocation">Custom Allocation</a>.

<p>An additional choice <code>--enable-alloca=debug</code> is available, to help when
debugging memory related problems (see <a href="#Debugging">Debugging</a>).

<br><dt>FFT Multiplication, <code>--disable-fft</code>
<dd>
By default multiplications are done using Karatsuba, 3-way Toom-Cook, and
Fermat FFT.  The FFT is only used on large to very large operands and can be
disabled to save code size if desired.

<br><dt>Berkeley MP, <code>--enable-mpbsd</code>
<dd>
The Berkeley MP compatibility library (<code>libmp</code>) and header file
(<code>mp.h</code>) are built and installed only if <code>--enable-mpbsd</code> is used. 
See <a href="#BSD%20Compatible%20Functions">BSD Compatible Functions</a>.

<br><dt>MPFR, <code>--enable-mpfr</code>
<dd>

<p>The optional MPFR functions are built and installed only if
<code>--enable-mpfr</code> is used.  These are in a separate library
<code>libmpfr.a</code> and are documented separately too (see <a href="mpfr.html#Introduction%20to%20MPFR">Introduction to MPFR</a>).

<br><dt>Assertion Checking, <code>--enable-assert</code>
<dd>
This option enables some consistency checking within the library.  This can be
of use while debugging, see <a href="#Debugging">Debugging</a>.

<br><dt>Execution Profiling, <code>--enable-profiling=prof/gprof</code>
<dd>
Profiling support can be enabled either for <code>prof</code> or <code>gprof</code>. 
This adds <code>-p</code> or <code>-pg</code> respectively to <code>CFLAGS</code>, and for some
systems adds corresponding <code>mcount</code> calls to the assembler code. 
See <a href="#Profiling">Profiling</a>.

<br><dt><code>MPN_PATH</code>
<dd>
Various assembler versions of each mpn subroutines are provided.  For a given
CPU, a search is made though a path to choose a version of each.  For example
<code>sparcv8</code> has

<br><pre>MPN_PATH="sparc32/v8 sparc32 generic"
</pre>

<p>which means look first for v8 code, then plain sparc32 (which is v7), and
finally fall back on generic C.  Knowledgeable users with special requirements
can specify a different path.  Normally this is completely unnecessary.

<br><dt>Demonstration Programs
<dd>

<p>The <code>demos</code> subdirectory has some sample programs using GMP.  These
aren't built or installed, but there's a <code>Makefile</code> with rules for them. 
For instance,

<br><pre>make pexpr
./pexpr 68^975+10
</pre>

<br><dt>Documentation
<dd>
The document you're now reading is <code>gmp.texi</code>.  The usual automake
targets are available to make PostScript <code>gmp.ps</code> and/or DVI
<code>gmp.dvi</code>.

<p>HTML can be produced with <code>makeinfo --html</code>, see <a href="texinfo.html#makeinfo%20html">Generating HTML</a>.  Or alternately
<code>texi2html</code>, see <a href="texi2html.html#Top">Texinfo to HTML</a>.

<p>PDF can be produced with <code>texi2dvi --pdf</code> (see <a href="texinfo.html#PDF%20Output">PDF</a>) or with <code>pdftex</code>.

<p>Some supplementary notes can be found in the <code>doc</code> subdirectory.

</dl>

<p><hr>
Node:<a name="ABI%20and%20ISA">ABI and ISA</a>,
Next:<a rel=next accesskey=n href="#Notes%20for%20Package%20Builds">Notes for Package Builds</a>,
Previous:<a rel=previous accesskey=p href="#Build%20Options">Build Options</a>,
Up:<a rel=up accesskey=u href="#Installing%20GMP">Installing GMP</a>
<br>

<h3>ABI and ISA</h3>

<p>ABI (Application Binary Interface) refers to the calling conventions between
functions, meaning what registers are used and what sizes the various C data
types are.  ISA (Instruction Set Architecture) refers to the instructions and
registers a CPU has available.

<p>Some 64-bit ISA CPUs have both a 64-bit ABI and a 32-bit ABI defined, the
latter for compatibility with older CPUs in the family.  GMP supports some
CPUs like this in both ABIs.  In fact within GMP <code>ABI</code> means a
combination of chip ABI, plus how GMP chooses to use it.  For example in some
32-bit ABIs, GMP may support a limb as either a 32-bit <code>long</code> or a 64-bit
<code>long long</code>.

<p>By default GMP chooses the best ABI available for a given system, and this
generally gives significantly greater speed.  But an ABI can be chosen
explicitly to make GMP compatible with other libraries, or particular
application requirements.  For example,

<br><pre>./configure ABI=32
</pre>

<p>In all cases it's vital that all object code used in a given program is
compiled for the same ABI.

<p>Usually a limb is implemented as a <code>long</code>.  When a <code>long long</code> limb
is used this is encoded in the generated <code>gmp.h</code>.  This is convenient for
applications, but it does mean that <code>gmp.h</code> will vary, and can't be just
copied around.  <code>gmp.h</code> remains compiler independent though, since all
compilers for a particular ABI will be expected to use the same limb type.

<p>Currently no attempt is made to follow whatever conventions a system has for
installing library or header files built for a particular ABI.  This will
probably only matter when installing multiple builds of GMP, and it might be
as simple as configuring with a special <code>libdir</code>, or it might require
more than that.  Note that builds for different ABIs need to done separately,
with a fresh <code>./configure</code> and <code>make</code> each.

<dl>
<br><p>
<br><dt>HPPA 2.0 (<code>hppa2.0*</code>)
<dd>
<dl>
<dt><code>ABI=2.0w</code>
<dd>
The 2.0w ABI uses 64-bit limbs and pointers and is available on HP-UX 11 or up
when using <code>cc</code>.  <code>gcc</code> support for this is in progress. 
Applications must be compiled with

<br><pre>cc  +DD64
</pre>

<br><dt><code>ABI=2.0n</code>
<dd>
The 2.0n ABI means the 32-bit HPPA 1.0 ABI but with a 64-bit limb using
<code>long long</code>.  This is available on HP-UX 10 or up when using
<code>cc</code>.  No <code>gcc</code> support is planned for this.  Applications
must be compiled with

<br><pre>cc  +DA2.0 +e
</pre>

<br><dt><code>ABI=1.0</code>
<dd>
HPPA 2.0 CPUs can run all HPPA 1.0 and 1.1 code in the 32-bit HPPA 1.0 ABI. 
No special compiler options are needed for applications. 
</dl>

<p>All three ABIs are available for CPUs <code>hppa2.0w</code> and <code>hppa2.0</code>, but
for CPU <code>hppa2.0n</code> only 2.0n or 1.0 are allowed.

<br><p>
<br><dt>MIPS under IRIX 6 (<code>mips*-*-irix[6789]</code>)
<dd>
IRIX 6 supports the n32 and 64 ABIs and always has a 64-bit MIPS 3 or better
CPU.  In both these ABIs GMP uses a 64-bit limb.  A new enough <code>gcc</code>
is required (2.95 for instance).

<dl>
<dt><code>ABI=n32</code>
<dd>
The n32 ABI is 32-bit pointers and integers, but with a 64-bit limb using a
<code>long long</code>.  Applications must be compiled with

<br><pre>gcc  -mabi=n32
cc   -n32
</pre>

<br><dt><code>ABI=64</code>
<dd>
The 64-bit ABI is 64-bit pointers and integers.  Applications must be compiled
with

<br><pre>gcc  -mabi=64
cc   -64
</pre>
</dl>

<p>Note that MIPS GNU/Linux, as of kernel version 2.2, doesn't have the necessary
support for n32 or 64 and so only gets a 32-bit limb and the MIPS 2 code.

<br><p>
<br><dt>PowerPC 64 (<code>powerpc64*</code>)
<dd>
<dl>
<dt><code>ABI=aix64</code>
<dd>
The AIX 64 ABI uses 64-bit limbs and pointers and is available on systems
<code>powerpc64*-*-aix*</code>.  Applications must be compiled (and linked) with

<br><pre>gcc  -maix64
xlc  -q64
</pre>

<br><dt><code>ABI=32L</code>
<dd>
This uses the 32-bit ABI but a 64-bit limb using GCC <code>long long</code> in
64-bit registers.  Applications must be compiled with

<br><pre>gcc  -mpowerpc64
</pre>

<br><dt><code>ABI=32</code>
<dd>
This is the basic 32-bit PowerPC ABI.  No special compiler options are needed
for applications. 
</dl>

<br><p>
<br><dt>Sparc V9 (<code>sparcv9</code> and <code>ultrasparc*</code>)
<dd>
<dl>
<dt><code>ABI=64</code>
<dd>
The 64-bit V9 ABI is available on Solaris 2.7 and up and GNU/Linux.  GCC 2.95
or up, or Sun <code>cc</code> is required.  Applications must be compiled with

<br><pre>gcc  -m64 -mptr64 -Wa,-xarch=v9 -mcpu=v9
cc   -xarch=v9
</pre>

<br><dt><code>ABI=32</code>
<dd>
On Solaris 2.6 and earlier, and on Solaris 2.7 with the kernel in 32-bit mode,
only the plain V8 32-bit ABI can be used, since the kernel doesn't save all
registers.  GMP still uses as much of the V9 ISA as it can in these
circumstances.  No special compiler options are required for applications,
though using something like the following requesting V9 code within the V8 ABI
is recommended.

<br><pre>gcc  -mv8plus
cc   -xarch=v8plus
</pre>

<p><code>gcc</code> 2.8 and earlier only supports <code>-mv8</code> though. 
</dl>

<p>Don't be confused by the names of these sparc <code>-m</code> and <code>-x</code> options,
they're called <code>arch</code> but they effectively control the ABI.

<p>On Solaris 2.7 with the kernel in 32-bit-mode, a normal native build will
reject <code>ABI=64</code> because the resulting executables won't run. 
<code>ABI=64</code> can still be built if desired by making it look like a
cross-compile, for example

<br><pre>./configure --build=none --host=sparcv9-sun-solaris2.7 ABI=64
</pre>
</dl>

<p><hr>
Node:<a name="Notes%20for%20Package%20Builds">Notes for Package Builds</a>,
Next:<a rel=next accesskey=n href="#Notes%20for%20Particular%20Systems">Notes for Particular Systems</a>,
Previous:<a rel=previous accesskey=p href="#ABI%20and%20ISA">ABI and ISA</a>,
Up:<a rel=up accesskey=u href="#Installing%20GMP">Installing GMP</a>
<br>

<h3>Notes for Package Builds</h3>

<p>GMP should present no great difficulties for packaging in a binary
distribution.

<p>Libtool is used to build the library and <code>-version-info</code> is set
appropriately, having started from <code>3:0:0</code> in GMP 3.0.  The GMP 4 series
will be upwardly binary compatible in each release and will be upwardly binary
compatible with all of the GMP 3 series.  Additional function interfaces may
be added in each release, so on systems where libtool versioning is not fully
checked by the loader an auxiliary mechanism may be needed to express that a
dynamic linked application depends on a new enough GMP.

<p>An auxiliary mechanism may also be needed to express that <code>libgmpxx.la</code>
(from <code>--enable-cxx</code>, see <a href="#Build%20Options">Build Options</a>) requires <code>libgmp.la</code>
from the same GMP version, since this is not done by the libtool versioning,
nor otherwise.  A mismatch will result in unresolved symbols from the linker,
or perhaps the loader.

<p>Using <code>DESTDIR</code> or a <code>prefix</code> override with <code>make install</code> and
a shared <code>libgmpxx</code> may run into a libtool relinking problem, see
<a href="#Known%20Build%20Problems">Known Build Problems</a>.

<p>When building a package for a CPU family, care should be taken to use
<code>--host</code> (or <code>--build</code>) to choose the least common denominator among
the CPUs which might use the package.  For example this might necessitate
<code>i386</code> for x86s, or plain <code>sparc</code> (meaning V7) for SPARCs.

<p>Users who care about speed will want GMP built for their exact CPU type, to
make use of the available optimizations.  Providing a way to suitably rebuild
a package may be useful.  This could be as simple as making it possible for a
user to omit <code>--build</code> (and <code>--host</code>) so <code>./config.guess</code> will
detect the CPU.  But a way to manually specify a <code>--build</code> will be wanted
for systems where <code>./config.guess</code> is inexact.

<p>Note that <code>gmp.h</code> is a generated file, and will be architecture and ABI
dependent.

<p><hr>
Node:<a name="Notes%20for%20Particular%20Systems">Notes for Particular Systems</a>,
Next:<a rel=next accesskey=n href="#Known%20Build%20Problems">Known Build Problems</a>,
Previous:<a rel=previous accesskey=p href="#Notes%20for%20Package%20Builds">Notes for Package Builds</a>,
Up:<a rel=up accesskey=u href="#Installing%20GMP">Installing GMP</a>
<br>

<h3>Notes for Particular Systems</h3>

<dl>

<br><dt>AIX 3 and 4
<dd>
On systems <code>*-*-aix[34]*</code> shared libraries are disabled by default, since
some versions of the native <code>ar</code> fail on the convenience libraries
used.  A shared build can be attempted with

<br><pre>./configure --enable-shared --disable-static
</pre>

<p>Note that the <code>--disable-static</code> is necessary because in a shared build
libtool makes <code>libgmp.a</code> a symlink to <code>libgmp.so</code>, apparently for
the benefit of old versions of <code>ld</code> which only recognise <code>.a</code>,
but unfortunately this is done even if a fully functional <code>ld</code> is
available.

<br><dt>ARM
<dd>
On systems <code>arm*-*-*</code>, versions of GCC up to and including 2.95.3 have a
bug in unsigned division, giving wrong results for some operands.  GMP
<code>./configure</code> will demand GCC 2.95.4 or later.

<br><dt>Microsoft Windows
<dd>On systems <code>*-*-cygwin*</code>, <code>*-*-mingw*</code> and <code>*-*-pw32*</code> by
default GMP builds only a static library, but a DLL can be built instead using

<br><pre>./configure --disable-static --enable-shared
</pre>

<p>Static and DLL libraries can't both be built, since certain export directives
in <code>gmp.h</code> must be different.  <code>--enable-cxx</code> cannot be used when
building a DLL, since libtool doesn't currently support C++ DLLs.  This might
change in the future.

<p>GCC is recommended for compiling GMP, but the resulting DLL can be used with
any compiler.  On mingw only the standard Windows libraries will be needed, on
Cygwin the usual cygwin runtime will be required.

<br><dt>Motorola 68k CPU Types
<dd>
<code>m68k</code> is taken to mean 68000.  <code>m68020</code> or higher will give a
performance boost on applicable CPUs.  <code>m68360</code> can be used for CPU32
series chips.  <code>m68302</code> can be used for "Dragonball" series chips,
though this is merely a synonym for <code>m68000</code>.

<br><dt>OpenBSD 2.6
<dd>
<code>m4</code> in this release of OpenBSD has a bug in <code>eval</code> that makes it
unsuitable for <code>.asm</code> file processing.  <code>./configure</code> will detect
the problem and either abort or choose another m4 in the <code>PATH</code>.  The bug
is fixed in OpenBSD 2.7, so either upgrade or use GNU m4.

<br><dt>Power CPU Types
<dd>
In GMP, CPU types <code>power*</code> and <code>powerpc*</code> will each use instructions
not available on the other, so it's important to choose the right one for the
CPU that will be used.  Currently GMP has no assembler code support for using
just the common instruction subset.  To get executables that run on both, the
current suggestion is to use the generic C code (CPU <code>none</code>), possibly
with appropriate compiler options (like <code>-mcpu=common</code> for
<code>gcc</code>).  CPU <code>rs6000</code> (which is not a CPU but a family of
workstations) is accepted by <code>config.sub</code>, but is currently equivalent to
<code>none</code>.

<br><dt>Sparc CPU Types
<dd>
<code>sparcv8</code> or <code>supersparc</code> on relevant systems will give a
significant performance increase over the V7 code.

<br><dt>SunOS 4
<dd>
<code>/usr/bin/m4</code> lacks various features needed to process <code>.asm</code>
files, and instead <code>./configure</code> will automatically use
<code>/usr/5bin/m4</code>, which we believe is always available (if not then use
GNU m4).

<br><dt>x86 CPU Types
<dd>
<code>i386</code> selects generic code which will run reasonably well on all x86
chips.

<p><code>i586</code>, <code>pentium</code> or <code>pentiummmx</code> code is good for the intended
P5 Pentium chips, but quite slow when run on Intel P6 class chips (PPro, P-II,
P-III).  <code>i386</code> is a better choice when making binaries that must run on
both.

<p><code>pentium4</code> and an SSE2 capable assembler are important for best results
on Pentium 4.  The specific code is for instance roughly a 2x to
3x speedup over the generic <code>i386</code> code.

<br><dt>x86 MMX and SSE2 Code
<dd>
If the CPU selected has MMX code but the assembler doesn't support it, a
warning is given and non-MMX code is used instead.  This will be an inferior
build, since the MMX code that's present is there because it's faster than the
corresponding plain integer code.  The same applies to SSE2.

<p>Old versions of <code>gas</code> don't support MMX instructions, in particular
version 1.92.3 that comes with FreeBSD 2.2.8 doesn't (and unfortunately
there's no newer assembler for that system).

<p>Solaris 2.6 and 2.7 <code>as</code> generate incorrect object code for register
to register <code>movq</code> instructions, and so can't be used for MMX code. 
Install a recent <code>gas</code> if MMX code is wanted on these systems.

<br><dt>x86 GCC <code>-march=pentiumpro</code>
<dd>
GCC 2.95.2 and 2.95.3 miscompiled some versions of <code>mpz/powm.c</code> when
<code>-march=pentiumpro</code> was used, so for relevant CPUs that option is only in
the default <code>CFLAGS</code> for GCC 2.95.4 and up. 
</dl>

<p><hr>
Node:<a name="Known%20Build%20Problems">Known Build Problems</a>,
Previous:<a rel=previous accesskey=p href="#Notes%20for%20Particular%20Systems">Notes for Particular Systems</a>,
Up:<a rel=up accesskey=u href="#Installing%20GMP">Installing GMP</a>
<br>

<h3>Known Build Problems</h3>

<p>You might find more up-to-date information at <a href="http://swox.com/gmp/">http://swox.com/gmp/</a>.

<dl>
<dt>DJGPP
<dd>
The DJGPP port of <code>bash</code> 2.03 is unable to run the <code>configure</code>
script, it exits silently, having died writing a preamble to
<code>config.log</code>.  Use <code>bash</code> 2.04 or higher.

<p><code>make all</code> was found to run out of memory during the final
<code>libgmp.la</code> link on one system tested, despite having 64Mb available.  A
separate <code>make libgmp.la</code> helped, perhaps recursing into the various
subdirectories uses up memory.

<br><dt><code>DESTDIR</code> and shared <code>libgmpxx</code>
<dd>

<p><code>make install DESTDIR=/my/staging/area</code> or the same with a <code>prefix</code>
override to install to a temporary directory is not fully supported by current
versions of libtool when building a shared version of a library which depends
on another being built at the same time, like <code>libgmpxx</code> and
<code>libgmp</code>.

<p>The problem is that <code>libgmpxx</code> is relinked at the install stage to ensure
that if the system puts a hard-coded path to <code>libgmp</code> within
<code>libgmpxx</code> then that path will be correct.  Naturally the linker is
directed to look only at the final location, not the staging area, so if
<code>libgmp</code> is not already in that final location then the link will fail.

<p>On systems which don't hard-code library paths, for instance SVR4 style
systems such as GNU/Linux, a workaround is to insert a suitable <code>-L</code> in
the <code>relink_command</code> of <code>libgmpxx.la</code> after building but before
installing.  This can be automated with something like

<br><pre>sed '/^relink_command/s:libgmp.la:-L /my/staging/area libgmp.la:' \
    &lt;libgmpxx.la &gt;libgmpxx.new
mv libgmpxx.new libgmpxx.la
</pre>

<br><dt>GNU binutils <code>strip</code>
<dd>

<p>GNU binutils <code>strip</code> should not be used on the static libraries
<code>libgmp.a</code> and <code>libmp.a</code>, neither directly nor via <code>make
install-strip</code>.  It can be used on the shared libraries <code>libgmp.so</code> and
<code>libmp.so</code> though.

<p>Currently (binutils 2.10.0), <code>strip</code> unpacks an archive then operates
on the files, but GMP contains multiple object files of the same name
(eg. three versions of <code>init.o</code>), and they overwrite each other, leaving
only the one that happens to be last.

<p>If stripped static libraries are wanted, the suggested workaround is to build
normally, strip the separate object files, and do another <code>make all</code> to
rebuild.  Alternately <code>CFLAGS</code> with <code>-g</code> omitted can always be used
if it's just debugging which is unwanted.

<br><dt><code>make</code> syntax error
<dd>
On certain versions of SCO OpenServer 5 and IRIX 6.5 the native <code>make</code>
is unable to handle the long dependencies list for <code>libgmp.la</code>.  The
symptom is a "syntax error" on the following line of the top-level
<code>Makefile</code>.

<br><pre>libgmp.la: $(libgmp_la_OBJECTS) $(libgmp_la_DEPENDENCIES)
</pre>

<p>Either use GNU Make, or as a workaround remove
<code>$(libgmp_la_DEPENDENCIES)</code> from that line (which will make the initial
build work, but if any recompiling is done <code>libgmp.la</code> might not be
rebuilt).

<br><dt>NeXT prior to 3.3
<dd>
The system compiler on old versions of NeXT was a massacred and old GCC, even
if it called itself <code>cc</code>.  This compiler cannot be used to build GMP, you
need to get a real GCC, and install that.  (NeXT may have fixed this in
release 3.3 of their system.)

<br><dt>POWER and PowerPC
<dd>
Bugs in GCC 2.7.2 (and 2.6.3) mean it can't be used to compile GMP on POWER or
PowerPC.  If you want to use GCC for these machines, get GCC 2.7.2.1 (or
later).

<br><dt>Sequent Symmetry
<dd>
Use the GNU assembler instead of the system assembler, since the latter has
serious bugs.

<br><dt>Solaris 2.6
<dd>
The system <code>sed</code> prints an error "Output line too long" when libtool
builds <code>libgmp.la</code>.  This doesn't seem to cause any obvious ill effects,
but GNU <code>sed</code> is recommended, to avoid any doubt.

<br><dt>Sparc Solaris 2.7 with gcc 2.95.2 in ABI=32
<dd>
A shared library build of GMP seems to fail in this combination, it builds but
then fails the tests, apparently due to some incorrect data relocations within
<code>gmp_randinit_lc_2exp_size</code>.  The exact cause is unknown,
<code>--disable-shared</code> is recommended.

<br><dt>Windows DLL test programs
<dd>
When creating a DLL version of <code>libgmp</code>, libtool creates wrapper scripts
like <code>t-mul</code> for programs that would normally be <code>t-mul.exe</code>, in
order to setup the right library paths etc.  This works fine, but the absence
of <code>t-mul.exe</code> etc causes <code>make</code> to think they need recompiling
every time, which is an annoyance when re-running a <code>make check</code>. 
</dl>

<p><hr>
Node:<a name="GMP%20Basics">GMP Basics</a>,
Next:<a rel=next accesskey=n href="#Reporting%20Bugs">Reporting Bugs</a>,
Previous:<a rel=previous accesskey=p href="#Installing%20GMP">Installing GMP</a>,
Up:<a rel=up accesskey=u href="#Top">Top</a>
<br>

<h2>GMP Basics</h2>

<p><strong>Using functions, macros, data types, etc. not documented in this
manual is strongly discouraged.  If you do so your application is guaranteed
to be incompatible with future versions of GMP.</strong>

<ul>
<li><a accesskey=1 href="#Headers%20and%20Libraries">Headers and Libraries</a>: 
<li><a accesskey=2 href="#Nomenclature%20and%20Types">Nomenclature and Types</a>: 
<li><a accesskey=3 href="#Function%20Classes">Function Classes</a>: 
<li><a accesskey=4 href="#Variable%20Conventions">Variable Conventions</a>: 
<li><a accesskey=5 href="#Parameter%20Conventions">Parameter Conventions</a>: 
<li><a accesskey=6 href="#Memory%20Management">Memory Management</a>: 
<li><a accesskey=7 href="#Reentrancy">Reentrancy</a>: 
<li><a accesskey=8 href="#Useful%20Macros%20and%20Constants">Useful Macros and Constants</a>: 
<li><a accesskey=9 href="#Compatibility%20with%20older%20versions">Compatibility with older versions</a>: 
<li><a href="#Efficiency">Efficiency</a>: 
<li><a href="#Debugging">Debugging</a>: 
<li><a href="#Profiling">Profiling</a>: 
<li><a href="#Autoconf">Autoconf</a>: 
</ul>

<p><hr>
Node:<a name="Headers%20and%20Libraries">Headers and Libraries</a>,
Next:<a rel=next accesskey=n href="#Nomenclature%20and%20Types">Nomenclature and Types</a>,
Previous:<a rel=previous accesskey=p href="#GMP%20Basics">GMP Basics</a>,
Up:<a rel=up accesskey=u href="#GMP%20Basics">GMP Basics</a>
<br>

<h3>Headers and Libraries</h3>

<p>All declarations needed to use GMP are collected in the include file
<code>gmp.h</code>.  It is designed to work with both C and C++ compilers.

<br><pre>#include &lt;gmp.h&gt;
</pre>

<p>Note however that prototypes for GMP functions with <code>FILE *</code> parameters
are only provided if <code>&lt;stdio.h&gt;</code> is included too.

<br><pre>#include &lt;stdio.h&gt;
#include &lt;gmp.h&gt;
</pre>

<p>Likewise <code>&lt;stdarg.h&gt;</code> (or <code>&lt;varargs.h&gt;</code>) is required for prototypes
with <code>va_list</code> parameters, such as <code>gmp_vprintf</code>.  And
<code>&lt;obstack.h&gt;</code> for prototypes with <code>struct obstack</code> parameters, such
as <code>gmp_obstack_printf</code>, when available.

<p>All programs using GMP must link against the <code>libgmp</code> library.  On a
typical Unix-like system this can be done with <code>-lgmp</code>, for example

<br><pre>gcc myprogram.c -lgmp
</pre>

<p>GMP C++ functions are in a separate <code>libgmpxx</code> library.  This is built
and installed if C++ support has been enabled (see <a href="#Build%20Options">Build Options</a>).  For
example,

<br><pre>g++ mycxxprog.cc -lgmpxx -lgmp
</pre>

<p>GMP is built using Libtool and an application can use that to link if desired,
see <a href="libtool.html#Top">Shared library support for GNU</a>

<p>If GMP has been installed to a non-standard location then it may be necessary
to use <code>-I</code> and <code>-L</code> compiler options to point to the right
directories, and some sort of run-time path for a shared library.  Consult
your compiler documentation, for instance <a href="gcc.html#Top">Introduction</a>.

<p><hr>
Node:<a name="Nomenclature%20and%20Types">Nomenclature and Types</a>,
Next:<a rel=next accesskey=n href="#Function%20Classes">Function Classes</a>,
Previous:<a rel=previous accesskey=p href="#Headers%20and%20Libraries">Headers and Libraries</a>,
Up:<a rel=up accesskey=u href="#GMP%20Basics">GMP Basics</a>
<br>

<h3>Nomenclature and Types</h3>

<p>In this manual, <dfn>integer</dfn> usually means a multiple precision integer, as
defined by the GMP library.  The C data type for such integers is <code>mpz_t</code>. 
Here are some examples of how to declare such integers:

<br><pre>mpz_t sum;

struct foo { mpz_t x, y; };

mpz_t vec[20];
</pre>

<p><dfn>Rational number</dfn> means a multiple precision fraction.  The C data type
for these fractions is <code>mpq_t</code>.  For example:

<br><pre>mpq_t quotient;
</pre>

<p><dfn>Floating point number</dfn> or <dfn>Float</dfn> for short, is an arbitrary precision
mantissa with a limited precision exponent.  The C data type for such objects
is <code>mpf_t</code>.

<p>A <dfn>limb</dfn> means the part of a multi-precision number that fits in a single
machine word.  (We chose this word because a limb of the human body is
analogous to a digit, only larger, and containing several digits.)  Normally a
limb is 32 or 64 bits.  The C data type for a limb is <code>mp_limb_t</code>.

<p><hr>
Node:<a name="Function%20Classes">Function Classes</a>,
Next:<a rel=next accesskey=n href="#Variable%20Conventions">Variable Conventions</a>,
Previous:<a rel=previous accesskey=p href="#Nomenclature%20and%20Types">Nomenclature and Types</a>,
Up:<a rel=up accesskey=u href="#GMP%20Basics">GMP Basics</a>
<br>

<h3>Function Classes</h3>

<p>There are six classes of functions in the GMP library:

<ol type=1 start=1>
</p><li>Functions for signed integer arithmetic, with names beginning with
<code>mpz_</code>.  The associated type is <code>mpz_t</code>.  There are about 150
functions in this class.

<li>Functions for rational number arithmetic, with names beginning with
<code>mpq_</code>.  The associated type is <code>mpq_t</code>.  There are about 40
functions in this class, but the integer functions can be used for arithmetic
on the numerator and denominator separately.

<li>Functions for floating-point arithmetic, with names beginning with
<code>mpf_</code>.  The associated type is <code>mpf_t</code>.  There are about 60
functions is this class.

<li>Functions compatible with Berkeley MP, such as <code>itom</code>, <code>madd</code>, and
<code>mult</code>.  The associated type is <code>MINT</code>.

<li>Fast low-level functions that operate on natural numbers.  These are used by
the functions in the preceding groups, and you can also call them directly
from very time-critical user programs.  These functions' names begin with
<code>mpn_</code>.  The associated type is array of <code>mp_limb_t</code>.  There are
about 30 (hard-to-use) functions in this class.

<li>Miscellaneous functions.  Functions for setting up custom allocation and
functions for generating random numbers.
</ol>

<p><hr>
Node:<a name="Variable%20Conventions">Variable Conventions</a>,
Next:<a rel=next accesskey=n href="#Parameter%20Conventions">Parameter Conventions</a>,
Previous:<a rel=previous accesskey=p href="#Function%20Classes">Function Classes</a>,
Up:<a rel=up accesskey=u href="#GMP%20Basics">GMP Basics</a>
<br>

<h3>Variable Conventions</h3>

<p>GMP functions generally have output arguments before input arguments.  This
notation is by analogy with the assignment operator.  The BSD MP compatibility
functions are exceptions, having the output arguments last.

<p>GMP lets you use the same variable for both input and output in one call.  For
example, the main function for integer multiplication, <code>mpz_mul</code>, can be
used to square <code>x</code> and put the result back in <code>x</code> with

<br><pre>mpz_mul (x, x, x);
</pre>

<p>Before you can assign to a GMP variable, you need to initialize it by calling
one of the special initialization functions.  When you're done with a
variable, you need to clear it out, using one of the functions for that
purpose.  Which function to use depends on the type of variable.  See the
chapters on integer functions, rational number functions, and floating-point
functions for details.

<p>A variable should only be initialized once, or at least cleared between each
initialization.  After a variable has been initialized, it may be assigned to
any number of times.

<p>For efficiency reasons, avoid excessive initializing and clearing.  In
general, initialize near the start of a function and clear near the end.  For
example,

<br><pre>void
foo (void)
{
  mpz_t  n;
  int    i;
  mpz_init (n);
  for (i = 1; i &lt; 100; i++)
    {
      mpz_mul (n, <small>...</small>);
      mpz_fdiv_q (n, <small>...</small>);
      <small>...</small>
    }
  mpz_clear (n);
}
</pre>

<p><hr>
Node:<a name="Parameter%20Conventions">Parameter Conventions</a>,
Next:<a rel=next accesskey=n href="#Memory%20Management">Memory Management</a>,
Previous:<a rel=previous accesskey=p href="#Variable%20Conventions">Variable Conventions</a>,
Up:<a rel=up accesskey=u href="#GMP%20Basics">GMP Basics</a>
<br>

<h3>Parameter Conventions</h3>

<p>When a GMP variable is used as a function parameter, it's effectively a
call-by-reference, meaning if the function stores a value there it will change
the original in the caller.  Parameters which are input-only can be designated
<code>const</code> to provoke a compiler error or warning on attempting to modify
them.

<p>When a function is going to return a GMP result, it should designate a
parameter that it sets, like the library functions do.  More than one value
can be returned by having more than one output parameter, again like the
library functions.  A <code>return</code> of an <code>mpz_t</code> etc doesn't return the
object, only a pointer, and this is almost certainly not what's wanted.

<p>Here's an example accepting an <code>mpz_t</code> parameter, doing a calculation,
and storing the result to the indicated parameter.

<br><pre>void
foo (mpz_t result, const mpz_t param, unsigned long n)
{
  unsigned long  i;
  mpz_mul_ui (result, param, n);
  for (i = 1; i &lt; n; i++)
    mpz_add_ui (result, result, i*7);
}

int
main (void)
{
  mpz_t  r, n;
  mpz_init (r);
  mpz_init_set_str (n, "123456", 0);
  foo (r, n, 20L);
  gmp_printf ("%Zd\n", r);
  return 0;
}
</pre>

<p><code>foo</code> works even if the mainline passes the same variable for
<code>param</code> and <code>result</code>, just like the library functions.  But
sometimes it's tricky to make that work, and an application might not want to
bother supporting that sort of thing.

<p>For interest, the GMP types <code>mpz_t</code> etc are implemented as one-element
arrays of certain structures.  This is why declaring a variable creates an
object with the fields GMP needs, but then using it as a parameter passes a
pointer to the object.  Note that the actual fields in each <code>mpz_t</code> etc
are for internal use only and should not be accessed directly by code that
expects to be compatible with future GMP releases.

<p><hr>
Node:<a name="Memory%20Management">Memory Management</a>,
Next:<a rel=next accesskey=n href="#Reentrancy">Reentrancy</a>,
Previous:<a rel=previous accesskey=p href="#Parameter%20Conventions">Parameter Conventions</a>,
Up:<a rel=up accesskey=u href="#GMP%20Basics">GMP Basics</a>
<br>

<h3>Memory Management</h3>

<p>The GMP types like <code>mpz_t</code> are small, containing only a couple of sizes,
and pointers to allocated data.  Once a variable is initialized, GMP takes
care of all space allocation.  Additional space is allocated whenever a
variable doesn't have enough.

<p><code>mpz_t</code> and <code>mpq_t</code> variables never reduce their allocated space. 
Normally this is the best policy, since it avoids frequent reallocation. 
Applications that need to return memory to the heap at some particular point
can use <code>mpz_realloc2</code>, or clear variables no longer needed.

<p><code>mpf_t</code> variables, in the current implementation, use a fixed amount of
space, determined by the chosen precision and allocated at initialization, so
their size doesn't change.

<p>All memory is allocated using <code>malloc</code> and friends by default, but this
can be changed, see <a href="#Custom%20Allocation">Custom Allocation</a>.  Temporary memory on the stack is
also used (via <code>alloca</code>), but this can be changed at build-time if
desired, see <a href="#Build%20Options">Build Options</a>.

<p><hr>
Node:<a name="Reentrancy">Reentrancy</a>,
Next:<a rel=next accesskey=n href="#Useful%20Macros%20and%20Constants">Useful Macros and Constants</a>,
Previous:<a rel=previous accesskey=p href="#Memory%20Management">Memory Management</a>,
Up:<a rel=up accesskey=u href="#GMP%20Basics">GMP Basics</a>
<br>

<h3>Reentrancy</h3>

<p>GMP is reentrant and thread-safe, with some exceptions:

<ul>
<li>If configured with <code>--enable-alloca=malloc-notreentrant</code> (or with
<code>--enable-alloca=notreentrant</code> when <code>alloca</code> is not available),
then naturally GMP is not reentrant.

<li><code>mpf_set_default_prec</code> and <code>mpf_init</code> use a global variable for the
selected precision.  <code>mpf_init2</code> can be used instead.

<li><code>mpz_random</code> and the other old random number functions use a global
random state and are hence not reentrant.  The newer random number functions
that accept a <code>gmp_randstate_t</code> parameter can be used instead.

<li><code>mp_set_memory_functions</code> uses global variables to store the selected
memory allocation functions.

<li>If the memory allocation functions set by a call to
<code>mp_set_memory_functions</code> (or <code>malloc</code> and friends by default) are
not reentrant, then GMP will not be reentrant either.

<li>If the standard I/O functions such as <code>fwrite</code> are not reentrant then the
GMP I/O functions using them will not be reentrant either.

<li>It's safe for two threads to read from the same GMP variable simultaneously,
but it's not safe for one to read while the another might be writing, nor for
two threads to write simultaneously.  It's not safe for two threads to
generate a random number from the same <code>gmp_randstate_t</code> simultaneously,
since this involves an update of that variable.

<li>On SCO systems the default <code>&lt;ctype.h&gt;</code> macros use per-file static
variables and may not be reentrant, depending whether the compiler optimizes
away fetches from them.  The GMP text-based input functions are affected. 
</ul>

<p><hr>
Node:<a name="Useful%20Macros%20and%20Constants">Useful Macros and Constants</a>,
Next:<a rel=next accesskey=n href="#Compatibility%20with%20older%20versions">Compatibility with older versions</a>,
Previous:<a rel=previous accesskey=p href="#Reentrancy">Reentrancy</a>,
Up:<a rel=up accesskey=u href="#GMP%20Basics">GMP Basics</a>
<br>

<h3>Useful Macros and Constants</h3>

<p>
<table width="100%">
<tr>
<td align="left">const int <b>mp_bits_per_limb</b><i>
</i></td>
<td align="right">Global Constant</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The number of bits per limb. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left"><b>__GNU_MP_VERSION</b><i>
</i></td>
<td align="right">Macro</td>
</tr>

<tr>
<td align="left"><b>__GNU_MP_VERSION_MINOR</b><i>
</i></td>
<td align="right">Macro</td>
</tr>

<tr>
<td align="left"><b>__GNU_MP_VERSION_PATCHLEVEL</b><i>
</i></td>
<td align="right">Macro</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The major and minor GMP version, and patch level, respectively, as integers. 
For GMP i.j, these numbers will be i, j, and 0, respectively. 
For GMP i.j.k, these numbers will be i, j, and k, respectively. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">const char * const <b>gmp_version</b><i>
</i></td>
<td align="right">Global Constant</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The GMP version number, as a null-terminated string, in the form "i.j" or
"i.j.k".  This release is <code>"4.1"</code>. 
</td></tr>
</table>

<p><hr>
Node:<a name="Compatibility%20with%20older%20versions">Compatibility with older versions</a>,
Next:<a rel=next accesskey=n href="#Efficiency">Efficiency</a>,
Previous:<a rel=previous accesskey=p href="#Useful%20Macros%20and%20Constants">Useful Macros and Constants</a>,
Up:<a rel=up accesskey=u href="#GMP%20Basics">GMP Basics</a>
<br>

<h3>Compatibility with older versions</h3>

<p>This version of GMP is upwardly binary compatible with all 4.x and 3.x
versions, and upwardly compatible at the source level with all 2.x versions,
with the following exceptions.

<ul>
<li><code>mpn_gcd</code> had its source arguments swapped as of GMP 3.0, for consistency
with other <code>mpn</code> functions.

<li><code>mpf_get_prec</code> counted precision slightly differently in GMP 3.0 and
3.0.1, but in 3.1 reverted to the 2.x style. 
</ul>

<p>There are a number of compatibility issues between GMP 1 and GMP 2 that of
course also apply when porting applications from GMP 1 to GMP 4.  Please
see the GMP 2 manual for details.

<p>The Berkeley MP compatibility library (see <a href="#BSD%20Compatible%20Functions">BSD Compatible Functions</a>) is
source and binary compatible with the standard <code>libmp</code>.

<p><hr>
Node:<a name="Efficiency">Efficiency</a>,
Next:<a rel=next accesskey=n href="#Debugging">Debugging</a>,
Previous:<a rel=previous accesskey=p href="#Compatibility%20with%20older%20versions">Compatibility with older versions</a>,
Up:<a rel=up accesskey=u href="#GMP%20Basics">GMP Basics</a>
<br>

<h3>Efficiency</h3>

<dl>
<dt>Small operands
<dd>On small operands, the time for function call overheads and memory allocation
can be significant in comparison to actual calculation.  This is unavoidable
in a general purpose variable precision library, although GMP attempts to be
as efficient as it can on both large and small operands.

<br><dt>Static Linking
<dd>On some CPUs, in particular the x86s, the static <code>libgmp.a</code> should be
used for maximum speed, since the PIC code in the shared <code>libgmp.so</code> will
have a small overhead on each function call and global data address.  For many
programs this will be insignificant, but for long calculations there's a gain
to be had.

<br><dt>Initializing and clearing
<dd>Avoid excessive initializing and clearing of variables, since this can be
quite time consuming, especially in comparison to otherwise fast operations
like addition.

<p>A language interpreter might want to keep a free list or stack of
initialized variables ready for use.  It should be possible to integrate
something like that with a garbage collector too.

<br><dt>Reallocations
<dd>An <code>mpz_t</code> or <code>mpq_t</code> variable used to hold successively increasing
values will have its memory repeatedly <code>realloc</code>ed, which could be quite
slow or could fragment memory, depending on the C library.  If an application
can estimate the final size then <code>mpz_init2</code> or <code>mpz_realloc2</code> can
be called to allocate the necessary space from the beginning
(see <a href="#Initializing%20Integers">Initializing Integers</a>).

<p>It doesn't matter if a size set with <code>mpz_init2</code> or <code>mpz_realloc2</code>
is too small, since all functions will do a further reallocation if necessary. 
Badly overestimating memory required will waste space though.

<br><dt><code>2exp</code> functions
<dd>It's up to an application to call functions like <code>mpz_mul_2exp</code> when
appropriate.  General purpose functions like <code>mpz_mul</code> make no attempt to
identify powers of two or other special forms, because such inputs will
usually be very rare and testing every time would be wasteful.

<br><dt><code>ui</code> and <code>si</code> functions
<dd>The <code>ui</code> functions and the small number of <code>si</code> functions exist for
convenience and should be used where applicable.  But if for example an
<code>mpz_t</code> contains a value that fits in an <code>unsigned long</code> there's no
need extract it and call a <code>ui</code> function, just use the regular <code>mpz</code>
function.

<br><dt>In-Place Operations
<dd><code>mpz_abs</code>, <code>mpq_abs</code>, <code>mpf_abs</code>, <code>mpz_neg</code>, <code>mpq_neg</code>
and <code>mpf_neg</code> are fast when used for in-place operations like
<code>mpz_abs(x,x)</code>, since in the current implementation only a single field
of <code>x</code> needs changing.  On suitable compilers (GCC for instance) this is
inlined too.

<p><code>mpz_add_ui</code>, <code>mpz_sub_ui</code>, <code>mpf_add_ui</code> and <code>mpf_sub_ui</code>
benefit from an in-place operation like <code>mpz_add_ui(x,x,y)</code>, since
usually only one or two limbs of <code>x</code> will need to be changed.  The same
applies to the full precision <code>mpz_add</code> etc if <code>y</code> is small.  If
<code>y</code> is big then cache locality may be helped, but that's all.

<p><code>mpz_mul</code> is currently the opposite, a separate destination is slightly
better.  A call like <code>mpz_mul(x,x,y)</code> will, unless <code>y</code> is only one
limb, make a temporary copy of <code>x</code> before forming the result.  Normally
that copying will only be a tiny fraction of the time for the multiply, so
this is not a particularly important consideration.

<p><code>mpz_set</code>, <code>mpq_set</code>, <code>mpq_set_num</code>, <code>mpf_set</code>, etc, make
no attempt to recognise a copy of something to itself, so a call like
<code>mpz_set(x,x)</code> will be wasteful.  Naturally that would never be written
deliberately, but if it might arise from two pointers to the same object then
a test to avoid it might be desirable.

<br><pre>if (x != y)
  mpz_set (x, y);
</pre>

<p>Note that it's never worth introducing extra <code>mpz_set</code> calls just to get
in-place operations.  If a result should go to a particular variable then just
direct it there and let GMP take care of data movement.

<br><dt>Divisibility Testing (Small Integers)
<dd>
<code>mpz_divisible_ui_p</code> and <code>mpz_congruent_ui_p</code> are the best functions
for testing whether an <code>mpz_t</code> is divisible by an individual small
integer.  They use an algorithm which is faster than <code>mpz_tdiv_ui</code>, but
which gives no useful information about the actual remainder, only whether
it's zero (or a particular value).

<p>However when testing divisibility by several small integers, it's best to take
a remainder modulo their product, to save multi-precision operations.  For
instance to test whether a number is divisible by any of 23, 29 or 31 take a
remainder modulo 23*29*31 = 20677 and then test that.

<p>The division functions like <code>mpz_tdiv_q_ui</code> which give a quotient as well
as a remainder are generally a little slower than the remainder-only functions
like <code>mpz_tdiv_ui</code>.  If the quotient is only rarely wanted then it's
probably best to just take a remainder and then go back and calculate the
quotient if and when it's wanted (<code>mpz_divexact_ui</code> can be used if the
remainder is zero).

<br><dt>Rational Arithmetic
<dd>The <code>mpq</code> functions operate on <code>mpq_t</code> values with no common factors
in the numerator and denominator.  Common factors are checked-for and cast out
as necessary.  In general, cancelling factors every time is the best approach
since it minimizes the sizes for subsequent operations.

<p>However, applications that know something about the factorization of the
values they're working with might be able to avoid some of the GCDs used for
canonicalization, or swap them for divisions.  For example when multiplying by
a prime it's enough to check for factors of it in the denominator instead of
doing a full GCD.  Or when forming a big product it might be known that very
little cancellation will be possible, and so canonicalization can be left to
the end.

<p>The <code>mpq_numref</code> and <code>mpq_denref</code> macros give access to the
numerator and denominator to do things outside the scope of the supplied
<code>mpq</code> functions.  See <a href="#Applying%20Integer%20Functions">Applying Integer Functions</a>.

<p>The canonical form for rationals allows mixed-type <code>mpq_t</code> and integer
additions or subtractions to be done directly with multiples of the
denominator.  This will be somewhat faster than <code>mpq_add</code>.  For example,

<br><pre>/* mpq increment */
mpz_add (mpq_numref(q), mpq_numref(q), mpq_denref(q));

/* mpq += unsigned long */
mpz_addmul_ui (mpq_numref(q), mpq_denref(q), 123UL);

/* mpq -= mpz */
mpz_submul (mpq_numref(q), mpq_denref(q), z);
</pre>

<br><dt>Number Sequences
<dd>Functions like <code>mpz_fac_ui</code>, <code>mpz_fib_ui</code> and <code>mpz_bin_uiui</code>
are designed for calculating isolated values.  If a range of values is wanted
it's probably best to call to get a starting point and iterate from there.

<br><dt>Text Input/Output
<dd>Hexadecimal or octal are suggested for input or output in text form. 
Power-of-2 bases like these can be converted much more efficiently than other
bases, like decimal.  For big numbers there's usually nothing of particular
interest to be seen in the digits, so the base doesn't matter much.

<p>Maybe we can hope octal will one day become the normal base for everyday use,
as proposed by King Charles XII of Sweden and later reformers. 
</dl>

<p><hr>
Node:<a name="Debugging">Debugging</a>,
Next:<a rel=next accesskey=n href="#Profiling">Profiling</a>,
Previous:<a rel=previous accesskey=p href="#Efficiency">Efficiency</a>,
Up:<a rel=up accesskey=u href="#GMP%20Basics">GMP Basics</a>
<br>

<h3>Debugging</h3>

<dl>
<dt>Stack Overflow
<dd>Depending on the system, a segmentation violation or bus error might be the
only indication of stack overflow.  See <code>--enable-alloca</code> choices in
<a href="#Build%20Options">Build Options</a>, for how to address this.

<br><dt>Heap Problems
<dd>The most likely cause of application problems with GMP is heap corruption. 
Failing to <code>init</code> GMP variables will have unpredictable effects, and
corruption arising elsewhere in a program may well affect GMP.  Initializing
GMP variables more than once or failing to clear them will cause memory leaks.

<p>In all such cases a malloc debugger is recommended.  On a GNU or BSD system
the standard C library <code>malloc</code> has some diagnostic facilities, see
<a href="libc.html#Allocation%20Debugging">Allocation Debugging</a>, or
<code>man 3 malloc</code>.  Other possibilities, in no particular order, include

<br><pre><a href="http://www.inf.ethz.ch/personal/biere/projects/ccmalloc">http://www.inf.ethz.ch/personal/biere/projects/ccmalloc</a>
<a href="http://quorum.tamu.edu/jon/gnu">http://quorum.tamu.edu/jon/gnu</a>  (debauch)
<a href="http://dmalloc.com">http://dmalloc.com</a>
<a href="http://www.perens.com/FreeSoftware">http://www.perens.com/FreeSoftware</a>  (electric fence)
<a href="http://packages.debian.org/fda">http://packages.debian.org/fda</a>
<a href="http://www.gnupdate.org/components/leakbug">http://www.gnupdate.org/components/leakbug</a>
<a href="http://people.redhat.com/~otaylor/memprof">http://people.redhat.com/~otaylor/memprof</a>
<a href="http://www.cbmamiga.demon.co.uk/mpatrol">http://www.cbmamiga.demon.co.uk/mpatrol</a>
</pre>

<p>The GMP default allocation routines in <code>memory.c</code> also have a simple
sentinel scheme which can be enabled with <code>#define DEBUG</code> in that file. 
This is mainly designed for detecting buffer overruns during GMP development,
but might find other uses.

<br><dt>Stack Backtraces
<dd>On some systems the compiler options GMP uses by default can interfere with
debugging.  In particular on x86 and 68k systems <code>-fomit-frame-pointer</code>
is used and this generally inhibits stack backtracing.  Recompiling without
such options may help while debugging, though the usual caveats about it
potentially moving a memory problem or hiding a compiler bug will apply.

<br><dt>GNU Debugger
<dd>A sample <code>.gdbinit</code> is included in the distribution, showing how to call
some undocumented dump functions to print GMP variables from within GDB.  Note
that these functions shouldn't be used in final application code since they're
undocumented and may be subject to incompatible changes in future versions of
GMP.

<br><dt>Source File Paths
<dd>GMP has multiple source files with the same name, in different directories. 
For example <code>mpz</code>, <code>mpq</code>, <code>mpf</code> and <code>mpfr</code> each have an
<code>init.c</code>.  If the debugger can't already determine the right one it may
help to build with absolute paths on each C file.  One way to do that is to
use a separate object directory with an absolute path to the source directory.

<br><pre>cd /my/build/dir
/my/source/dir/gmp-4.1/configure
</pre>

<p>This works via <code>VPATH</code>, and might require GNU <code>make</code>. 
Alternately it might be possible to change the <code>.c.lo</code> rules
appropriately.

<br><dt>Assertion Checking
<dd>The build option <code>--enable-assert</code> is available to add some consistency
checks to the library (see <a href="#Build%20Options">Build Options</a>).  These are likely to be of
limited value to most applications.  Assertion failures are just as likely to
indicate memory corruption as a library or compiler bug.

<p>Applications using the low-level <code>mpn</code> functions, however, will benefit
from <code>--enable-assert</code> since it adds checks on the parameters of most
such functions, many of which have subtle restrictions on their usage.  Note
however that only the generic C code has checks, not the assembler code, so
CPU <code>none</code> should be used for maximum checking.

<br><dt>Temporary Memory Checking
<dd>The build option <code>--enable-alloca=debug</code> arranges that each block of
temporary memory in GMP is allocated with a separate call to <code>malloc</code> (or
the allocation function set with <code>mp_set_memory_functions</code>).

<p>This can help a malloc debugger detect accesses outside the intended bounds,
or detect memory not released.  In a normal build, on the other hand,
temporary memory is allocated in blocks which GMP divides up for its own use,
or may be allocated with a compiler builtin <code>alloca</code> which will go
nowhere near any malloc debugger hooks.

<br><dt>Checker
<dd>The checker program (<a href="http://savannah.gnu.org/projects/checker">http://savannah.gnu.org/projects/checker</a>) can be
used with GMP.  It contains a stub library which means GMP applications
compiled with checker can use a normal GMP build.

<p>A build of GMP with checking within GMP itself can be made.  This will run
very very slowly.  Configure with

<br><pre>./configure --host=none-pc-linux-gnu CC=checkergcc
</pre>

<p><code>--host=none</code> must be used, since the GMP assembler code doesn't support
the checking scheme.  The GMP C++ features cannot be used, since current
versions of checker (0.9.9.1) don't yet support the standard C++ library.

<br><dt>Valgrind
<dd>The valgrind program (<a href="http://devel-home.kde.org/~sewardj">http://devel-home.kde.org/~sewardj</a>) is a memory
checker for x86s.  It translates and emulates machine instructions to do
strong checks for uninitialized data (at the level of individual bits), memory
accesses through bad pointers, and memory leaks.

<p>Current versions (20020226 snapshot) don't support MMX or SSE, so GMP must be
configured for an x86 without those (eg. plain <code>i386</code>), or with a special
<code>MPN_PATH</code> that excludes those subdirectories (see <a href="#Build%20Options">Build Options</a>).

<br><dt>Other Problems
<dd>Any suspected bug in GMP itself should be isolated to make sure it's not an
application problem, see <a href="#Reporting%20Bugs">Reporting Bugs</a>. 
</dl>

<p><hr>
Node:<a name="Profiling">Profiling</a>,
Next:<a rel=next accesskey=n href="#Autoconf">Autoconf</a>,
Previous:<a rel=previous accesskey=p href="#Debugging">Debugging</a>,
Up:<a rel=up accesskey=u href="#GMP%20Basics">GMP Basics</a>
<br>

<h3>Profiling</h3>

<p>Running a program under a profiler is a good way to find where it's spending
most time and where improvements can be best sought.

<p>Depending on the system, it may be possible to get a flat profile, meaning
simple timer sampling of the program counter, with no special GMP build
options, just a <code>-p</code> when compiling the mainline.  This is a good way to
ensure minimum interference with normal operation.  The necessary symbol type
and size information exists in most of the GMP assembler code.

<p>The <code>--enable-profiling</code> build option can be used to add suitable
compiler flags, either for <code>prof</code> (<code>-p</code>) or <code>gprof</code>
(<code>-pg</code>), see <a href="#Build%20Options">Build Options</a>.  Which of the two is available and what
they do will depend on the system, and possibly on support available in
<code>libc</code>.  For some systems appropriate corresponding <code>mcount</code> calls
are added to the assembler code too.

<p>On x86 systems <code>prof</code> gives call counting, so that average time spent
in a function can be determined.  <code>gprof</code>, where supported, adds call
graph construction, so for instance calls to <code>mpn_add_n</code> from
<code>mpz_add</code> and from <code>mpz_mul</code> can be differentiated.

<p>On x86 and 68k systems <code>-pg</code> and <code>-fomit-frame-pointer</code> are
incompatible, so the latter is not used when <code>gprof</code> profiling is
selected, which may result in poorer code generation.  If <code>prof</code>
profiling is selected instead it should still be possible to use
<code>gprof</code>, but only the <code>gprof -p</code> flat profile and call counts can
be expected to be valid, not the <code>gprof -q</code> call graph.

<p><hr>
Node:<a name="Autoconf">Autoconf</a>,
Previous:<a rel=previous accesskey=p href="#Profiling">Profiling</a>,
Up:<a rel=up accesskey=u href="#GMP%20Basics">GMP Basics</a>
<br>

<h3>Autoconf</h3>

<p>Autoconf based applications can easily check whether GMP is installed.  The
only thing to be noted is that GMP library symbols from version 3 onwards have
prefixes like <code>__gmpz</code>.  The following therefore would be a simple test,

<br><pre>AC_CHECK_LIB(gmp, __gmpz_init)
</pre>

<p>This just uses the default <code>AC_CHECK_LIB</code> actions for found or not found,
but an application that must have GMP would want to generate an error if not
found.  For example,

<br><pre>AC_CHECK_LIB(gmp, __gmpz_init, , [AC_MSG_ERROR(
[GNU MP not found, see http://swox.com/gmp])])
</pre>

<p>If functions added in some particular version of GMP are required, then one of
those can be used when checking.  For example <code>mpz_mul_si</code> was added in
GMP 3.1,

<br><pre>AC_CHECK_LIB(gmp, __gmpz_mul_si, , [AC_MSG_ERROR(
[GNU MP not found, or not 3.1 or up, see http://swox.com/gmp])])
</pre>

<p>An alternative would be to test the version number in <code>gmp.h</code> using say
<code>AC_EGREP_CPP</code>.  That would make it possible to test the exact version,
if some particular sub-minor release is known to be necessary.

<p>An application that can use either GMP 2 or 3 will need to test for
<code>__gmpz_init</code> (GMP 3 and up) or <code>mpz_init</code> (GMP 2), and it's also
worth checking for <code>libgmp2</code> since Debian GNU/Linux systems used that
name in the past.  For example,

<br><pre>AC_CHECK_LIB(gmp, __gmpz_init, ,
  [AC_CHECK_LIB(gmp, mpz_init, ,
    [AC_CHECK_LIB(gmp2, mpz_init)])])
</pre>

<p>In general it's suggested that applications should simply demand a new enough
GMP rather than trying to provide supplements for features not available in
past versions.

<p>Occasionally an application will need or want to know the size of a type at
configuration or preprocessing time, not just with <code>sizeof</code> in the code. 
This can be done in the normal way with <code>mp_limb_t</code> etc, but GMP 4.0 or
up is best for this, since prior versions needed certain <code>-D</code> defines on
systems using a <code>long long</code> limb.  The following would suit Autoconf 2.50
or up,

<br><pre>AC_CHECK_SIZEOF(mp_limb_t, , [#include &lt;gmp.h&gt;])
</pre>

<p>The optional <code>mpfr</code> functions are provided in a separate
<code>libmpfr.a</code>, and this might be from GMP with <code>--enable-mpfr</code> or
from MPFR installed separately.  Either way <code>libmpfr</code> depends on
<code>libgmp</code>, it doesn't stand alone.  Currently only a static
<code>libmpfr.a</code> will be available, not a shared library, since upward binary
compatibility is not guaranteed.

<br><pre>AC_CHECK_LIB(mpfr, mpfr_add, , [AC_MSG_ERROR(
[Need MPFR either from GNU MP 4 or separate MPFR package.
See http://www.mpfr.org or http://swox.com/gmp])
</pre>

<p><hr>
Node:<a name="Reporting%20Bugs">Reporting Bugs</a>,
Next:<a rel=next accesskey=n href="#Integer%20Functions">Integer Functions</a>,
Previous:<a rel=previous accesskey=p href="#GMP%20Basics">GMP Basics</a>,
Up:<a rel=up accesskey=u href="#Top">Top</a>
<br>

<h2>Reporting Bugs</h2>

<p>If you think you have found a bug in the GMP library, please investigate it
and report it.  We have made this library available to you, and it is not too
much to ask you to report the bugs you find.

<p>Before you report a bug, check it's not already addressed in <a href="#Known%20Build%20Problems">Known Build Problems</a>, or perhaps <a href="#Notes%20for%20Particular%20Systems">Notes for Particular Systems</a>.  You may also want
to check <a href="http://swox.com/gmp/">http://swox.com/gmp/</a> for patches for this release.

<p>Please include the following in any report,

<ul>
<li>The GMP version number, and if pre-packaged or patched then say so.

<li>A test program that makes it possible for us to reproduce the bug.  Include
instructions on how to run the program.

<li>A description of what is wrong.  If the results are incorrect, in what way. 
If you get a crash, say so.

<li>If you get a crash, include a stack backtrace from the debugger if it's
informative (<code>where</code> in <code>gdb</code>, or <code>$C</code> in <code>adb</code>).

<li>Please do not send core dumps, executables or <code>strace</code>s.

<li>The configuration options you used when building GMP, if any.

<li>The name of the compiler and its version.  For <code>gcc</code>, get the version
with <code>gcc -v</code>, otherwise perhaps <code>what `which cc`</code>, or similar.

<li>The output from running <code>uname -a</code>.

<li>The output from running <code>./config.guess</code>, and from running
<code>./configfsf.guess</code> (might be the same).

<li>If the bug is related to <code>configure</code>, then the contents of
<code>config.log</code>.

<li>If the bug is related to an <code>asm</code> file not assembling, then the contents
of <code>config.m4</code> and the offending line or lines from the temporary
<code>mpn/tmp-&lt;file&gt;.s</code>. 
</ul>

<p>Please make an effort to produce a self-contained report, with something
definite that can be tested or debugged.  Vague queries or piecemeal messages
are difficult to act on and don't help the development effort.

<p>It is not uncommon that an observed problem is actually due to a bug in the
compiler; the GMP code tends to explore interesting corners in compilers.

<p>If your bug report is good, we will do our best to help you get a corrected
version of the library; if the bug report is poor, we won't do anything about
it (except maybe ask you to send a better report).

<p>Send your report to: <a href="mailto:bug-gmp@gnu.org">bug-gmp@gnu.org</a>.

<p>If you think something in this manual is unclear, or downright incorrect, or if
the language needs to be improved, please send a note to the same address.

<p><hr>
Node:<a name="Integer%20Functions">Integer Functions</a>,
Next:<a rel=next accesskey=n href="#Rational%20Number%20Functions">Rational Number Functions</a>,
Previous:<a rel=previous accesskey=p href="#Reporting%20Bugs">Reporting Bugs</a>,
Up:<a rel=up accesskey=u href="#Top">Top</a>
<br>

<h2>Integer Functions</h2>

<p>This chapter describes the GMP functions for performing integer arithmetic. 
These functions start with the prefix <code>mpz_</code>.

<p>GMP integers are stored in objects of type <code>mpz_t</code>.

<ul>
<li><a accesskey=1 href="#Initializing%20Integers">Initializing Integers</a>: 
<li><a accesskey=2 href="#Assigning%20Integers">Assigning Integers</a>: 
<li><a accesskey=3 href="#Simultaneous%20Integer%20Init%20&amp;%20Assign">Simultaneous Integer Init &amp; Assign</a>: 
<li><a accesskey=4 href="#Converting%20Integers">Converting Integers</a>: 
<li><a accesskey=5 href="#Integer%20Arithmetic">Integer Arithmetic</a>: 
<li><a accesskey=6 href="#Integer%20Division">Integer Division</a>: 
<li><a accesskey=7 href="#Integer%20Exponentiation">Integer Exponentiation</a>: 
<li><a accesskey=8 href="#Integer%20Roots">Integer Roots</a>: 
<li><a accesskey=9 href="#Number%20Theoretic%20Functions">Number Theoretic Functions</a>: 
<li><a href="#Integer%20Comparisons">Integer Comparisons</a>: 
<li><a href="#Integer%20Logic%20and%20Bit%20Fiddling">Integer Logic and Bit Fiddling</a>: 
<li><a href="#I%2fO%20of%20Integers">I/O of Integers</a>: 
<li><a href="#Integer%20Random%20Numbers">Integer Random Numbers</a>: 
<li><a href="#Integer%20Import%20and%20Export">Integer Import and Export</a>: 
<li><a href="#Miscellaneous%20Integer%20Functions">Miscellaneous Integer Functions</a>: 
</ul>

<p><hr>
Node:<a name="Initializing%20Integers">Initializing Integers</a>,
Next:<a rel=next accesskey=n href="#Assigning%20Integers">Assigning Integers</a>,
Previous:<a rel=previous accesskey=p href="#Integer%20Functions">Integer Functions</a>,
Up:<a rel=up accesskey=u href="#Integer%20Functions">Integer Functions</a>
<br>

<h3>Initialization Functions</h3>

<p>The functions for integer arithmetic assume that all integer objects are
initialized.  You do that by calling the function <code>mpz_init</code>.  For
example,

<br><pre>{
  mpz_t integ;
  mpz_init (integ);
  <small>...</small>
  mpz_add (integ, <small>...</small>);
  <small>...</small>
  mpz_sub (integ, <small>...</small>);

  /* Unless the program is about to exit, do ... */
  mpz_clear (integ);
}
</pre>

<p>As you can see, you can store new values any number of times, once an
object is initialized.

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpz_init</b><i> (mpz_t <var>integer</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Initialize <var>integer</var>, and set its value to 0. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpz_init2</b><i> (mpz_t <var>integer</var>, unsigned long <var>n</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Initialize <var>integer</var>, with space for <var>n</var> bits, and set its value to 0.

<p><var>n</var> is only the initial space, <var>integer</var> will grow automatically in
the normal way, if necessary, for subsequent values stored.  <code>mpz_init2</code>
makes it possible to avoid such reallocations if a maximum size is known in
advance. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpz_clear</b><i> (mpz_t <var>integer</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Free the space occupied by <var>integer</var>.  Call this function for all
<code>mpz_t</code> variables when you are done with them. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpz_realloc2</b><i> (mpz_t <var>integer</var>, unsigned long <var>n</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Change the space allocated for <var>integer</var> to <var>n</var> bits.  The value in
<var>integer</var> is preserved if it fits, or is set to 0 if not.

<p>This function can be used to increase the space for a variable in order to
avoid repeated automatic reallocations, or to decrease it to give memory back
to the heap. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpz_array_init</b><i> (mpz_t <var>integer_array</var>[], size_t <var>array_size</var>, mp_size_t&nbsp;<var>fixed_num_bits</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
This is a special type of initialization.  <strong>Fixed</strong> space of
<var>fixed_num_bits</var> bits is allocated to each of the <var>array_size</var>
integers in <var>integer_array</var>.

<p>The space will not be automatically increased, unlike the normal
<code>mpz_init</code>, but instead an application must ensure it's sufficient for
any value stored.  The following space requirements apply to various
functions,

<ul>
<li><code>mpz_abs</code>, <code>mpz_neg</code>, <code>mpz_set</code>, <code>mpz_set_si</code> and
<code>mpz_set_ui</code> need room for the value they store.

<li><code>mpz_add</code>, <code>mpz_add_ui</code>, <code>mpz_sub</code> and <code>mpz_sub_ui</code> need
room for the larger of the two operands, plus an extra
<code>mp_bits_per_limb</code>.

<li><code>mpz_mul</code>, <code>mpz_mul_ui</code> and <code>mpz_mul_ui</code> need room for the sum
of the number of bits in their operands, but each rounded up to a multiple of
<code>mp_bits_per_limb</code>.

<li><code>mpz_swap</code> can be used between two array variables, but not between an
array and a normal variable. 
</ul>

<p>For other functions, or if in doubt, the suggestion is to calculate in a
regular <code>mpz_init</code> variable and copy the result to an array variable with
<code>mpz_set</code>.

<p><code>mpz_array_init</code> can reduce memory usage in algorithms that need large
arrays of integers, since it avoids allocating and reallocating lots of small
memory blocks.  There is no way to free the storage allocated by this
function.  Don't call <code>mpz_clear</code>! 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void * <b>_mpz_realloc</b><i> (mpz_t <var>integer</var>, mp_size_t <var>new_alloc</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Change the space for <var>integer</var> to <var>new_alloc</var> limbs.  The value in
<var>integer</var> is preserved if it fits, or is set to 0 if not.  The return
value is not useful to applications and should be ignored.

<p><code>mpz_realloc2</code> is the preferred way to accomplish allocation changes like
this.  <code>mpz_realloc2</code> and <code>_mpz_realloc</code> are the same except that
<code>_mpz_realloc</code> takes the new size in limbs. 
</td></tr>
</table>

<p><hr>
Node:<a name="Assigning%20Integers">Assigning Integers</a>,
Next:<a rel=next accesskey=n href="#Simultaneous%20Integer%20Init%20&amp;%20Assign">Simultaneous Integer Init & Assign</a>,
Previous:<a rel=previous accesskey=p href="#Initializing%20Integers">Initializing Integers</a>,
Up:<a rel=up accesskey=u href="#Integer%20Functions">Integer Functions</a>
<br>

<h3>Assignment Functions</h3>

<p>These functions assign new values to already initialized integers
(see <a href="#Initializing%20Integers">Initializing Integers</a>).

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpz_set</b><i> (mpz_t <var>rop</var>, mpz_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpz_set_ui</b><i> (mpz_t <var>rop</var>, unsigned long int <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpz_set_si</b><i> (mpz_t <var>rop</var>, signed long int <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpz_set_d</b><i> (mpz_t <var>rop</var>, double <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpz_set_q</b><i> (mpz_t <var>rop</var>, mpq_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpz_set_f</b><i> (mpz_t <var>rop</var>, mpf_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set the value of <var>rop</var> from <var>op</var>.

<p><code>mpz_set_d</code>, <code>mpz_set_q</code> and <code>mpz_set_f</code> truncate <var>op</var> to
make it an integer. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>mpz_set_str</b><i> (mpz_t <var>rop</var>, char *<var>str</var>, int <var>base</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set the value of <var>rop</var> from <var>str</var>, a null-terminated C string in base
<var>base</var>.  White space is allowed in the string, and is simply ignored.  The
base may vary from 2 to 36.  If <var>base</var> is 0, the actual base is determined
from the leading characters: if the first two characters are "0x" or "0X",
hexadecimal is assumed, otherwise if the first character is "0", octal is
assumed, otherwise decimal is assumed.

<p>This function returns 0 if the entire string is a valid number in base
<var>base</var>.  Otherwise it returns -1.

<p>[It turns out that it is not entirely true that this function ignores
white-space.  It does ignore it between digits, but not after a minus sign or
within or after "0x".  We are considering changing the definition of this
function, making it fail when there is any white-space in the input, since
that makes a lot of sense.  Send your opinion of this change to
<a href="mailto:bug-gmp@gnu.org">bug-gmp@gnu.org</a>.  Do you really want it to accept <code>"3 14"</code> as
meaning 314 as it does now?] 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpz_swap</b><i> (mpz_t <var>rop1</var>, mpz_t <var>rop2</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Swap the values <var>rop1</var> and <var>rop2</var> efficiently. 
</td></tr>
</table>

<p><hr>
Node:<a name="Simultaneous%20Integer%20Init%20&amp;%20Assign">Simultaneous Integer Init & Assign</a>,
Next:<a rel=next accesskey=n href="#Converting%20Integers">Converting Integers</a>,
Previous:<a rel=previous accesskey=p href="#Assigning%20Integers">Assigning Integers</a>,
Up:<a rel=up accesskey=u href="#Integer%20Functions">Integer Functions</a>
<br>

<h3>Combined Initialization and Assignment Functions</h3>

<p>For convenience, GMP provides a parallel series of initialize-and-set functions
which initialize the output and then store the value there.  These functions'
names have the form <code>mpz_init_set<small>...</small></code>

<p>Here is an example of using one:

<br><pre>{
  mpz_t pie;
  mpz_init_set_str (pie, "3141592653589793238462643383279502884", 10);
  <small>...</small>
  mpz_sub (pie, <small>...</small>);
  <small>...</small>
  mpz_clear (pie);
}
</pre>

<p>Once the integer has been initialized by any of the <code>mpz_init_set<small>...</small></code>
functions, it can be used as the source or destination operand for the ordinary
integer functions.  Don't use an initialize-and-set function on a variable
already initialized!

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpz_init_set</b><i> (mpz_t <var>rop</var>, mpz_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpz_init_set_ui</b><i> (mpz_t <var>rop</var>, unsigned long int <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpz_init_set_si</b><i> (mpz_t <var>rop</var>, signed long int <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpz_init_set_d</b><i> (mpz_t <var>rop</var>, double <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Initialize <var>rop</var> with limb space and set the initial numeric value from
<var>op</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>mpz_init_set_str</b><i> (mpz_t <var>rop</var>, char *<var>str</var>, int <var>base</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Initialize <var>rop</var> and set its value like <code>mpz_set_str</code> (see its
documentation above for details).

<p>If the string is a correct base <var>base</var> number, the function returns 0;
if an error occurs it returns -1.  <var>rop</var> is initialized even if
an error occurs.  (I.e., you have to call <code>mpz_clear</code> for it.) 
</td></tr>
</table>

<p><hr>
Node:<a name="Converting%20Integers">Converting Integers</a>,
Next:<a rel=next accesskey=n href="#Integer%20Arithmetic">Integer Arithmetic</a>,
Previous:<a rel=previous accesskey=p href="#Simultaneous%20Integer%20Init%20&amp;%20Assign">Simultaneous Integer Init & Assign</a>,
Up:<a rel=up accesskey=u href="#Integer%20Functions">Integer Functions</a>
<br>

<h3>Conversion Functions</h3>

<p>This section describes functions for converting GMP integers to standard C
types.  Functions for converting <em>to</em> GMP integers are described in
<a href="#Assigning%20Integers">Assigning Integers</a> and <a href="#I%2fO%20of%20Integers">I/O of Integers</a>.

<p>
<table width="100%">
<tr>
<td align="left">unsigned long int <b>mpz_get_ui</b><i> (mpz_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Return the value of <var>op</var> as an <code>unsigned long</code>.

<p>If <var>op</var> is too big to fit an <code>unsigned long</code> then just the least
significant bits that do fit are returned.  The sign of <var>op</var> is ignored,
only the absolute value is used. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">signed long int <b>mpz_get_si</b><i> (mpz_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
If <var>op</var> fits into a <code>signed long int</code> return the value of <var>op</var>. 
Otherwise return the least significant part of <var>op</var>, with the same sign
as <var>op</var>.

<p>If <var>op</var> is too big to fit in a <code>signed long int</code>, the returned
result is probably not very useful.  To find out if the value will fit, use
the function <code>mpz_fits_slong_p</code>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">double <b>mpz_get_d</b><i> (mpz_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Convert <var>op</var> to a <code>double</code>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">double <b>mpz_get_d_2exp</b><i> (signed long int *<var>exp</var>, mpz_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Find <var>d</var> and <var>exp</var> such that <var>d</var> times 2
raised to <var>exp</var>, with 0.5&lt;=abs(<var>d</var>)&lt;1, is a good
approximation to <var>op</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">char * <b>mpz_get_str</b><i> (char *<var>str</var>, int <var>base</var>, mpz_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Convert <var>op</var> to a string of digits in base <var>base</var>.  The base may vary
from 2 to 36.

<p>If <var>str</var> is <code>NULL</code>, the result string is allocated using the current
allocation function (see <a href="#Custom%20Allocation">Custom Allocation</a>).  The block will be
<code>strlen(str)+1</code> bytes, that being exactly enough for the string and
null-terminator.

<p>If <var>str</var> is not <code>NULL</code>, it should point to a block of storage large
enough for the result, that being <code>mpz_sizeinbase (<var>op</var>, <var>base</var>)
+ 2</code>.  The two extra bytes are for a possible minus sign, and the
null-terminator.

<p>A pointer to the result string is returned, being either the allocated block,
or the given <var>str</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">mp_limb_t <b>mpz_getlimbn</b><i> (mpz_t <var>op</var>, mp_size_t <var>n</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Return limb number <var>n</var> from <var>op</var>.  The sign of <var>op</var> is ignored,
just the absolute value is used.  The least significant limb is number 0.

<p><code>mpz_size</code> can be used to find how many limbs make up <var>op</var>. 
<code>mpz_getlimbn</code> returns zero if <var>n</var> is outside the range 0 to
<code>mpz_size(<var>op</var>)-1</code>. 
</td></tr>
</table>

<p><hr>
Node:<a name="Integer%20Arithmetic">Integer Arithmetic</a>,
Next:<a rel=next accesskey=n href="#Integer%20Division">Integer Division</a>,
Previous:<a rel=previous accesskey=p href="#Converting%20Integers">Converting Integers</a>,
Up:<a rel=up accesskey=u href="#Integer%20Functions">Integer Functions</a>
<br>

<h3>Arithmetic Functions</h3>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpz_add</b><i> (mpz_t <var>rop</var>, mpz_t <var>op1</var>, mpz_t <var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpz_add_ui</b><i> (mpz_t <var>rop</var>, mpz_t <var>op1</var>, unsigned long int <var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>rop</var> to <var>op1</var> + <var>op2</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpz_sub</b><i> (mpz_t <var>rop</var>, mpz_t <var>op1</var>, mpz_t <var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpz_sub_ui</b><i> (mpz_t <var>rop</var>, mpz_t <var>op1</var>, unsigned long int <var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpz_ui_sub</b><i> (mpz_t <var>rop</var>, unsigned long int <var>op1</var>, mpz_t <var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>rop</var> to <var>op1</var> - <var>op2</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpz_mul</b><i> (mpz_t <var>rop</var>, mpz_t <var>op1</var>, mpz_t <var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpz_mul_si</b><i> (mpz_t <var>rop</var>, mpz_t <var>op1</var>, long int <var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpz_mul_ui</b><i> (mpz_t <var>rop</var>, mpz_t <var>op1</var>, unsigned long int <var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>rop</var> to <var>op1</var> times <var>op2</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpz_addmul</b><i> (mpz_t <var>rop</var>, mpz_t <var>op1</var>, mpz_t <var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpz_addmul_ui</b><i> (mpz_t <var>rop</var>, mpz_t <var>op1</var>, unsigned long int <var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>rop</var> to <var>rop</var> + <var>op1</var> times <var>op2</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpz_submul</b><i> (mpz_t <var>rop</var>, mpz_t <var>op1</var>, mpz_t <var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpz_submul_ui</b><i> (mpz_t <var>rop</var>, mpz_t <var>op1</var>, unsigned long int <var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>rop</var> to <var>rop</var> - <var>op1</var> times <var>op2</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpz_mul_2exp</b><i> (mpz_t <var>rop</var>, mpz_t <var>op1</var>, unsigned long int <var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>rop</var> to <var>op1</var> times 2 raised to
<var>op2</var>.  This operation can also be defined as a left shift by <var>op2</var>
bits. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpz_neg</b><i> (mpz_t <var>rop</var>, mpz_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>rop</var> to -<var>op</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpz_abs</b><i> (mpz_t <var>rop</var>, mpz_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>rop</var> to the absolute value of <var>op</var>. 
</td></tr>
</table>

<p><hr>
Node:<a name="Integer%20Division">Integer Division</a>,
Next:<a rel=next accesskey=n href="#Integer%20Exponentiation">Integer Exponentiation</a>,
Previous:<a rel=previous accesskey=p href="#Integer%20Arithmetic">Integer Arithmetic</a>,
Up:<a rel=up accesskey=u href="#Integer%20Functions">Integer Functions</a>
<br>

<h3>Division Functions</h3>

<p>Division is undefined if the divisor is zero.  Passing a zero divisor to the
division or modulo functions (including the modular powering functions
<code>mpz_powm</code> and <code>mpz_powm_ui</code>), will cause an intentional division by
zero.  This lets a program handle arithmetic exceptions in these functions the
same way as for normal C <code>int</code> arithmetic.

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpz_cdiv_q</b><i> (mpz_t <var>q</var>, mpz_t <var>n</var>, mpz_t <var>d</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpz_cdiv_r</b><i> (mpz_t <var>r</var>, mpz_t <var>n</var>, mpz_t <var>d</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpz_cdiv_qr</b><i> (mpz_t <var>q</var>, mpz_t <var>r</var>, mpz_t <var>n</var>, mpz_t <var>d</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<tr>
<td align="left">unsigned long int <b>mpz_cdiv_q_ui</b><i> (mpz_t <var>q</var>, mpz_t <var>n</var>, unsigned&nbsp;long&nbsp;int&nbsp;<var>d</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">unsigned long int <b>mpz_cdiv_r_ui</b><i> (mpz_t <var>r</var>, mpz_t <var>n</var>, unsigned&nbsp;long&nbsp;int&nbsp;<var>d</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">unsigned long int <b>mpz_cdiv_qr_ui</b><i> (mpz_t <var>q</var>, mpz_t <var>r</var>, mpz_t&nbsp;<var>n</var>, unsigned&nbsp;long&nbsp;int&nbsp;<var>d</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">unsigned long int <b>mpz_cdiv_ui</b><i> (mpz_t <var>n</var>, unsigned&nbsp;long&nbsp;int&nbsp;<var>d</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<tr>
<td align="left">void <b>mpz_cdiv_q_2exp</b><i> (mpz_t <var>q</var>, mpz_t <var>n</var>, unsigned&nbsp;long&nbsp;int&nbsp;<var>b</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpz_cdiv_r_2exp</b><i> (mpz_t <var>r</var>, mpz_t <var>n</var>, unsigned&nbsp;long&nbsp;int&nbsp;<var>b</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpz_fdiv_q</b><i> (mpz_t <var>q</var>, mpz_t <var>n</var>, mpz_t <var>d</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpz_fdiv_r</b><i> (mpz_t <var>r</var>, mpz_t <var>n</var>, mpz_t <var>d</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpz_fdiv_qr</b><i> (mpz_t <var>q</var>, mpz_t <var>r</var>, mpz_t <var>n</var>, mpz_t <var>d</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<tr>
<td align="left">unsigned long int <b>mpz_fdiv_q_ui</b><i> (mpz_t <var>q</var>, mpz_t <var>n</var>, unsigned&nbsp;long&nbsp;int&nbsp;<var>d</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">unsigned long int <b>mpz_fdiv_r_ui</b><i> (mpz_t <var>r</var>, mpz_t <var>n</var>, unsigned&nbsp;long&nbsp;int&nbsp;<var>d</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">unsigned long int <b>mpz_fdiv_qr_ui</b><i> (mpz_t <var>q</var>, mpz_t <var>r</var>, mpz_t&nbsp;<var>n</var>, unsigned&nbsp;long&nbsp;int&nbsp;<var>d</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">unsigned long int <b>mpz_fdiv_ui</b><i> (mpz_t <var>n</var>, unsigned&nbsp;long&nbsp;int&nbsp;<var>d</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<tr>
<td align="left">void <b>mpz_fdiv_q_2exp</b><i> (mpz_t <var>q</var>, mpz_t <var>n</var>, unsigned&nbsp;long&nbsp;int&nbsp;<var>b</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpz_fdiv_r_2exp</b><i> (mpz_t <var>r</var>, mpz_t <var>n</var>, unsigned&nbsp;long&nbsp;int&nbsp;<var>b</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpz_tdiv_q</b><i> (mpz_t <var>q</var>, mpz_t <var>n</var>, mpz_t <var>d</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpz_tdiv_r</b><i> (mpz_t <var>r</var>, mpz_t <var>n</var>, mpz_t <var>d</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpz_tdiv_qr</b><i> (mpz_t <var>q</var>, mpz_t <var>r</var>, mpz_t <var>n</var>, mpz_t <var>d</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<tr>
<td align="left">unsigned long int <b>mpz_tdiv_q_ui</b><i> (mpz_t <var>q</var>, mpz_t <var>n</var>, unsigned&nbsp;long&nbsp;int&nbsp;<var>d</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">unsigned long int <b>mpz_tdiv_r_ui</b><i> (mpz_t <var>r</var>, mpz_t <var>n</var>, unsigned&nbsp;long&nbsp;int&nbsp;<var>d</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">unsigned long int <b>mpz_tdiv_qr_ui</b><i> (mpz_t <var>q</var>, mpz_t <var>r</var>, mpz_t&nbsp;<var>n</var>, unsigned&nbsp;long&nbsp;int&nbsp;<var>d</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">unsigned long int <b>mpz_tdiv_ui</b><i> (mpz_t <var>n</var>, unsigned&nbsp;long&nbsp;int&nbsp;<var>d</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<tr>
<td align="left">void <b>mpz_tdiv_q_2exp</b><i> (mpz_t <var>q</var>, mpz_t <var>n</var>, unsigned&nbsp;long&nbsp;int&nbsp;<var>b</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpz_tdiv_r_2exp</b><i> (mpz_t <var>r</var>, mpz_t <var>n</var>, unsigned&nbsp;long&nbsp;int&nbsp;<var>b</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<br><p>
<p>Divide <var>n</var> by <var>d</var>, forming a quotient <var>q</var> and/or remainder
<var>r</var>.  For the <code>2exp</code> functions, <var>d</var>=2^<var>b</var>. 
The rounding is in three styles, each suiting different applications.

<ul>
<li><code>cdiv</code> rounds <var>q</var> up towards +infinity, and <var>r</var> will
have the opposite sign to <var>d</var>.  The <code>c</code> stands for "ceil".

<li><code>fdiv</code> rounds <var>q</var> down towards -infinity, and
<var>r</var> will have the same sign as <var>d</var>.  The <code>f</code> stands for
"floor".

<li><code>tdiv</code> rounds <var>q</var> towards zero, and <var>r</var> will have the same sign
as <var>n</var>.  The <code>t</code> stands for "truncate". 
</ul>

<p>In all cases <var>q</var> and <var>r</var> will satisfy
<var>n</var>=<var>q</var>*<var>d</var>+<var>r</var>, and
<var>r</var> will satisfy 0&lt;=abs(<var>r</var>)&lt;abs(<var>d</var>).

<p>The <code>q</code> functions calculate only the quotient, the <code>r</code> functions
only the remainder, and the <code>qr</code> functions calculate both.  Note that for
<code>qr</code> the same variable cannot be passed for both <var>q</var> and <var>r</var>, or
results will be unpredictable.

<p>For the <code>ui</code> variants the return value is the remainder, and in fact
returning the remainder is all the <code>div_ui</code> functions do.  For
<code>tdiv</code> and <code>cdiv</code> the remainder can be negative, so for those the
return value is the absolute value of the remainder.

<p>The <code>2exp</code> functions are right shifts and bit masks, but of course
rounding the same as the other functions.  For positive <var>n</var> both
<code>mpz_fdiv_q_2exp</code> and <code>mpz_tdiv_q_2exp</code> are simple bitwise right
shifts.  For negative <var>n</var>, <code>mpz_fdiv_q_2exp</code> is effectively an
arithmetic right shift treating <var>n</var> as twos complement the same as the
bitwise logical functions do, whereas <code>mpz_tdiv_q_2exp</code> effectively
treats <var>n</var> as sign and magnitude. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpz_mod</b><i> (mpz_t <var>r</var>, mpz_t <var>n</var>, mpz_t <var>d</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">unsigned long int <b>mpz_mod_ui</b><i> (mpz_t <var>r</var>, mpz_t <var>n</var>, unsigned&nbsp;long&nbsp;int&nbsp;<var>d</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>r</var> to <var>n</var> <code>mod</code> <var>d</var>.  The sign of the divisor is
ignored; the result is always non-negative.

<p><code>mpz_mod_ui</code> is identical to <code>mpz_fdiv_r_ui</code> above, returning the
remainder as well as setting <var>r</var>.  See <code>mpz_fdiv_ui</code> above if only
the return value is wanted. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpz_divexact</b><i> (mpz_t <var>q</var>, mpz_t <var>n</var>, mpz_t <var>d</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpz_divexact_ui</b><i> (mpz_t <var>q</var>, mpz_t <var>n</var>, unsigned long <var>d</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>q</var> to <var>n</var>/<var>d</var>.  These functions produce correct results only
when it is known in advance that <var>d</var> divides <var>n</var>.

<p>These routines are much faster than the other division functions, and are the
best choice when exact division is known to occur, for example reducing a
rational to lowest terms. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>mpz_divisible_p</b><i> (mpz_t <var>n</var>, mpz_t <var>d</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">int <b>mpz_divisible_ui_p</b><i> (mpz_t <var>n</var>, unsigned long int <var>d</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">int <b>mpz_divisible_2exp_p</b><i> (mpz_t <var>n</var>, unsigned long int <var>b</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Return non-zero if <var>n</var> is exactly divisible by <var>d</var>, or in the case of
<code>mpz_divisible_2exp_p</code> by 2^<var>b</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>mpz_congruent_p</b><i> (mpz_t <var>n</var>, mpz_t <var>c</var>, mpz_t <var>d</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">int <b>mpz_congruent_ui_p</b><i> (mpz_t <var>n</var>, unsigned long int <var>c</var>, unsigned long int <var>d</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">int <b>mpz_congruent_2exp_p</b><i> (mpz_t <var>n</var>, mpz_t <var>c</var>, unsigned long int <var>b</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Return non-zero if <var>n</var> is congruent to <var>c</var> modulo <var>d</var>, or in the
case of <code>mpz_congruent_2exp_p</code> modulo 2^<var>b</var>. 
</td></tr>
</table>

<p><hr>
Node:<a name="Integer%20Exponentiation">Integer Exponentiation</a>,
Next:<a rel=next accesskey=n href="#Integer%20Roots">Integer Roots</a>,
Previous:<a rel=previous accesskey=p href="#Integer%20Division">Integer Division</a>,
Up:<a rel=up accesskey=u href="#Integer%20Functions">Integer Functions</a>
<br>

<h3>Exponentiation Functions</h3>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpz_powm</b><i> (mpz_t <var>rop</var>, mpz_t <var>base</var>, mpz_t <var>exp</var>, mpz_t <var>mod</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpz_powm_ui</b><i> (mpz_t <var>rop</var>, mpz_t <var>base</var>, unsigned long int <var>exp</var>, mpz_t <var>mod</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>rop</var> to (<var>base</var> raised to <var>exp</var>)
modulo <var>mod</var>.

<p>Negative <var>exp</var> is supported if an inverse <var>base</var>^-1 mod
<var>mod</var> exists (see <code>mpz_invert</code> in <a href="#Number%20Theoretic%20Functions">Number Theoretic Functions</a>). 
If an inverse doesn't exist then a divide by zero is raised. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpz_pow_ui</b><i> (mpz_t <var>rop</var>, mpz_t <var>base</var>, unsigned long int <var>exp</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpz_ui_pow_ui</b><i> (mpz_t <var>rop</var>, unsigned long int <var>base</var>, unsigned long int <var>exp</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>rop</var> to <var>base</var> raised to <var>exp</var>.  The case
0^0 yields 1. 
</td></tr>
</table>

<p><hr>
Node:<a name="Integer%20Roots">Integer Roots</a>,
Next:<a rel=next accesskey=n href="#Number%20Theoretic%20Functions">Number Theoretic Functions</a>,
Previous:<a rel=previous accesskey=p href="#Integer%20Exponentiation">Integer Exponentiation</a>,
Up:<a rel=up accesskey=u href="#Integer%20Functions">Integer Functions</a>
<br>

<h3>Root Extraction Functions</h3>

<p>
<table width="100%">
<tr>
<td align="left">int <b>mpz_root</b><i> (mpz_t <var>rop</var>, mpz_t <var>op</var>, unsigned long int <var>n</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>rop</var> to  the truncated integer
part of the <var>n</var>th root of <var>op</var>.  Return non-zero if the computation
was exact, i.e., if <var>op</var> is <var>rop</var> to the <var>n</var>th power. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpz_sqrt</b><i> (mpz_t <var>rop</var>, mpz_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>rop</var> to  the truncated
integer part of the square root of <var>op</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpz_sqrtrem</b><i> (mpz_t <var>rop1</var>, mpz_t <var>rop2</var>, mpz_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>rop1</var> to the truncated integer part
of the square root of <var>op</var>, like <code>mpz_sqrt</code>.  Set <var>rop2</var> to the
remainder <var>op</var>-<var>rop1</var>*<var>rop1</var>, which will be zero if <var>op</var> is a
perfect square.

<p>If <var>rop1</var> and <var>rop2</var> are the same variable, the results are
undefined. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>mpz_perfect_power_p</b><i> (mpz_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Return non-zero if <var>op</var> is a perfect power, i.e., if there exist integers
<var>a</var> and <var>b</var>, with <var>b</var>&gt;1, such that
<var>op</var> equals <var>a</var> raised to the power <var>b</var>.

<p>Under this definition both 0 and 1 are considered to be perfect powers. 
Negative values of <var>op</var> are accepted, but of course can only be odd
perfect powers. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>mpz_perfect_square_p</b><i> (mpz_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Return non-zero if <var>op</var> is a perfect square, i.e., if the square root of
<var>op</var> is an integer.  Under this definition both 0 and 1 are considered to
be perfect squares. 
</td></tr>
</table>

<p><hr>
Node:<a name="Number%20Theoretic%20Functions">Number Theoretic Functions</a>,
Next:<a rel=next accesskey=n href="#Integer%20Comparisons">Integer Comparisons</a>,
Previous:<a rel=previous accesskey=p href="#Integer%20Roots">Integer Roots</a>,
Up:<a rel=up accesskey=u href="#Integer%20Functions">Integer Functions</a>
<br>

<h3>Number Theoretic Functions</h3>

<p>
<table width="100%">
<tr>
<td align="left">int <b>mpz_probab_prime_p</b><i> (mpz_t <var>n</var>, int <var>reps</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Determine whether <var>n</var> is prime.  Return 2 if <var>n</var> is definitely prime,
return 1 if <var>n</var> is probably prime (without being certain), or return 0 if
<var>n</var> is definitely composite.

<p>This function does some trial divisions, then some Miller-Rabin probabilistic
primality tests.  <var>reps</var> controls how many such tests are done, 5 to 10 is
a reasonable number, more will reduce the chances of a composite being
returned as "probably prime".

<p>Miller-Rabin and similar tests can be more properly called compositeness
tests.  Numbers which fail are known to be composite but those which pass
might be prime or might be composite.  Only a few composites pass, hence those
which pass are considered probably prime. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpz_nextprime</b><i> (mpz_t <var>rop</var>, mpz_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>rop</var> to the next prime greater than <var>op</var>.

<p>This function uses a probabilistic algorithm to identify primes.  For
practical purposes it's adequate, the chance of a composite passing will be
extremely small. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpz_gcd</b><i> (mpz_t <var>rop</var>, mpz_t <var>op1</var>, mpz_t <var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>rop</var> to the greatest common divisor of <var>op1</var> and <var>op2</var>. 
The result is always positive even if one or both input operands
are negative. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">unsigned long int <b>mpz_gcd_ui</b><i> (mpz_t <var>rop</var>, mpz_t <var>op1</var>, unsigned long int <var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Compute the greatest common divisor of <var>op1</var> and <var>op2</var>.  If
<var>rop</var> is not <code>NULL</code>, store the result there.

<p>If the result is small enough to fit in an <code>unsigned long int</code>, it is
returned.  If the result does not fit, 0 is returned, and the result is equal
to the argument <var>op1</var>.  Note that the result will always fit if <var>op2</var>
is non-zero. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpz_gcdext</b><i> (mpz_t <var>g</var>, mpz_t <var>s</var>, mpz_t <var>t</var>, mpz_t <var>a</var>, mpz_t <var>b</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>g</var> to the greatest common divisor of <var>a</var> and <var>b</var>, and in
addition set <var>s</var> and <var>t</var> to coefficients satisfying
<var>a</var>*<var>s</var> + <var>b</var>*<var>t</var> = <var>g</var>. 
<var>g</var> is always positive, even if one or both of <var>a</var> and <var>b</var> are
negative.

<p>If <var>t</var> is <code>NULL</code> then that value is not computed. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpz_lcm</b><i> (mpz_t <var>rop</var>, mpz_t <var>op1</var>, mpz_t <var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpz_lcm_ui</b><i> (mpz_t <var>rop</var>, mpz_t <var>op1</var>, unsigned long <var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>rop</var> to the least common multiple of <var>op1</var> and <var>op2</var>. 
<var>rop</var> is always positive, irrespective of the signs of <var>op1</var> and
<var>op2</var>.  <var>rop</var> will be zero if either <var>op1</var> or <var>op2</var> is zero. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>mpz_invert</b><i> (mpz_t <var>rop</var>, mpz_t <var>op1</var>, mpz_t <var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Compute the inverse of <var>op1</var> modulo <var>op2</var> and put the result in
<var>rop</var>.  If the inverse exists, the return value is non-zero and <var>rop</var>
will satisfy 0 &lt;= <var>rop</var> &lt; <var>op2</var>.  If an inverse doesn't exist
the return value is zero and <var>rop</var> is undefined. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>mpz_jacobi</b><i> (mpz_t <var>a</var>, mpz_t <var>b</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Calculate the Jacobi symbol (<var>a</var>/<var>b</var>).  This is defined only for <var>b</var> odd. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>mpz_legendre</b><i> (mpz_t <var>a</var>, mpz_t <var>p</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Calculate the Legendre symbol (<var>a</var>/<var>p</var>).  This is defined only for <var>p</var> an odd positive
prime, and for such <var>p</var> it's identical to the Jacobi symbol. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>mpz_kronecker</b><i> (mpz_t <var>a</var>, mpz_t <var>b</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">int <b>mpz_kronecker_si</b><i> (mpz_t <var>a</var>, long <var>b</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">int <b>mpz_kronecker_ui</b><i> (mpz_t <var>a</var>, unsigned long <var>b</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">int <b>mpz_si_kronecker</b><i> (long <var>a</var>, mpz_t <var>b</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">int <b>mpz_ui_kronecker</b><i> (unsigned long <var>a</var>, mpz_t <var>b</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Calculate the Jacobi symbol (<var>a</var>/<var>b</var>) with the Kronecker extension (a/2)=(2/a) when a odd, or
(a/2)=0 when a even.

<p>When <var>b</var> is odd the Jacobi symbol and Kronecker symbol are
identical, so <code>mpz_kronecker_ui</code> etc can be used for mixed
precision Jacobi symbols too.

<p>For more information see Henri Cohen section 1.4.2 (see <a href="#References">References</a>),
or any number theory textbook.  See also the example program
<code>demos/qcn.c</code> which uses <code>mpz_kronecker_ui</code>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">unsigned long int <b>mpz_remove</b><i> (mpz_t <var>rop</var>, mpz_t <var>op</var>, mpz_t <var>f</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Remove all occurrences of the factor <var>f</var> from <var>op</var> and store the
result in <var>rop</var>.  Return the multiplicity of <var>f</var> in <var>op</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpz_fac_ui</b><i> (mpz_t <var>rop</var>, unsigned long int <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>rop</var> to <var>op</var>!, the factorial of <var>op</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpz_bin_ui</b><i> (mpz_t <var>rop</var>, mpz_t <var>n</var>, unsigned long int <var>k</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpz_bin_uiui</b><i> (mpz_t <var>rop</var>, unsigned long int <var>n</var>, unsigned&nbsp;long&nbsp;int&nbsp;<var>k</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Compute the binomial coefficient <var>n</var> over
<var>k</var> and store the result in <var>rop</var>.  Negative values of <var>n</var> are
supported by <code>mpz_bin_ui</code>, using the identity
bin(-n,k) = (-1)^k * bin(n+k-1,k), see Knuth volume 1 section 1.2.6
part G. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpz_fib_ui</b><i> (mpz_t <var>fn</var>, unsigned long int <var>n</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpz_fib2_ui</b><i> (mpz_t <var>fn</var>, mpz_t <var>fnsub1</var>, unsigned long int <var>n</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
<code>mpz_fib_ui</code> sets <var>fn</var> to to F[n], the <var>n</var>'th Fibonacci
number.  <code>mpz_fib2_ui</code> sets <var>fn</var> to F[n], and <var>fnsub1</var> to
F[n-1].

<p>These functions are designed for calculating isolated Fibonacci numbers.  When
a sequence of values is wanted it's best to start with <code>mpz_fib2_ui</code> and
iterate the defining F[n+1]=F[n]+F[n-1] or
similar. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpz_lucnum_ui</b><i> (mpz_t <var>ln</var>, unsigned long int <var>n</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpz_lucnum2_ui</b><i> (mpz_t <var>ln</var>, mpz_t <var>lnsub1</var>, unsigned long int <var>n</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
<code>mpz_lucnum_ui</code> sets <var>ln</var> to to L[n], the <var>n</var>'th Lucas
number.  <code>mpz_lucnum2_ui</code> sets <var>ln</var> to L[n], and <var>lnsub1</var>
to L[n-1].

<p>These functions are designed for calculating isolated Lucas numbers.  When a
sequence of values is wanted it's best to start with <code>mpz_lucnum2_ui</code> and
iterate the defining L[n+1]=L[n]+L[n-1] or
similar.

<p>The Fibonacci numbers and Lucas numbers are related sequences, so it's never
necessary to call both <code>mpz_fib2_ui</code> and <code>mpz_lucnum2_ui</code>.  The
formulas for going from Fibonacci to Lucas can be found in <a href="#Lucas%20Numbers%20Algorithm">Lucas Numbers Algorithm</a>, the reverse is straightforward too. 
</td></tr>
</table>

<p><hr>
Node:<a name="Integer%20Comparisons">Integer Comparisons</a>,
Next:<a rel=next accesskey=n href="#Integer%20Logic%20and%20Bit%20Fiddling">Integer Logic and Bit Fiddling</a>,
Previous:<a rel=previous accesskey=p href="#Number%20Theoretic%20Functions">Number Theoretic Functions</a>,
Up:<a rel=up accesskey=u href="#Integer%20Functions">Integer Functions</a>
<br>

<h3>Comparison Functions</h3>

<p>
<table width="100%">
<tr>
<td align="left">int <b>mpz_cmp</b><i> (mpz_t <var>op1</var>, mpz_t <var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">int <b>mpz_cmp_d</b><i> (mpz_t <var>op1</var>, double <var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">int <b>mpz_cmp_si</b><i> (mpz_t <var>op1</var>, signed long int <var>op2</var>)
</i></td>
<td align="right">Macro</td>
</tr>

<tr>
<td align="left">int <b>mpz_cmp_ui</b><i> (mpz_t <var>op1</var>, unsigned long int <var>op2</var>)
</i></td>
<td align="right">Macro</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Compare <var>op1</var> and <var>op2</var>.  Return a positive value if <var>op1</var> &gt;
<var>op2</var>, zero if <var>op1</var> = <var>op2</var>, or a negative value if
<var>op1</var> &lt; <var>op2</var>.

<p>Note that <code>mpz_cmp_ui</code> and <code>mpz_cmp_si</code> are macros and will evaluate
their arguments more than once. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>mpz_cmpabs</b><i> (mpz_t <var>op1</var>, mpz_t <var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">int <b>mpz_cmpabs_d</b><i> (mpz_t <var>op1</var>, double <var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">int <b>mpz_cmpabs_ui</b><i> (mpz_t <var>op1</var>, unsigned long int <var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Compare the absolute values of <var>op1</var> and <var>op2</var>.  Return a positive
value if abs(<var>op1</var>) &gt; abs(<var>op2</var>), zero if
abs(<var>op1</var>) = abs(<var>op2</var>), or a negative value if
abs(<var>op1</var>) &lt; abs(<var>op2</var>).

<p>Note that <code>mpz_cmpabs_si</code> is a macro and will evaluate its arguments more
than once. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>mpz_sgn</b><i> (mpz_t <var>op</var>)
</i></td>
<td align="right">Macro</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Return +1 if <var>op</var> &gt; 0, 0 if <var>op</var> = 0, and
-1 if <var>op</var> &lt; 0.

<p>This function is actually implemented as a macro.  It evaluates its argument
multiple times. 
</td></tr>
</table>

<p><hr>
Node:<a name="Integer%20Logic%20and%20Bit%20Fiddling">Integer Logic and Bit Fiddling</a>,
Next:<a rel=next accesskey=n href="#I%2fO%20of%20Integers">I/O of Integers</a>,
Previous:<a rel=previous accesskey=p href="#Integer%20Comparisons">Integer Comparisons</a>,
Up:<a rel=up accesskey=u href="#Integer%20Functions">Integer Functions</a>
<br>

<h3>Logical and Bit Manipulation Functions</h3>

<p>These functions behave as if twos complement arithmetic were used (although
sign-magnitude is the actual implementation).  The least significant bit is
number 0.

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpz_and</b><i> (mpz_t <var>rop</var>, mpz_t <var>op1</var>, mpz_t <var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>rop</var> to <var>op1</var> logical-and <var>op2</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpz_ior</b><i> (mpz_t <var>rop</var>, mpz_t <var>op1</var>, mpz_t <var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>rop</var> to <var>op1</var> inclusive-or <var>op2</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpz_xor</b><i> (mpz_t <var>rop</var>, mpz_t <var>op1</var>, mpz_t <var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>rop</var> to <var>op1</var> exclusive-or <var>op2</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpz_com</b><i> (mpz_t <var>rop</var>, mpz_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>rop</var> to the one's complement of <var>op</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">unsigned long int <b>mpz_popcount</b><i> (mpz_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
If <var>op</var>&gt;=0, return the population count of <var>op</var>, which is
the number of 1 bits in the binary representation.  If <var>op</var>&lt;0, the
number of 1s is infinite, and the return value is <var>MAX_ULONG</var>, the largest
possible <code>unsigned long</code>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">unsigned long int <b>mpz_hamdist</b><i> (mpz_t <var>op1</var>, mpz_t <var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
If <var>op1</var> and <var>op2</var> are both &gt;=0 or both &lt;0, return
the hamming distance between the two operands, which is the number of bit
positions where <var>op1</var> and <var>op2</var> have different bit values.  If one
operand is &gt;=0 and the other &lt;0 then the number of bits
different is infinite, and the return value is <var>MAX_ULONG</var>, the largest
possible <code>unsigned long</code>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">unsigned long int <b>mpz_scan0</b><i> (mpz_t <var>op</var>, unsigned long int <var>starting_bit</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">unsigned long int <b>mpz_scan1</b><i> (mpz_t <var>op</var>, unsigned long int <var>starting_bit</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Scan <var>op</var>, starting from bit <var>starting_bit</var>, towards more significant
bits, until the first 0 or 1 bit (respectively) is found.  Return the index of
the found bit.

<p>If the bit at <var>starting_bit</var> is already what's sought, then
<var>starting_bit</var> is returned.

<p>If there's no bit found, then <var>MAX_ULONG</var> is returned.  This will happen
in <code>mpz_scan0</code> past the end of a positive number, or <code>mpz_scan1</code>
past the end of a negative. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpz_setbit</b><i> (mpz_t <var>rop</var>, unsigned long int <var>bit_index</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set bit <var>bit_index</var> in <var>rop</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpz_clrbit</b><i> (mpz_t <var>rop</var>, unsigned long int <var>bit_index</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Clear bit <var>bit_index</var> in <var>rop</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>mpz_tstbit</b><i> (mpz_t <var>op</var>, unsigned long int <var>bit_index</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Test bit <var>bit_index</var> in <var>op</var> and return 0 or 1 accordingly. 
</td></tr>
</table>

<p><hr>
Node:<a name="I%2fO%20of%20Integers">I/O of Integers</a>,
Next:<a rel=next accesskey=n href="#Integer%20Random%20Numbers">Integer Random Numbers</a>,
Previous:<a rel=previous accesskey=p href="#Integer%20Logic%20and%20Bit%20Fiddling">Integer Logic and Bit Fiddling</a>,
Up:<a rel=up accesskey=u href="#Integer%20Functions">Integer Functions</a>
<br>

<h3>Input and Output Functions</h3>

<p>Functions that perform input from a stdio stream, and functions that output to
a stdio stream.  Passing a <code>NULL</code> pointer for a <var>stream</var> argument to any of
these functions will make them read from <code>stdin</code> and write to
<code>stdout</code>, respectively.

<p>When using any of these functions, it is a good idea to include <code>stdio.h</code>
before <code>gmp.h</code>, since that will allow <code>gmp.h</code> to define prototypes
for these functions.

<p>
<table width="100%">
<tr>
<td align="left">size_t <b>mpz_out_str</b><i> (FILE *<var>stream</var>, int <var>base</var>, mpz_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Output <var>op</var> on stdio stream <var>stream</var>, as a string of digits in base
<var>base</var>.  The base may vary from 2 to 36.

<p>Return the number of bytes written, or if an error occurred, return 0. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">size_t <b>mpz_inp_str</b><i> (mpz_t <var>rop</var>, FILE *<var>stream</var>, int <var>base</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Input a possibly white-space preceded string in base <var>base</var> from stdio
stream <var>stream</var>, and put the read integer in <var>rop</var>.  The base may vary
from 2 to 36.  If <var>base</var> is 0, the actual base is determined from the
leading characters: if the first two characters are `0x' or `0X', hexadecimal
is assumed, otherwise if the first character is `0', octal is assumed,
otherwise decimal is assumed.

<p>Return the number of bytes read, or if an error occurred, return 0. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">size_t <b>mpz_out_raw</b><i> (FILE *<var>stream</var>, mpz_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Output <var>op</var> on stdio stream <var>stream</var>, in raw binary format.  The
integer is written in a portable format, with 4 bytes of size information, and
that many bytes of limbs.  Both the size and the limbs are written in
decreasing significance order (i.e., in big-endian).

<p>The output can be read with <code>mpz_inp_raw</code>.

<p>Return the number of bytes written, or if an error occurred, return 0.

<p>The output of this can not be read by <code>mpz_inp_raw</code> from GMP 1, because
of changes necessary for compatibility between 32-bit and 64-bit machines. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">size_t <b>mpz_inp_raw</b><i> (mpz_t <var>rop</var>, FILE *<var>stream</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Input from stdio stream <var>stream</var> in the format written by
<code>mpz_out_raw</code>, and put the result in <var>rop</var>.  Return the number of
bytes read, or if an error occurred, return 0.

<p>This routine can read the output from <code>mpz_out_raw</code> also from GMP 1, in
spite of changes necessary for compatibility between 32-bit and 64-bit
machines. 
</td></tr>
</table>

<p><hr>
Node:<a name="Integer%20Random%20Numbers">Integer Random Numbers</a>,
Next:<a rel=next accesskey=n href="#Integer%20Import%20and%20Export">Integer Import and Export</a>,
Previous:<a rel=previous accesskey=p href="#I%2fO%20of%20Integers">I/O of Integers</a>,
Up:<a rel=up accesskey=u href="#Integer%20Functions">Integer Functions</a>
<br>

<h3>Random Number Functions</h3>

<p>The random number functions of GMP come in two groups; older function
that rely on a global state, and newer functions that accept a state
parameter that is read and modified.  Please see the <a href="#Random%20Number%20Functions">Random Number Functions</a> for more information on how to use and not to use random
number functions.

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpz_urandomb</b><i> (mpz_t <var>rop</var>, gmp_randstate_t <var>state</var>, unsigned long int <var>n</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Generate a uniformly distributed random integer in the range 0 to 2^<var>n</var>-1, inclusive.

<p>The variable <var>state</var> must be initialized by calling one of the
<code>gmp_randinit</code> functions (<a href="#Random%20State%20Initialization">Random State Initialization</a>) before
invoking this function. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpz_urandomm</b><i> (mpz_t <var>rop</var>, gmp_randstate_t <var>state</var>, mpz_t <var>n</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Generate a uniform random integer in the range 0 to <var>n</var>-1,
inclusive.

<p>The variable <var>state</var> must be initialized by calling one of the
<code>gmp_randinit</code> functions (<a href="#Random%20State%20Initialization">Random State Initialization</a>)
before invoking this function. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpz_rrandomb</b><i> (mpz_t <var>rop</var>, gmp_randstate_t <var>state</var>, unsigned long int <var>n</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Generate a random integer with long strings of zeros and ones in the
binary representation.  Useful for testing functions and algorithms,
since this kind of random numbers have proven to be more likely to
trigger corner-case bugs.  The random number will be in the range
0 to 2^<var>n</var>-1, inclusive.

<p>The variable <var>state</var> must be initialized by calling one of the
<code>gmp_randinit</code> functions (<a href="#Random%20State%20Initialization">Random State Initialization</a>)
before invoking this function. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpz_random</b><i> (mpz_t <var>rop</var>, mp_size_t <var>max_size</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Generate a random integer of at most <var>max_size</var> limbs.  The generated
random number doesn't satisfy any particular requirements of randomness. 
Negative random numbers are generated when <var>max_size</var> is negative.

<p>This function is obsolete.  Use <code>mpz_urandomb</code> or
<code>mpz_urandomm</code> instead. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpz_random2</b><i> (mpz_t <var>rop</var>, mp_size_t <var>max_size</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Generate a random integer of at most <var>max_size</var> limbs, with long strings
of zeros and ones in the binary representation.  Useful for testing functions
and algorithms, since this kind of random numbers have proven to be more
likely to trigger corner-case bugs.  Negative random numbers are generated
when <var>max_size</var> is negative.

<p>This function is obsolete.  Use <code>mpz_rrandomb</code> instead. 
</td></tr>
</table>

<p><hr>
Node:<a name="Integer%20Import%20and%20Export">Integer Import and Export</a>,
Next:<a rel=next accesskey=n href="#Miscellaneous%20Integer%20Functions">Miscellaneous Integer Functions</a>,
Previous:<a rel=previous accesskey=p href="#Integer%20Random%20Numbers">Integer Random Numbers</a>,
Up:<a rel=up accesskey=u href="#Integer%20Functions">Integer Functions</a>
<br>

<h3>Integer Import and Export</h3>

<p><code>mpz_t</code> variables can be converted to and from arbitrary words of binary
data with the following functions.

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpz_import</b><i> (mpz_t <var>rop</var>, size_t <var>count</var>, int <var>order</var>, int <var>size</var>, int <var>endian</var>, size_t <var>nails</var>, const void *<var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>rop</var> from an array of word data at <var>op</var>.

<p>The parameters specify the format of the data.  <var>count</var> many words are
read, each <var>size</var> bytes.  <var>order</var> can be 1 for most significant word
first or -1 for least significant first.  Within each word <var>endian</var> can be
1 for most significant byte first, -1 for least significant first, or 0 for
the native endianness of the host CPU.  The most significant <var>nails</var> bits
of each word are skipped, this can be 0 to use the full words.

<p>There are no data alignment restrictions on <var>op</var>, any address is allowed.

<p>Here's an example converting an array of <code>unsigned long</code> data, most
significant element first and host byte order within each value.

<br><pre>unsigned long  a[20];
mpz_t          z;
mpz_import (z, 20, 1, sizeof(a[0]), 0, 0, a);
</pre>

<p>This example assumes the full <code>sizeof</code> bytes are used for data in the
given type, which is usually true, and certainly true for <code>unsigned long</code>
everywhere we know of.  However on Cray vector systems it may be noted that
<code>short</code> and <code>int</code> are always stored in 8 bytes (and with
<code>sizeof</code> indicating that) but use only 32 or 46 bits.  The <var>nails</var>
feature can account for this, by passing for instance
<code>8*sizeof(int)-INT_BIT</code>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>*mpz_export</b><i> (void *<var>rop</var>, size_t *<var>count</var>, int <var>order</var>, int <var>size</var>, int <var>endian</var>, size_t <var>nails</var>, mpz_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Fill <var>rop</var> with word data from <var>op</var>.

<p>The parameters specify the format of the data produced.  Each word will be
<var>size</var> bytes and <var>order</var> can be 1 for most significant word first or
-1 for least significant first.  Within each word <var>endian</var> can be 1 for
most significant byte first, -1 for least significant first, or 0 for the
native endianness of the host CPU.  The most significant <var>nails</var> bits of
each word are unused and set to zero, this can be 0 to produce full words.

<p>The number of words produced is written to <code>*<var>count</var></code>.  <var>rop</var>
must have enough space for the data, or if <var>rop</var> is <code>NULL</code> then a
result array of the necessary size is allocated using the current GMP
allocation function (see <a href="#Custom%20Allocation">Custom Allocation</a>).  In either case the return
value is the destination used, <var>rop</var> or the allocated block.

<p>If <var>op</var> is non-zero then the most significant word produced will be
non-zero.  If <var>op</var> is zero then the count returned will be zero and
nothing written to <var>rop</var>.  If <var>rop</var> is <code>NULL</code> in this case, no
block is allocated, just <code>NULL</code> is returned.

<p>There are no data alignment restrictions on <var>rop</var>, any address is allowed. 
The sign of <var>op</var> is ignored, just the absolute value is used.

<p>When an application is allocating space itself the required size can be
determined with a calculation like the following.  Since <code>mpz_sizeinbase</code>
always returns at least 1, <code>count</code> here will be at least one, which
avoids any portability problems with <code>malloc(0)</code>, though if <code>z</code> is
zero no space at all is actually needed.

<br><pre>numb = 8*size - nail;
count = (mpz_sizeinbase (z, 2) + numb-1) / numb;
p = malloc (count * size);
</pre>
</td></tr>
</table>

<p><hr>
Node:<a name="Miscellaneous%20Integer%20Functions">Miscellaneous Integer Functions</a>,
Previous:<a rel=previous accesskey=p href="#Integer%20Import%20and%20Export">Integer Import and Export</a>,
Up:<a rel=up accesskey=u href="#Integer%20Functions">Integer Functions</a>
<br>

<h3>Miscellaneous Functions</h3>

<p>
<table width="100%">
<tr>
<td align="left">int <b>mpz_fits_ulong_p</b><i> (mpz_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">int <b>mpz_fits_slong_p</b><i> (mpz_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">int <b>mpz_fits_uint_p</b><i> (mpz_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">int <b>mpz_fits_sint_p</b><i> (mpz_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">int <b>mpz_fits_ushort_p</b><i> (mpz_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">int <b>mpz_fits_sshort_p</b><i> (mpz_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Return non-zero iff the value of <var>op</var> fits in an <code>unsigned long int</code>,
<code>signed long int</code>, <code>unsigned int</code>, <code>signed int</code>, <code>unsigned
short int</code>, or <code>signed short int</code>, respectively.  Otherwise, return zero. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>mpz_odd_p</b><i> (mpz_t <var>op</var>)
</i></td>
<td align="right">Macro</td>
</tr>

<tr>
<td align="left">int <b>mpz_even_p</b><i> (mpz_t <var>op</var>)
</i></td>
<td align="right">Macro</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Determine whether <var>op</var> is odd or even, respectively.  Return non-zero if
yes, zero if no.  These macros evaluate their argument more than once. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">size_t <b>mpz_size</b><i> (mpz_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Return the size of <var>op</var> measured in number of limbs.  If <var>op</var> is zero,
the returned value will be zero. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">size_t <b>mpz_sizeinbase</b><i> (mpz_t <var>op</var>, int <var>base</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Return the size of <var>op</var> measured in number of digits in base <var>base</var>. 
The base may vary from 2 to 36.  The sign of <var>op</var> is ignored, just the
absolute value is used.  The result will be exact or 1 too big.  If <var>base</var>
is a power of 2, the result will always be exact.  If <var>op</var> is zero the
return value is always 1.

<p>This function is useful in order to allocate the right amount of space before
converting <var>op</var> to a string.  The right amount of allocation is normally
two more than the value returned by <code>mpz_sizeinbase</code> (one extra for a
minus sign and one for the null-terminator). 
</td></tr>
</table>

<p><hr>
Node:<a name="Rational%20Number%20Functions">Rational Number Functions</a>,
Next:<a rel=next accesskey=n href="#Floating-point%20Functions">Floating-point Functions</a>,
Previous:<a rel=previous accesskey=p href="#Integer%20Functions">Integer Functions</a>,
Up:<a rel=up accesskey=u href="#Top">Top</a>
<br>

<h2>Rational Number Functions</h2>

<p>This chapter describes the GMP functions for performing arithmetic on rational
numbers.  These functions start with the prefix <code>mpq_</code>.

<p>Rational numbers are stored in objects of type <code>mpq_t</code>.

<p>All rational arithmetic functions assume operands have a canonical form, and
canonicalize their result.  The canonical from means that the denominator and
the numerator have no common factors, and that the denominator is positive. 
Zero has the unique representation 0/1.

<p>Pure assignment functions do not canonicalize the assigned variable.  It is
the responsibility of the user to canonicalize the assigned variable before
any arithmetic operations are performed on that variable.

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpq_canonicalize</b><i> (mpq_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Remove any factors that are common to the numerator and denominator of
<var>op</var>, and make the denominator positive. 
</td></tr>
</table>

<ul>
<li><a accesskey=1 href="#Initializing%20Rationals">Initializing Rationals</a>: 
<li><a accesskey=2 href="#Rational%20Conversions">Rational Conversions</a>: 
<li><a accesskey=3 href="#Rational%20Arithmetic">Rational Arithmetic</a>: 
<li><a accesskey=4 href="#Comparing%20Rationals">Comparing Rationals</a>: 
<li><a accesskey=5 href="#Applying%20Integer%20Functions">Applying Integer Functions</a>: 
<li><a accesskey=6 href="#I%2fO%20of%20Rationals">I/O of Rationals</a>: 
</ul>

<p><hr>
Node:<a name="Initializing%20Rationals">Initializing Rationals</a>,
Next:<a rel=next accesskey=n href="#Rational%20Conversions">Rational Conversions</a>,
Previous:<a rel=previous accesskey=p href="#Rational%20Number%20Functions">Rational Number Functions</a>,
Up:<a rel=up accesskey=u href="#Rational%20Number%20Functions">Rational Number Functions</a>
<br>

<h3>Initialization and Assignment Functions</h3>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpq_init</b><i> (mpq_t <var>dest_rational</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Initialize <var>dest_rational</var> and set it to 0/1.  Each variable should
normally only be initialized once, or at least cleared out (using the function
<code>mpq_clear</code>) between each initialization. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpq_clear</b><i> (mpq_t <var>rational_number</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Free the space occupied by <var>rational_number</var>.  Make sure to call this
function for all <code>mpq_t</code> variables when you are done with them. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpq_set</b><i> (mpq_t <var>rop</var>, mpq_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpq_set_z</b><i> (mpq_t <var>rop</var>, mpz_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Assign <var>rop</var> from <var>op</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpq_set_ui</b><i> (mpq_t <var>rop</var>, unsigned long int <var>op1</var>, unsigned long int <var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpq_set_si</b><i> (mpq_t <var>rop</var>, signed long int <var>op1</var>, unsigned long int <var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set the value of <var>rop</var> to <var>op1</var>/<var>op2</var>.  Note that if <var>op1</var> and
<var>op2</var> have common factors, <var>rop</var> has to be passed to
<code>mpq_canonicalize</code> before any operations are performed on <var>rop</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>mpq_set_str</b><i> (mpq_t <var>rop</var>, char *<var>str</var>, int <var>base</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>rop</var> from a null-terminated string <var>str</var> in the given <var>base</var>.

<p>The string can be an integer like "41" or a fraction like "41/152".  The
fraction must be in canonical form (see <a href="#Rational%20Number%20Functions">Rational Number Functions</a>), or if
not then <code>mpq_canonicalize</code> must be called.

<p>The numerator and optional denominator are parsed the same as in
<code>mpz_set_str</code> (see <a href="#Assigning%20Integers">Assigning Integers</a>).  White space is allowed in
the string, and is simply ignored.  The <var>base</var> can vary from 2 to 36, or
if <var>base</var> is 0 then the leading characters are used: <code>0x</code> for hex,
<code>0</code> for octal, or decimal otherwise.  Note that this is done separately
for the numerator and denominator, so for instance <code>0xEF/100</code> is 239/100,
whereas <code>0xEF/0x100</code> is 239/256.

<p>The return value is 0 if the entire string is a valid number, or -1 if
not. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpq_swap</b><i> (mpq_t <var>rop1</var>, mpq_t <var>rop2</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Swap the values <var>rop1</var> and <var>rop2</var> efficiently. 
</td></tr>
</table>

<p><hr>
Node:<a name="Rational%20Conversions">Rational Conversions</a>,
Next:<a rel=next accesskey=n href="#Rational%20Arithmetic">Rational Arithmetic</a>,
Previous:<a rel=previous accesskey=p href="#Initializing%20Rationals">Initializing Rationals</a>,
Up:<a rel=up accesskey=u href="#Rational%20Number%20Functions">Rational Number Functions</a>
<br>

<h3>Conversion Functions</h3>

<p>
<table width="100%">
<tr>
<td align="left">double <b>mpq_get_d</b><i> (mpq_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Convert <var>op</var> to a <code>double</code>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpq_set_d</b><i> (mpq_t <var>rop</var>, double <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpq_set_f</b><i> (mpq_t <var>rop</var>, mpf_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>rop</var> to the value of <var>op</var>, without rounding. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">char * <b>mpq_get_str</b><i> (char *<var>str</var>, int <var>base</var>, mpq_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Convert <var>op</var> to a string of digits in base <var>base</var>.  The base may vary
from 2 to 36.  The string will be of the form <code>num/den</code>, or if the
denominator is 1 then just <code>num</code>.

<p>If <var>str</var> is <code>NULL</code>, the result string is allocated using the current
allocation function (see <a href="#Custom%20Allocation">Custom Allocation</a>).  The block will be
<code>strlen(str)+1</code> bytes, that being exactly enough for the string and
null-terminator.

<p>If <var>str</var> is not <code>NULL</code>, it should point to a block of storage large
enough for the result, that being

<br><pre>mpz_sizeinbase (mpq_numref(<var>op</var>), <var>base</var>)
+ mpz_sizeinbase (mpq_denref(<var>op</var>), <var>base</var>) + 3
</pre>

<p>The three extra bytes are for a possible minus sign, possible slash, and the
null-terminator.

<p>A pointer to the result string is returned, being either the allocated block,
or the given <var>str</var>. 
</td></tr>
</table>

<p><hr>
Node:<a name="Rational%20Arithmetic">Rational Arithmetic</a>,
Next:<a rel=next accesskey=n href="#Comparing%20Rationals">Comparing Rationals</a>,
Previous:<a rel=previous accesskey=p href="#Rational%20Conversions">Rational Conversions</a>,
Up:<a rel=up accesskey=u href="#Rational%20Number%20Functions">Rational Number Functions</a>
<br>

<h3>Arithmetic Functions</h3>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpq_add</b><i> (mpq_t <var>sum</var>, mpq_t <var>addend1</var>, mpq_t <var>addend2</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>sum</var> to <var>addend1</var> + <var>addend2</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpq_sub</b><i> (mpq_t <var>difference</var>, mpq_t <var>minuend</var>, mpq_t <var>subtrahend</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>difference</var> to <var>minuend</var> - <var>subtrahend</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpq_mul</b><i> (mpq_t <var>product</var>, mpq_t <var>multiplier</var>, mpq_t <var>multiplicand</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>product</var> to <var>multiplier</var> times <var>multiplicand</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpq_mul_2exp</b><i> (mpq_t <var>rop</var>, mpq_t <var>op1</var>, unsigned long int <var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>rop</var> to <var>op1</var> times 2 raised to
<var>op2</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpq_div</b><i> (mpq_t <var>quotient</var>, mpq_t <var>dividend</var>, mpq_t <var>divisor</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>quotient</var> to <var>dividend</var>/<var>divisor</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpq_div_2exp</b><i> (mpq_t <var>rop</var>, mpq_t <var>op1</var>, unsigned long int <var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>rop</var> to <var>op1</var> divided by 2 raised to
<var>op2</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpq_neg</b><i> (mpq_t <var>negated_operand</var>, mpq_t <var>operand</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>negated_operand</var> to -<var>operand</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpq_abs</b><i> (mpq_t <var>rop</var>, mpq_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>rop</var> to the absolute value of <var>op</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpq_inv</b><i> (mpq_t <var>inverted_number</var>, mpq_t <var>number</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>inverted_number</var> to 1/<var>number</var>.  If the new denominator is
zero, this routine will divide by zero. 
</td></tr>
</table>

<p><hr>
Node:<a name="Comparing%20Rationals">Comparing Rationals</a>,
Next:<a rel=next accesskey=n href="#Applying%20Integer%20Functions">Applying Integer Functions</a>,
Previous:<a rel=previous accesskey=p href="#Rational%20Arithmetic">Rational Arithmetic</a>,
Up:<a rel=up accesskey=u href="#Rational%20Number%20Functions">Rational Number Functions</a>
<br>

<h3>Comparison Functions</h3>

<p>
<table width="100%">
<tr>
<td align="left">int <b>mpq_cmp</b><i> (mpq_t <var>op1</var>, mpq_t <var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Compare <var>op1</var> and <var>op2</var>.  Return a positive value if <var>op1</var> &gt;
<var>op2</var>, zero if <var>op1</var> = <var>op2</var>, and a negative value if
<var>op1</var> &lt; <var>op2</var>.

<p>To determine if two rationals are equal, <code>mpq_equal</code> is faster than
<code>mpq_cmp</code>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>mpq_cmp_ui</b><i> (mpq_t <var>op1</var>, unsigned long int <var>num2</var>, unsigned long int <var>den2</var>)
</i></td>
<td align="right">Macro</td>
</tr>

<tr>
<td align="left">int <b>mpq_cmp_si</b><i> (mpq_t <var>op1</var>, long int <var>num2</var>, unsigned long int <var>den2</var>)
</i></td>
<td align="right">Macro</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Compare <var>op1</var> and <var>num2</var>/<var>den2</var>.  Return a positive value if
<var>op1</var> &gt; <var>num2</var>/<var>den2</var>, zero if <var>op1</var> =
<var>num2</var>/<var>den2</var>, and a negative value if <var>op1</var> &lt;
<var>num2</var>/<var>den2</var>.

<p><var>num2</var> and <var>den2</var> are allowed to have common factors.

<p>These functions are implemented as a macros and evaluate their arguments
multiple times. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>mpq_sgn</b><i> (mpq_t <var>op</var>)
</i></td>
<td align="right">Macro</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Return +1 if <var>op</var> &gt; 0, 0 if <var>op</var> = 0, and
-1 if <var>op</var> &lt; 0.

<p>This function is actually implemented as a macro.  It evaluates its
arguments multiple times. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>mpq_equal</b><i> (mpq_t <var>op1</var>, mpq_t <var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Return non-zero if <var>op1</var> and <var>op2</var> are equal, zero if they are
non-equal.  Although <code>mpq_cmp</code> can be used for the same purpose, this
function is much faster. 
</td></tr>
</table>

<p><hr>
Node:<a name="Applying%20Integer%20Functions">Applying Integer Functions</a>,
Next:<a rel=next accesskey=n href="#I%2fO%20of%20Rationals">I/O of Rationals</a>,
Previous:<a rel=previous accesskey=p href="#Comparing%20Rationals">Comparing Rationals</a>,
Up:<a rel=up accesskey=u href="#Rational%20Number%20Functions">Rational Number Functions</a>
<br>

<h3>Applying Integer Functions to Rationals</h3>

<p>The set of <code>mpq</code> functions is quite small.  In particular, there are few
functions for either input or output.  The following functions give direct
access to the numerator and denominator of an <code>mpq_t</code>.

<p>Note that if an assignment to the numerator and/or denominator could take an
<code>mpq_t</code> out of the canonical form described at the start of this chapter
(see <a href="#Rational%20Number%20Functions">Rational Number Functions</a>) then <code>mpq_canonicalize</code> must be
called before any other <code>mpq</code> functions are applied to that <code>mpq_t</code>.

<p>
<table width="100%">
<tr>
<td align="left">mpz_t <b>mpq_numref</b><i> (mpq_t <var>op</var>)
</i></td>
<td align="right">Macro</td>
</tr>

<tr>
<td align="left">mpz_t <b>mpq_denref</b><i> (mpq_t <var>op</var>)
</i></td>
<td align="right">Macro</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Return a reference to the numerator and denominator of <var>op</var>, respectively. 
The <code>mpz</code> functions can be used on the result of these macros. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpq_get_num</b><i> (mpz_t <var>numerator</var>, mpq_t <var>rational</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpq_get_den</b><i> (mpz_t <var>denominator</var>, mpq_t <var>rational</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpq_set_num</b><i> (mpq_t <var>rational</var>, mpz_t <var>numerator</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpq_set_den</b><i> (mpq_t <var>rational</var>, mpz_t <var>denominator</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Get or set the numerator or denominator of a rational.  These functions are
equivalent to calling <code>mpz_set</code> with an appropriate <code>mpq_numref</code> or
<code>mpq_denref</code>.  Direct use of <code>mpq_numref</code> or <code>mpq_denref</code> is
recommended instead of these functions. 
</td></tr>
</table>

<p><hr>
Node:<a name="I%2fO%20of%20Rationals">I/O of Rationals</a>,
Previous:<a rel=previous accesskey=p href="#Applying%20Integer%20Functions">Applying Integer Functions</a>,
Up:<a rel=up accesskey=u href="#Rational%20Number%20Functions">Rational Number Functions</a>
<br>

<h3>Input and Output Functions</h3>

<p>When using any of these functions, it's a good idea to include <code>stdio.h</code>
before <code>gmp.h</code>, since that will allow <code>gmp.h</code> to define prototypes
for these functions.

<p>Passing a <code>NULL</code> pointer for a <var>stream</var> argument to any of these
functions will make them read from <code>stdin</code> and write to <code>stdout</code>,
respectively.

<p>
<table width="100%">
<tr>
<td align="left">size_t <b>mpq_out_str</b><i> (FILE *<var>stream</var>, int <var>base</var>, mpq_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Output <var>op</var> on stdio stream <var>stream</var>, as a string of digits in base
<var>base</var>.  The base may vary from 2 to 36.  Output is in the form
<code>num/den</code> or if the denominator is 1 then just <code>num</code>.

<p>Return the number of bytes written, or if an error occurred, return 0. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">size_t <b>mpq_inp_str</b><i> (mpq_t <var>rop</var>, FILE *<var>stream</var>, int <var>base</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Read a string of digits from <var>stream</var> and convert them to a rational in
<var>rop</var>.  Any initial white-space characters are read and discarded.  Return
the number of characters read (including white space), or 0 if a rational
could not be read.

<p>The input can be a fraction like <code>17/63</code> or just an integer like
<code>123</code>.  Reading stops at the first character not in this form, and white
space is not permitted within the string.  If the input might not be in
canonical form, then <code>mpq_canonicalize</code> must be called (see <a href="#Rational%20Number%20Functions">Rational Number Functions</a>).

<p>The <var>base</var> can be between 2 and 36, or can be 0 in which case the leading
characters of the string determine the base, <code>0x</code> or <code>0X</code> for
hexadecimal, <code>0</code> for octal, or decimal otherwise.  The leading characters
are examined separately for the numerator and denominator of a fraction, so
for instance <code>0x10/11</code> is 16/11, whereas <code>0x10/0x11</code> is 16/17. 
</td></tr>
</table>

<p><hr>
Node:<a name="Floating-point%20Functions">Floating-point Functions</a>,
Next:<a rel=next accesskey=n href="#Low-level%20Functions">Low-level Functions</a>,
Previous:<a rel=previous accesskey=p href="#Rational%20Number%20Functions">Rational Number Functions</a>,
Up:<a rel=up accesskey=u href="#Top">Top</a>
<br>

<h2>Floating-point Functions</h2>

<p>GMP floating point numbers are stored in objects of type <code>mpf_t</code> and
functions operating on them have an <code>mpf_</code> prefix.

<p>The mantissa of each float has a user-selectable precision, limited only by
available memory.  Each variable has its own precision, and that can be
increased or decreased at any time.

<p>The exponent of each float is a fixed precision, one machine word on most
systems.  In the current implementation the exponent is a count of limbs, so
for example on a 32-bit system this means a range of roughly
2^-68719476768 to 2^68719476736, or on a 64-bit system
this will be greater.  Note however <code>mpf_get_str</code> can only return an
exponent which fits an <code>mp_exp_t</code> and currently <code>mpf_set_str</code>
doesn't accept exponents bigger than a <code>long</code>.

<p>Each variable keeps a size for the mantissa data actually in use.  This means
that if a float is exactly represented in only a few bits then only those bits
will be used in a calculation, even if the selected precision is high.

<p>All calculations are performed to the precision of the destination variable. 
Each function is defined to calculate with "infinite precision" followed by
a truncation to the destination precision, but of course the work done is only
what's needed to determine a result under that definition.

<p>The precision selected for a variable is a minimum value, GMP may increase it
a little to facilitate efficient calculation.  Currently this means rounding
up to a whole limb, and then sometimes having a further partial limb,
depending on the high limb of the mantissa.  But applications shouldn't be
concerned by such details.

<p><code>mpf</code> functions and variables have no special notion of infinity or
not-a-number, and applications must take care not to overflow the exponent or
results will be unpredictable.  This might change in a future release.

<p>Note that the <code>mpf</code> functions are <em>not</em> intended as a smooth
extension to IEEE P754 arithmetic.  In particular results obtained on one
computer often differ from the results on a computer with a different word
size.

<ul>
<li><a accesskey=1 href="#Initializing%20Floats">Initializing Floats</a>: 
<li><a accesskey=2 href="#Assigning%20Floats">Assigning Floats</a>: 
<li><a accesskey=3 href="#Simultaneous%20Float%20Init%20&amp;%20Assign">Simultaneous Float Init &amp; Assign</a>: 
<li><a accesskey=4 href="#Converting%20Floats">Converting Floats</a>: 
<li><a accesskey=5 href="#Float%20Arithmetic">Float Arithmetic</a>: 
<li><a accesskey=6 href="#Float%20Comparison">Float Comparison</a>: 
<li><a accesskey=7 href="#I%2fO%20of%20Floats">I/O of Floats</a>: 
<li><a accesskey=8 href="#Miscellaneous%20Float%20Functions">Miscellaneous Float Functions</a>: 
</ul>

<p><hr>
Node:<a name="Initializing%20Floats">Initializing Floats</a>,
Next:<a rel=next accesskey=n href="#Assigning%20Floats">Assigning Floats</a>,
Previous:<a rel=previous accesskey=p href="#Floating-point%20Functions">Floating-point Functions</a>,
Up:<a rel=up accesskey=u href="#Floating-point%20Functions">Floating-point Functions</a>
<br>

<h3>Initialization Functions</h3>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpf_set_default_prec</b><i> (unsigned long int <var>prec</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set the default precision to be <strong>at least</strong> <var>prec</var> bits.  All
subsequent calls to <code>mpf_init</code> will use this precision, but previously
initialized variables are unaffected. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">unsigned long int <b>mpf_get_default_prec</b><i> (void)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Return the default default precision actually used. 
</td></tr>
</table>

<p>An <code>mpf_t</code> object must be initialized before storing the first value in
it.  The functions <code>mpf_init</code> and <code>mpf_init2</code> are used for that
purpose.

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpf_init</b><i> (mpf_t <var>x</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Initialize <var>x</var> to 0.  Normally, a variable should be initialized once only
or at least be cleared, using <code>mpf_clear</code>, between initializations.  The
precision of <var>x</var> is undefined unless a default precision has already been
established by a call to <code>mpf_set_default_prec</code>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpf_init2</b><i> (mpf_t <var>x</var>, unsigned long int <var>prec</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Initialize <var>x</var> to 0 and set its precision to be <strong>at least</strong>
<var>prec</var> bits.  Normally, a variable should be initialized once only or at
least be cleared, using <code>mpf_clear</code>, between initializations. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpf_clear</b><i> (mpf_t <var>x</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Free the space occupied by <var>x</var>.  Make sure to call this function for all
<code>mpf_t</code> variables when you are done with them. 
</td></tr>
</table>

<p>Here is an example on how to initialize floating-point variables:
<br><pre>{
  mpf_t x, y;
  mpf_init (x);           /* use default precision */
  mpf_init2 (y, 256);     /* precision <em>at least</em> 256 bits */
  <small>...</small>
  /* Unless the program is about to exit, do ... */
  mpf_clear (x);
  mpf_clear (y);
}
</pre>

<p>The following three functions are useful for changing the precision during a
calculation.  A typical use would be for adjusting the precision gradually in
iterative algorithms like Newton-Raphson, making the computation precision
closely match the actual accurate part of the numbers.

<p>
<table width="100%">
<tr>
<td align="left">unsigned long int <b>mpf_get_prec</b><i> (mpf_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Return the current precision of <var>op</var>, in bits. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpf_set_prec</b><i> (mpf_t <var>rop</var>, unsigned long int <var>prec</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set the precision of <var>rop</var> to be <strong>at least</strong> <var>prec</var> bits.  The
value in <var>rop</var> will be truncated to the new precision.

<p>This function requires a call to <code>realloc</code>, and so should not be used in
a tight loop. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpf_set_prec_raw</b><i> (mpf_t <var>rop</var>, unsigned long int <var>prec</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set the precision of <var>rop</var> to be <strong>at least</strong> <var>prec</var> bits,
without changing the memory allocated.

<p><var>prec</var> must be no more than the allocated precision for <var>rop</var>, that
being the precision when <var>rop</var> was initialized, or in the most recent
<code>mpf_set_prec</code>.

<p>The value in <var>rop</var> is unchanged, and in particular if it had a higher
precision than <var>prec</var> it will retain that higher precision.  New values
written to <var>rop</var> will use the new <var>prec</var>.

<p>Before calling <code>mpf_clear</code> or the full <code>mpf_set_prec</code>, another
<code>mpf_set_prec_raw</code> call must be made to restore <var>rop</var> to its original
allocated precision.  Failing to do so will have unpredictable results.

<p><code>mpf_get_prec</code> can be used before <code>mpf_set_prec_raw</code> to get the
original allocated precision.  After <code>mpf_set_prec_raw</code> it reflects the
<var>prec</var> value set.

<p><code>mpf_set_prec_raw</code> is an efficient way to use an <code>mpf_t</code> variable at
different precisions during a calculation, perhaps to gradually increase
precision in an iteration, or just to use various different precisions for
different purposes during a calculation. 
</td></tr>
</table>

<p><hr>
Node:<a name="Assigning%20Floats">Assigning Floats</a>,
Next:<a rel=next accesskey=n href="#Simultaneous%20Float%20Init%20&amp;%20Assign">Simultaneous Float Init & Assign</a>,
Previous:<a rel=previous accesskey=p href="#Initializing%20Floats">Initializing Floats</a>,
Up:<a rel=up accesskey=u href="#Floating-point%20Functions">Floating-point Functions</a>
<br>

<h3>Assignment Functions</h3>

<p>These functions assign new values to already initialized floats
(see <a href="#Initializing%20Floats">Initializing Floats</a>).

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpf_set</b><i> (mpf_t <var>rop</var>, mpf_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpf_set_ui</b><i> (mpf_t <var>rop</var>, unsigned long int <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpf_set_si</b><i> (mpf_t <var>rop</var>, signed long int <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpf_set_d</b><i> (mpf_t <var>rop</var>, double <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpf_set_z</b><i> (mpf_t <var>rop</var>, mpz_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpf_set_q</b><i> (mpf_t <var>rop</var>, mpq_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set the value of <var>rop</var> from <var>op</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>mpf_set_str</b><i> (mpf_t <var>rop</var>, char *<var>str</var>, int <var>base</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set the value of <var>rop</var> from the string in <var>str</var>.  The string is of the
form <code>M@N</code> or, if the base is 10 or less, alternatively <code>MeN</code>. 
<code>M</code> is the mantissa and <code>N</code> is the exponent.  The mantissa is always
in the specified base.  The exponent is either in the specified base or, if
<var>base</var> is negative, in decimal.  The decimal point expected is taken from
the current locale, on systems providing <code>localeconv</code>.

<p>The argument <var>base</var> may be in the ranges 2 to 36, or -36 to
-2.  Negative values are used to specify that the exponent is in
decimal.

<p>Unlike the corresponding <code>mpz</code> function, the base will not be determined
from the leading characters of the string if <var>base</var> is 0.  This is so that
numbers like <code>0.23</code> are not interpreted as octal.

<p>White space is allowed in the string, and is simply ignored.  [This is not
really true; white-space is ignored in the beginning of the string and within
the mantissa, but not in other places, such as after a minus sign or in the
exponent.  We are considering changing the definition of this function, making
it fail when there is any white-space in the input, since that makes a lot of
sense.  Please tell us your opinion about this change.  Do you really want it
to accept <code>"3 14"</code> as meaning 314 as it does now?]

<p>This function returns 0 if the entire string is a valid number in base
<var>base</var>.  Otherwise it returns -1. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpf_swap</b><i> (mpf_t <var>rop1</var>, mpf_t <var>rop2</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Swap <var>rop1</var> and <var>rop2</var> efficiently.  Both the values and the
precisions of the two variables are swapped. 
</td></tr>
</table>

<p><hr>
Node:<a name="Simultaneous%20Float%20Init%20&amp;%20Assign">Simultaneous Float Init & Assign</a>,
Next:<a rel=next accesskey=n href="#Converting%20Floats">Converting Floats</a>,
Previous:<a rel=previous accesskey=p href="#Assigning%20Floats">Assigning Floats</a>,
Up:<a rel=up accesskey=u href="#Floating-point%20Functions">Floating-point Functions</a>
<br>

<h3>Combined Initialization and Assignment Functions</h3>

<p>For convenience, GMP provides a parallel series of initialize-and-set functions
which initialize the output and then store the value there.  These functions'
names have the form <code>mpf_init_set<small>...</small></code>

<p>Once the float has been initialized by any of the <code>mpf_init_set<small>...</small></code>
functions, it can be used as the source or destination operand for the ordinary
float functions.  Don't use an initialize-and-set function on a variable
already initialized!

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpf_init_set</b><i> (mpf_t <var>rop</var>, mpf_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpf_init_set_ui</b><i> (mpf_t <var>rop</var>, unsigned long int <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpf_init_set_si</b><i> (mpf_t <var>rop</var>, signed long int <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpf_init_set_d</b><i> (mpf_t <var>rop</var>, double <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Initialize <var>rop</var> and set its value from <var>op</var>.

<p>The precision of <var>rop</var> will be taken from the active default precision, as
set by <code>mpf_set_default_prec</code>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>mpf_init_set_str</b><i> (mpf_t <var>rop</var>, char *<var>str</var>, int <var>base</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Initialize <var>rop</var> and set its value from the string in <var>str</var>.  See
<code>mpf_set_str</code> above for details on the assignment operation.

<p>Note that <var>rop</var> is initialized even if an error occurs.  (I.e., you have to
call <code>mpf_clear</code> for it.)

<p>The precision of <var>rop</var> will be taken from the active default precision, as
set by <code>mpf_set_default_prec</code>. 
</td></tr>
</table>

<p><hr>
Node:<a name="Converting%20Floats">Converting Floats</a>,
Next:<a rel=next accesskey=n href="#Float%20Arithmetic">Float Arithmetic</a>,
Previous:<a rel=previous accesskey=p href="#Simultaneous%20Float%20Init%20&amp;%20Assign">Simultaneous Float Init & Assign</a>,
Up:<a rel=up accesskey=u href="#Floating-point%20Functions">Floating-point Functions</a>
<br>

<h3>Conversion Functions</h3>

<p>
<table width="100%">
<tr>
<td align="left">double <b>mpf_get_d</b><i> (mpf_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Convert <var>op</var> to a <code>double</code>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">double <b>mpf_get_d_2exp</b><i> (signed long int <var>exp</var>, mpf_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Find <var>d</var> and <var>exp</var> such that <var>d</var> times 2
raised to <var>exp</var>, with 0.5&lt;=abs(<var>d</var>)&lt;1, is a good
approximation to <var>op</var>.  This is similar to the standard C function
<code>frexp</code>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">long <b>mpf_get_si</b><i> (mpf_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">unsigned long <b>mpf_get_ui</b><i> (mpf_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Convert <var>op</var> to a <code>long</code> or <code>unsigned long</code>, truncating any
fraction part.  If <var>op</var> is too big for the return type, the result is
undefined.

<p>See also <code>mpf_fits_slong_p</code> and <code>mpf_fits_ulong_p</code>
(see <a href="#Miscellaneous%20Float%20Functions">Miscellaneous Float Functions</a>). 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">char * <b>mpf_get_str</b><i> (char *<var>str</var>, mp_exp_t *<var>expptr</var>, int <var>base</var>, size_t <var>n_digits</var>, mpf_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Convert <var>op</var> to a string of digits in base <var>base</var>.  <var>base</var> can be
2 to 36.  Up to <var>n_digits</var> digits will be generated.  Trailing zeros are
not returned.  No more digits than can be accurately represented by <var>op</var>
are ever generated.  If <var>n_digits</var> is 0 then that accurate maximum number
of digits are generated.

<p>If <var>str</var> is <code>NULL</code>, the result string is allocated using the current
allocation function (see <a href="#Custom%20Allocation">Custom Allocation</a>).  The block will be
<code>strlen(str)+1</code> bytes, that being exactly enough for the string and
null-terminator.

<p>If <var>str</var> is not <code>NULL</code>, it should point to a block of
<var>n\_digits</var> + 2 bytes, that being enough for the mantissa, a
possible minus sign, and a null-terminator.  When <var>n_digits</var> is 0 to get
all significant digits, an application won't be able to know the space
required, and <var>str</var> should be <code>NULL</code> in that case.

<p>The generated string is a fraction, with an implicit radix point immediately
to the left of the first digit.  The applicable exponent is written through
the <var>expptr</var> pointer.  For example, the number 3.1416 would be returned as
string <code>"31416"</code> and exponent 1.

<p>When <var>op</var> is zero, an empty string is produced and the exponent returned
is 0.

<p>A pointer to the result string is returned, being either the allocated block
or the given <var>str</var>. 
</td></tr>
</table>

<p><hr>
Node:<a name="Float%20Arithmetic">Float Arithmetic</a>,
Next:<a rel=next accesskey=n href="#Float%20Comparison">Float Comparison</a>,
Previous:<a rel=previous accesskey=p href="#Converting%20Floats">Converting Floats</a>,
Up:<a rel=up accesskey=u href="#Floating-point%20Functions">Floating-point Functions</a>
<br>

<h3>Arithmetic Functions</h3>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpf_add</b><i> (mpf_t <var>rop</var>, mpf_t <var>op1</var>, mpf_t <var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpf_add_ui</b><i> (mpf_t <var>rop</var>, mpf_t <var>op1</var>, unsigned long int <var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>rop</var> to <var>op1</var> + <var>op2</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpf_sub</b><i> (mpf_t <var>rop</var>, mpf_t <var>op1</var>, mpf_t <var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpf_ui_sub</b><i> (mpf_t <var>rop</var>, unsigned long int <var>op1</var>, mpf_t <var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpf_sub_ui</b><i> (mpf_t <var>rop</var>, mpf_t <var>op1</var>, unsigned long int <var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>rop</var> to <var>op1</var> - <var>op2</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpf_mul</b><i> (mpf_t <var>rop</var>, mpf_t <var>op1</var>, mpf_t <var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpf_mul_ui</b><i> (mpf_t <var>rop</var>, mpf_t <var>op1</var>, unsigned long int <var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>rop</var> to <var>op1</var> times <var>op2</var>. 
</td></tr>
</table>

<p>Division is undefined if the divisor is zero, and passing a zero divisor to the
divide functions will make these functions intentionally divide by zero.  This
lets the user handle arithmetic exceptions in these functions in the same
manner as other arithmetic exceptions.

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpf_div</b><i> (mpf_t <var>rop</var>, mpf_t <var>op1</var>, mpf_t <var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpf_ui_div</b><i> (mpf_t <var>rop</var>, unsigned long int <var>op1</var>, mpf_t <var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpf_div_ui</b><i> (mpf_t <var>rop</var>, mpf_t <var>op1</var>, unsigned long int <var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>rop</var> to <var>op1</var>/<var>op2</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpf_sqrt</b><i> (mpf_t <var>rop</var>, mpf_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpf_sqrt_ui</b><i> (mpf_t <var>rop</var>, unsigned long int <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>rop</var> to the square root of <var>op</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpf_pow_ui</b><i> (mpf_t <var>rop</var>, mpf_t <var>op1</var>, unsigned long int <var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>rop</var> to <var>op1</var> raised to the power <var>op2</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpf_neg</b><i> (mpf_t <var>rop</var>, mpf_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>rop</var> to -<var>op</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpf_abs</b><i> (mpf_t <var>rop</var>, mpf_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>rop</var> to the absolute value of <var>op</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpf_mul_2exp</b><i> (mpf_t <var>rop</var>, mpf_t <var>op1</var>, unsigned long int <var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>rop</var> to <var>op1</var> times 2 raised to
<var>op2</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpf_div_2exp</b><i> (mpf_t <var>rop</var>, mpf_t <var>op1</var>, unsigned long int <var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>rop</var> to <var>op1</var> divided by 2 raised to
<var>op2</var>. 
</td></tr>
</table>

<p><hr>
Node:<a name="Float%20Comparison">Float Comparison</a>,
Next:<a rel=next accesskey=n href="#I%2fO%20of%20Floats">I/O of Floats</a>,
Previous:<a rel=previous accesskey=p href="#Float%20Arithmetic">Float Arithmetic</a>,
Up:<a rel=up accesskey=u href="#Floating-point%20Functions">Floating-point Functions</a>
<br>

<h3>Comparison Functions</h3>

<p>
<table width="100%">
<tr>
<td align="left">int <b>mpf_cmp</b><i> (mpf_t <var>op1</var>, mpf_t <var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">int <b>mpf_cmp_d</b><i> (mpf_t <var>op1</var>, double <var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">int <b>mpf_cmp_ui</b><i> (mpf_t <var>op1</var>, unsigned long int <var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">int <b>mpf_cmp_si</b><i> (mpf_t <var>op1</var>, signed long int <var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Compare <var>op1</var> and <var>op2</var>.  Return a positive value if <var>op1</var> &gt;
<var>op2</var>, zero if <var>op1</var> = <var>op2</var>, and a negative value if
<var>op1</var> &lt; <var>op2</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>mpf_eq</b><i> (mpf_t <var>op1</var>, mpf_t <var>op2</var>, unsigned long int op3)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Return non-zero if the first <var>op3</var> bits of <var>op1</var> and <var>op2</var> are
equal, zero otherwise.  I.e., test of <var>op1</var> and <var>op2</var> are approximately
equal.

<p>Caution: Currently only whole limbs are compared, and only in an exact
fashion.  In the future values like 1000 and 0111 may be considered the same
to 3 bits (on the basis that their difference is that small). 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpf_reldiff</b><i> (mpf_t <var>rop</var>, mpf_t <var>op1</var>, mpf_t <var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Compute the relative difference between <var>op1</var> and <var>op2</var> and store the
result in <var>rop</var>.  This is abs(<var>op1</var>-<var>op2</var>)/<var>op1</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>mpf_sgn</b><i> (mpf_t <var>op</var>)
</i></td>
<td align="right">Macro</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Return +1 if <var>op</var> &gt; 0, 0 if <var>op</var> = 0, and
-1 if <var>op</var> &lt; 0.

<p>This function is actually implemented as a macro.  It evaluates its arguments
multiple times. 
</td></tr>
</table>

<p><hr>
Node:<a name="I%2fO%20of%20Floats">I/O of Floats</a>,
Next:<a rel=next accesskey=n href="#Miscellaneous%20Float%20Functions">Miscellaneous Float Functions</a>,
Previous:<a rel=previous accesskey=p href="#Float%20Comparison">Float Comparison</a>,
Up:<a rel=up accesskey=u href="#Floating-point%20Functions">Floating-point Functions</a>
<br>

<h3>Input and Output Functions</h3>

<p>Functions that perform input from a stdio stream, and functions that output to
a stdio stream.  Passing a <code>NULL</code> pointer for a <var>stream</var> argument to
any of these functions will make them read from <code>stdin</code> and write to
<code>stdout</code>, respectively.

<p>When using any of these functions, it is a good idea to include <code>stdio.h</code>
before <code>gmp.h</code>, since that will allow <code>gmp.h</code> to define prototypes
for these functions.

<p>
<table width="100%">
<tr>
<td align="left">size_t <b>mpf_out_str</b><i> (FILE *<var>stream</var>, int <var>base</var>, size_t <var>n_digits</var>, mpf_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Print <var>op</var> to <var>stream</var>, as a string of digits.  Return the number of
bytes written, or if an error occurred, return 0.

<p>The mantissa is prefixed with an <code>0.</code> and is in the given <var>base</var>,
which may vary from 2 to 36.  An exponent then printed, separated by an
<code>e</code>, or if <var>base</var> is greater than 10 then by an <code>@</code>.  The
exponent is always in decimal.  The decimal point follows the current locale,
on systems providing <code>localeconv</code>.

<p>Up to <var>n_digits</var> will be printed from the mantissa, except that no more
digits than are accurately representable by <var>op</var> will be printed. 
<var>n_digits</var> can be 0 to select that accurate maximum. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">size_t <b>mpf_inp_str</b><i> (mpf_t <var>rop</var>, FILE *<var>stream</var>, int <var>base</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Read a string in base <var>base</var> from <var>stream</var>, and put the read float in
<var>rop</var>.  The string is of the form <code>M@N</code> or, if the base is 10 or
less, alternatively <code>MeN</code>.  <code>M</code> is the mantissa and <code>N</code> is the
exponent.  The mantissa is always in the specified base.  The exponent is
either in the specified base or, if <var>base</var> is negative, in decimal.  The
decimal point expected is taken from the current locale, on systems providing
<code>localeconv</code>.

<p>The argument <var>base</var> may be in the ranges 2 to 36, or -36 to
-2.  Negative values are used to specify that the exponent is in
decimal.

<p>Unlike the corresponding <code>mpz</code> function, the base will not be determined
from the leading characters of the string if <var>base</var> is 0.  This is so that
numbers like <code>0.23</code> are not interpreted as octal.

<p>Return the number of bytes read, or if an error occurred, return 0. 
</td></tr>
</table>

<p><hr>
Node:<a name="Miscellaneous%20Float%20Functions">Miscellaneous Float Functions</a>,
Previous:<a rel=previous accesskey=p href="#I%2fO%20of%20Floats">I/O of Floats</a>,
Up:<a rel=up accesskey=u href="#Floating-point%20Functions">Floating-point Functions</a>
<br>

<h3>Miscellaneous Functions</h3>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpf_ceil</b><i> (mpf_t <var>rop</var>, mpf_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpf_floor</b><i> (mpf_t <var>rop</var>, mpf_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpf_trunc</b><i> (mpf_t <var>rop</var>, mpf_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>rop</var> to <var>op</var> rounded to an integer.  <code>mpf_ceil</code> rounds to the
next higher integer, <code>mpf_floor</code> to the next lower, and <code>mpf_trunc</code>
to the integer towards zero. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>mpf_integer_p</b><i> (mpf_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Return non-zero if <var>op</var> is an integer. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>mpf_fits_ulong_p</b><i> (mpf_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">int <b>mpf_fits_slong_p</b><i> (mpf_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">int <b>mpf_fits_uint_p</b><i> (mpf_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">int <b>mpf_fits_sint_p</b><i> (mpf_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">int <b>mpf_fits_ushort_p</b><i> (mpf_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">int <b>mpf_fits_sshort_p</b><i> (mpf_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Return non-zero if <var>op</var> would fit in the respective C data type, when
truncated to an integer. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpf_urandomb</b><i> (mpf_t <var>rop</var>, gmp_randstate_t <var>state</var>, unsigned long int <var>nbits</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Generate a uniformly distributed random float in <var>rop</var>, such that 0
&lt;= <var>rop</var> &lt; 1, with <var>nbits</var> significant bits in the mantissa.

<p>The variable <var>state</var> must be initialized by calling one of the
<code>gmp_randinit</code> functions (<a href="#Random%20State%20Initialization">Random State Initialization</a>) before
invoking this function. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpf_random2</b><i> (mpf_t <var>rop</var>, mp_size_t <var>max_size</var>, mp_exp_t <var>exp</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Generate a random float of at most <var>max_size</var> limbs, with long strings of
zeros and ones in the binary representation.  The exponent of the number is in
the interval -<var>exp</var> to <var>exp</var>.  This function is useful for
testing functions and algorithms, since this kind of random numbers have proven
to be more likely to trigger corner-case bugs.  Negative random numbers are
generated when <var>max_size</var> is negative. 
</td></tr>
</table>

<p><hr>
Node:<a name="Low-level%20Functions">Low-level Functions</a>,
Next:<a rel=next accesskey=n href="#Random%20Number%20Functions">Random Number Functions</a>,
Previous:<a rel=previous accesskey=p href="#Floating-point%20Functions">Floating-point Functions</a>,
Up:<a rel=up accesskey=u href="#Top">Top</a>
<br>

<h2>Low-level Functions</h2>

<p>This chapter describes low-level GMP functions, used to implement the
high-level GMP functions, but also intended for time-critical user code.

<p>These functions start with the prefix <code>mpn_</code>.

<p>The <code>mpn</code> functions are designed to be as fast as possible, <strong>not</strong>
to provide a coherent calling interface.  The different functions have somewhat
similar interfaces, but there are variations that make them hard to use.  These
functions do as little as possible apart from the real multiple precision
computation, so that no time is spent on things that not all callers need.

<p>A source operand is specified by a pointer to the least significant limb and a
limb count.  A destination operand is specified by just a pointer.  It is the
responsibility of the caller to ensure that the destination has enough space
for storing the result.

<p>With this way of specifying operands, it is possible to perform computations on
subranges of an argument, and store the result into a subrange of a
destination.

<p>A common requirement for all functions is that each source area needs at least
one limb.  No size argument may be zero.  Unless otherwise stated, in-place
operations are allowed where source and destination are the same, but not where
they only partly overlap.

<p>The <code>mpn</code> functions are the base for the implementation of the
<code>mpz_</code>, <code>mpf_</code>, and <code>mpq_</code> functions.

<p>This example adds the number beginning at <var>s1p</var> and the number beginning at
<var>s2p</var> and writes the sum at <var>destp</var>.  All areas have <var>n</var> limbs.

<br><pre>cy = mpn_add_n (destp, s1p, s2p, n)
</pre>

<p>In the notation used here, a source operand is identified by the pointer to
the least significant limb, and the limb count in braces.  For example,
{<var>s1p</var>, <var>s1n</var>}.

<p>
<table width="100%">
<tr>
<td align="left">mp_limb_t <b>mpn_add_n</b><i> (mp_limb_t *<var>rp</var>, const mp_limb_t *<var>s1p</var>, const mp_limb_t *<var>s2p</var>, mp_size_t <var>n</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Add {<var>s1p</var>, <var>n</var>} and {<var>s2p</var>, <var>n</var>}, and write the <var>n</var>
least significant limbs of the result to <var>rp</var>.  Return carry, either 0 or
1.

<p>This is the lowest-level function for addition.  It is the preferred function
for addition, since it is written in assembly for most CPUs.  For addition of
a variable to itself (i.e., <var>s1p</var> equals <var>s2p</var>, use <code>mpn_lshift</code>
with a count of 1 for optimal speed. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">mp_limb_t <b>mpn_add_1</b><i> (mp_limb_t *<var>rp</var>, const mp_limb_t *<var>s1p</var>, mp_size_t <var>n</var>, mp_limb_t <var>s2limb</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Add {<var>s1p</var>, <var>n</var>} and <var>s2limb</var>, and write the <var>n</var> least
significant limbs of the result to <var>rp</var>.  Return carry, either 0 or 1. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">mp_limb_t <b>mpn_add</b><i> (mp_limb_t *<var>rp</var>, const mp_limb_t *<var>s1p</var>, mp_size_t <var>s1n</var>, const mp_limb_t *<var>s2p</var>, mp_size_t <var>s2n</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Add {<var>s1p</var>, <var>s1n</var>} and {<var>s2p</var>, <var>s2n</var>}, and write the
<var>s1n</var> least significant limbs of the result to <var>rp</var>.  Return carry,
either 0 or 1.

<p>This function requires that <var>s1n</var> is greater than or equal to <var>s2n</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">mp_limb_t <b>mpn_sub_n</b><i> (mp_limb_t *<var>rp</var>, const mp_limb_t *<var>s1p</var>, const mp_limb_t *<var>s2p</var>, mp_size_t <var>n</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Subtract {<var>s2p</var>, <var>n</var>} from {<var>s1p</var>, <var>n</var>}, and write the
<var>n</var> least significant limbs of the result to <var>rp</var>.  Return borrow,
either 0 or 1.

<p>This is the lowest-level function for subtraction.  It is the preferred
function for subtraction, since it is written in assembly for most CPUs. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">mp_limb_t <b>mpn_sub_1</b><i> (mp_limb_t *<var>rp</var>, const mp_limb_t *<var>s1p</var>, mp_size_t <var>n</var>, mp_limb_t <var>s2limb</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Subtract <var>s2limb</var> from {<var>s1p</var>, <var>n</var>}, and write the <var>n</var> least
significant limbs of the result to <var>rp</var>.  Return borrow, either 0 or 1. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">mp_limb_t <b>mpn_sub</b><i> (mp_limb_t *<var>rp</var>, const mp_limb_t *<var>s1p</var>, mp_size_t <var>s1n</var>, const mp_limb_t *<var>s2p</var>, mp_size_t <var>s2n</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Subtract {<var>s2p</var>, <var>s2n</var>} from {<var>s1p</var>, <var>s1n</var>}, and write the
<var>s1n</var> least significant limbs of the result to <var>rp</var>.  Return borrow,
either 0 or 1.

<p>This function requires that <var>s1n</var> is greater than or equal to
<var>s2n</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpn_mul_n</b><i> (mp_limb_t *<var>rp</var>, const mp_limb_t *<var>s1p</var>, const mp_limb_t *<var>s2p</var>, mp_size_t <var>n</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Multiply {<var>s1p</var>, <var>n</var>} and {<var>s2p</var>, <var>n</var>}, and write the
2*<var>n</var>-limb result to <var>rp</var>.

<p>The destination has to have space for 2*<var>n</var> limbs, even if the product's
most significant limb is zero. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">mp_limb_t <b>mpn_mul_1</b><i> (mp_limb_t *<var>rp</var>, const mp_limb_t *<var>s1p</var>, mp_size_t <var>n</var>, mp_limb_t <var>s2limb</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Multiply {<var>s1p</var>, <var>n</var>} by <var>s2limb</var>, and write the <var>n</var> least
significant limbs of the product to <var>rp</var>.  Return the most significant
limb of the product.  {<var>s1p</var>, <var>n</var>} and {<var>rp</var>, <var>n</var>} are
allowed to overlap provided <var>rp</var> &lt;= <var>s1p</var>.

<p>This is a low-level function that is a building block for general
multiplication as well as other operations in GMP.  It is written in assembly
for most CPUs.

<p>Don't call this function if <var>s2limb</var> is a power of 2; use <code>mpn_lshift</code>
with a count equal to the logarithm of <var>s2limb</var> instead, for optimal speed. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">mp_limb_t <b>mpn_addmul_1</b><i> (mp_limb_t *<var>rp</var>, const mp_limb_t *<var>s1p</var>, mp_size_t <var>n</var>, mp_limb_t <var>s2limb</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Multiply {<var>s1p</var>, <var>n</var>} and <var>s2limb</var>, and add the <var>n</var> least
significant limbs of the product to {<var>rp</var>, <var>n</var>} and write the result
to <var>rp</var>.  Return the most significant limb of the product, plus carry-out
from the addition.

<p>This is a low-level function that is a building block for general
multiplication as well as other operations in GMP.  It is written in assembly
for most CPUs. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">mp_limb_t <b>mpn_submul_1</b><i> (mp_limb_t *<var>rp</var>, const mp_limb_t *<var>s1p</var>, mp_size_t <var>n</var>, mp_limb_t <var>s2limb</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Multiply {<var>s1p</var>, <var>n</var>} and <var>s2limb</var>, and subtract the <var>n</var>
least significant limbs of the product from {<var>rp</var>, <var>n</var>} and write the
result to <var>rp</var>.  Return the most significant limb of the product, minus
borrow-out from the subtraction.

<p>This is a low-level function that is a building block for general
multiplication and division as well as other operations in GMP.  It is written
in assembly for most CPUs. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">mp_limb_t <b>mpn_mul</b><i> (mp_limb_t *<var>rp</var>, const mp_limb_t *<var>s1p</var>, mp_size_t <var>s1n</var>, const mp_limb_t *<var>s2p</var>, mp_size_t <var>s2n</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Multiply {<var>s1p</var>, <var>s1n</var>} and {<var>s2p</var>, <var>s2n</var>}, and write the
result to <var>rp</var>.  Return the most significant limb of the result.

<p>The destination has to have space for <var>s1n</var> + <var>s2n</var> limbs, even if the
result might be one limb smaller.

<p>This function requires that <var>s1n</var> is greater than or equal to
<var>s2n</var>.  The destination must be distinct from both input operands. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpn_tdiv_qr</b><i> (mp_limb_t *<var>qp</var>, mp_limb_t *<var>rp</var>, mp_size_t <var>qxn</var>, const mp_limb_t *<var>np</var>, mp_size_t <var>nn</var>, const mp_limb_t *<var>dp</var>, mp_size_t <var>dn</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Divide {<var>np</var>, <var>nn</var>} by {<var>dp</var>, <var>dn</var>} and put the quotient
at {<var>qp</var>, <var>nn</var>-<var>dn</var>+1} and the remainder at {<var>rp</var>,
<var>dn</var>}.  The quotient is rounded towards 0.

<p>No overlap is permitted between arguments.  <var>nn</var> must be greater than or
equal to <var>dn</var>.  The most significant limb of <var>dp</var> must be non-zero. 
The <var>qxn</var> operand must be zero. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">mp_limb_t <b>mpn_divrem</b><i> (mp_limb_t *<var>r1p</var>, mp_size_t <var>qxn</var>, mp_limb_t *<var>rs2p</var>, mp_size_t <var>rs2n</var>, const mp_limb_t *<var>s3p</var>, mp_size_t <var>s3n</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
[This function is obsolete.  Please call <code>mpn_tdiv_qr</code> instead for best
performance.]

<p>Divide {<var>rs2p</var>, <var>rs2n</var>} by {<var>s3p</var>, <var>s3n</var>}, and write the
quotient at <var>r1p</var>, with the exception of the most significant limb, which
is returned.  The remainder replaces the dividend at <var>rs2p</var>; it will be
<var>s3n</var> limbs long (i.e., as many limbs as the divisor).

<p>In addition to an integer quotient, <var>qxn</var> fraction limbs are developed, and
stored after the integral limbs.  For most usages, <var>qxn</var> will be zero.

<p>It is required that <var>rs2n</var> is greater than or equal to <var>s3n</var>.  It is
required that the most significant bit of the divisor is set.

<p>If the quotient is not needed, pass <var>rs2p</var> + <var>s3n</var> as <var>r1p</var>.  Aside
from that special case, no overlap between arguments is permitted.

<p>Return the most significant limb of the quotient, either 0 or 1.

<p>The area at <var>r1p</var> needs to be <var>rs2n</var> - <var>s3n</var> + <var>qxn</var>
limbs large. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">mp_limb_t <b>mpn_divrem_1</b><i> (mp_limb_t *<var>r1p</var>, mp_size_t <var>qxn</var>, mp_limb_t&nbsp;*<var>s2p</var>, mp_size_t <var>s2n</var>, mp_limb_t <var>s3limb</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">mp_limb_t <b>mpn_divmod_1</b><i> (mp_limb_t *<var>r1p</var>, mp_limb_t *<var>s2p</var>, mp_size_t&nbsp;<var>s2n</var>, mp_limb_t&nbsp;<var>s3limb</var>)
</i></td>
<td align="right">Macro</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Divide {<var>s2p</var>, <var>s2n</var>} by <var>s3limb</var>, and write the quotient at
<var>r1p</var>.  Return the remainder.

<p>The integer quotient is written to {<var>r1p</var>+<var>qxn</var>, <var>s2n</var>} and in
addition <var>qxn</var> fraction limbs are developed and written to {<var>r1p</var>,
<var>qxn</var>}.  Either or both <var>s2n</var> and <var>qxn</var> can be zero.  For most
usages, <var>qxn</var> will be zero.

<p><code>mpn_divmod_1</code> exists for upward source compatibility and is simply a
macro calling <code>mpn_divrem_1</code> with a <var>qxn</var> of 0.

<p>The areas at <var>r1p</var> and <var>s2p</var> have to be identical or completely
separate, not partially overlapping. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">mp_limb_t <b>mpn_divmod</b><i> (mp_limb_t *<var>r1p</var>, mp_limb_t *<var>rs2p</var>, mp_size_t <var>rs2n</var>, const mp_limb_t *<var>s3p</var>, mp_size_t <var>s3n</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
[This function is obsolete.  Please call <code>mpn_tdiv_qr</code> instead for best
performance.] 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">mp_limb_t <b>mpn_divexact_by3</b><i> (mp_limb_t *<var>rp</var>, mp_limb_t *<var>sp</var>, mp_size_t&nbsp;<var>n</var>)
</i></td>
<td align="right">Macro</td>
</tr>

<tr>
<td align="left">mp_limb_t <b>mpn_divexact_by3c</b><i> (mp_limb_t *<var>rp</var>, mp_limb_t *<var>sp</var>, mp_size_t&nbsp;<var>n</var>, mp_limb_t <var>carry</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Divide {<var>sp</var>, <var>n</var>} by 3, expecting it to divide exactly, and writing
the result to {<var>rp</var>, <var>n</var>}.  If 3 divides exactly, the return value is
zero and the result is the quotient.  If not, the return value is non-zero and
the result won't be anything useful.

<p><code>mpn_divexact_by3c</code> takes an initial carry parameter, which can be the
return value from a previous call, so a large calculation can be done piece by
piece from low to high.  <code>mpn_divexact_by3</code> is simply a macro calling
<code>mpn_divexact_by3c</code> with a 0 carry parameter.

<p>These routines use a multiply-by-inverse and will be faster than
<code>mpn_divrem_1</code> on CPUs with fast multiplication but slow division.

<p>The source a, result q, size n, initial carry i,
and return value c satisfy c*b^n + a-i = 3*q, where
b=2^mp_bits_per_limb.  The
return c is always 0, 1 or 2, and the initial carry i must also
be 0, 1 or 2 (these are both borrows really).  When c=0 clearly
q=(a-i)/3.  When c!=0, the remainder (a-i) mod
3 is given by 3-c, because b == 1 mod 3 (when
<code>mp_bits_per_limb</code> is even, which is always so currently). 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">mp_limb_t <b>mpn_mod_1</b><i> (mp_limb_t *<var>s1p</var>, mp_size_t <var>s1n</var>, mp_limb_t <var>s2limb</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Divide {<var>s1p</var>, <var>s1n</var>} by <var>s2limb</var>, and return the remainder. 
<var>s1n</var> can be zero. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">mp_limb_t <b>mpn_bdivmod</b><i> (mp_limb_t *<var>rp</var>, mp_limb_t *<var>s1p</var>, mp_size_t <var>s1n</var>, const mp_limb_t *<var>s2p</var>, mp_size_t <var>s2n</var>, unsigned long int <var>d</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
This function puts the low
floor(<var>d</var>/<code>mp_bits_per_limb</code>) limbs of <var>q</var> =
{<var>s1p</var>, <var>s1n</var>}/{<var>s2p</var>, <var>s2n</var>} mod 2^<var>d</var> at
<var>rp</var>, and returns the high <var>d</var> mod <code>mp_bits_per_limb</code> bits of
<var>q</var>.

<p>{<var>s1p</var>, <var>s1n</var>} - <var>q</var> * {<var>s2p</var>, <var>s2n</var>} mod 2^(<var>s1n</var>*<code>mp_bits_per_limb</code>) is placed at <var>s1p</var>.  Since the
low floor(<var>d</var>/<code>mp_bits_per_limb</code>) limbs of this
difference are zero, it is possible to overwrite the low limbs at <var>s1p</var>
with this difference, provided <var>rp</var> &lt;= <var>s1p</var>.

<p>This function requires that <var>s1n</var> * <code>mp_bits_per_limb</code>
&gt;= <var>D</var>, and that {<var>s2p</var>, <var>s2n</var>} is odd.

<p><strong>This interface is preliminary.  It might change incompatibly in future
revisions.</strong>
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">mp_limb_t <b>mpn_lshift</b><i> (mp_limb_t *<var>rp</var>, const mp_limb_t *<var>sp</var>, mp_size_t <var>n</var>, unsigned int <var>count</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Shift {<var>sp</var>, <var>n</var>} left by <var>count</var> bits, and write the result to
{<var>rp</var>, <var>n</var>}.  The bits shifted out at the left are returned in the
least significant <var>count</var> bits of the return value (the rest of the return
value is zero).

<p><var>count</var> must be in the range 1 to <code>mp_bits_per_limb</code>-1.  The
regions {<var>sp</var>, <var>n</var>} and {<var>rp</var>, <var>n</var>} may overlap, provided
<var>rp</var> &gt;= <var>sp</var>.

<p>This function is written in assembly for most CPUs. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">mp_limb_t <b>mpn_rshift</b><i> (mp_limb_t *<var>rp</var>, const mp_limb_t *<var>sp</var>, mp_size_t <var>n</var>, unsigned int <var>count</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Shift {<var>sp</var>, <var>n</var>} right by <var>count</var> bits, and write the result to
{<var>rp</var>, <var>n</var>}.  The bits shifted out at the right are returned in the
most significant <var>count</var> bits of the return value (the rest of the return
value is zero).

<p><var>count</var> must be in the range 1 to <code>mp_bits_per_limb</code>-1.  The
regions {<var>sp</var>, <var>n</var>} and {<var>rp</var>, <var>n</var>} may overlap, provided
<var>rp</var> &lt;= <var>sp</var>.

<p>This function is written in assembly for most CPUs. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>mpn_cmp</b><i> (const mp_limb_t *<var>s1p</var>, const mp_limb_t *<var>s2p</var>, mp_size_t <var>n</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Compare {<var>s1p</var>, <var>n</var>} and {<var>s2p</var>, <var>n</var>} and return a
positive value if <var>s1</var> &gt; <var>s2</var>, 0 if they are equal, or a
negative value if <var>s1</var> &lt; <var>s2</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">mp_size_t <b>mpn_gcd</b><i> (mp_limb_t *<var>rp</var>, mp_limb_t *<var>s1p</var>, mp_size_t <var>s1n</var>, mp_limb_t *<var>s2p</var>, mp_size_t <var>s2n</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set {<var>rp</var>, <var>retval</var>} to the greatest common divisor of {<var>s1p</var>,
<var>s1n</var>} and {<var>s2p</var>, <var>s2n</var>}.  The result can be up to <var>s2n</var>
limbs, the return value is the actual number produced.  Both source operands
are destroyed.

<p>{<var>s1p</var>, <var>s1n</var>} must have at least as many bits as {<var>s2p</var>,
<var>s2n</var>}.  {<var>s2p</var>, <var>s2n</var>} must be odd.  Both operands must have
non-zero most significant limbs.  No overlap is permitted between {<var>s1p</var>,
<var>s1n</var>} and {<var>s2p</var>, <var>s2n</var>}. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">mp_limb_t <b>mpn_gcd_1</b><i> (const mp_limb_t *<var>s1p</var>, mp_size_t <var>s1n</var>, mp_limb_t <var>s2limb</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Return the greatest common divisor of {<var>s1p</var>, <var>s1n</var>} and
<var>s2limb</var>.  Both operands must be non-zero. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">mp_size_t <b>mpn_gcdext</b><i> (mp_limb_t *<var>r1p</var>, mp_limb_t *<var>r2p</var>, mp_size_t *<var>r2n</var>, mp_limb_t *<var>s1p</var>, mp_size_t <var>s1n</var>, mp_limb_t *<var>s2p</var>, mp_size_t <var>s2n</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Calculate the greatest common divisor of {<var>s1p</var>, <var>s1n</var>} and
{<var>s2p</var>, <var>s2n</var>}.  Store the gcd at {<var>r1p</var>, <var>retval</var>} and
the first cofactor at {<var>r2p</var>, *<var>r2n</var>}, with *<var>r2n</var> negative if
the cofactor is negative.  <var>r1p</var> and <var>r2p</var> should each have room for
<var>s1n</var>+1 limbs, but the return value and value stored through
<var>r2n</var> indicate the actual number produced.

<p>{<var>s1p</var>, <var>s1n</var>} &gt;= {<var>s2p</var>, <var>s2n</var>} is required,
and both must be non-zero.  The regions {<var>s1p</var>, <var>s1n</var>+1} and
{<var>s2p</var>, <var>s2n</var>+1} are destroyed (i.e. the operands plus an
extra limb past the end of each).

<p>The cofactor <var>r1</var> will satisfy <var>r2</var>*<var>s1</var>
+ <var>k</var>*<var>s2</var> = <var>r1</var>.  The second cofactor <var>k</var> is not calculated
but can easily be obtained from (<var>r1</var> -
<var>r2</var>*<var>s1</var>) / <var>s2</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">mp_size_t <b>mpn_sqrtrem</b><i> (mp_limb_t *<var>r1p</var>, mp_limb_t *<var>r2p</var>, const mp_limb_t *<var>sp</var>, mp_size_t <var>n</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Compute the square root of {<var>sp</var>, <var>n</var>} and put the result at
{<var>r1p</var>, ceil(<var>n</var>/2)} and the remainder at {<var>r2p</var>,
<var>retval</var>}.  <var>r2p</var> needs space for <var>n</var> limbs, but the return value
indicates how many are produced.

<p>The most significant limb of {<var>sp</var>, <var>n</var>} must be non-zero.  The
areas {<var>r1p</var>, ceil(<var>n</var>/2)} and {<var>sp</var>, <var>n</var>} must
be completely separate.  The areas {<var>r2p</var>, <var>n</var>} and {<var>sp</var>,
<var>n</var>} must be either identical or completely separate.

<p>If the remainder is not wanted then <var>r2p</var> can be <code>NULL</code>, and in this
case the return value is zero or non-zero according to whether the remainder
would have been zero or non-zero.

<p>A return value of zero indicates a perfect square.  See also
<code>mpz_perfect_square_p</code>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">mp_size_t <b>mpn_get_str</b><i> (unsigned char *<var>str</var>, int <var>base</var>, mp_limb_t *<var>s1p</var>, mp_size_t <var>s1n</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Convert {<var>s1p</var>, <var>s1n</var>} to a raw unsigned char array at <var>str</var> in
base <var>base</var>, and return the number of characters produced.  There may be
leading zeros in the string.  The string is not in ASCII; to convert it to
printable format, add the ASCII codes for <code>0</code> or <code>A</code>, depending on
the base and range.

<p>The most significant limb of the input {<var>s1p</var>, <var>s1n</var>} must be
non-zero.  The input {<var>s1p</var>, <var>s1n</var>} is clobbered, except when
<var>base</var> is a power of 2, in which case it's unchanged.

<p>The area at <var>str</var> has to have space for the largest possible number
represented by a <var>s1n</var> long limb array, plus one extra character. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">mp_size_t <b>mpn_set_str</b><i> (mp_limb_t *<var>rp</var>, const char *<var>str</var>, size_t <var>strsize</var>, int <var>base</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Convert bytes {<var>str</var>,<var>strsize</var>} in the given <var>base</var> to limbs at
<var>rp</var>.

<p><var>str</var>[0] is the most significant byte and
<var>str</var>[<var>strsize</var>-1] is the least significant.  Each byte should
be a value in the range 0 to <var>base</var>-1, not an ASCII character. 
<var>base</var> can vary from 2 to 256.

<p>The return value is the number of limbs written to <var>rp</var>.  If the most
significant input byte is non-zero then the high limb at <var>rp</var> will be
non-zero, and only that exact number of limbs will be required there.

<p>If the most significant input byte is zero then there may be high zero limbs
written to <var>rp</var> and included in the return value.

<p><var>strsize</var> must be at least 1, and no overlap is permitted between
{<var>str</var>,<var>strsize</var>} and the result at <var>rp</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">unsigned long int <b>mpn_scan0</b><i> (const mp_limb_t *<var>s1p</var>, unsigned long int <var>bit</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Scan <var>s1p</var> from bit position <var>bit</var> for the next clear bit.

<p>It is required that there be a clear bit within the area at <var>s1p</var> at or
beyond bit position <var>bit</var>, so that the function has something to return. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">unsigned long int <b>mpn_scan1</b><i> (const mp_limb_t *<var>s1p</var>, unsigned long int <var>bit</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Scan <var>s1p</var> from bit position <var>bit</var> for the next set bit.

<p>It is required that there be a set bit within the area at <var>s1p</var> at or
beyond bit position <var>bit</var>, so that the function has something to return. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpn_random</b><i> (mp_limb_t *<var>r1p</var>, mp_size_t <var>r1n</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpn_random2</b><i> (mp_limb_t *<var>r1p</var>, mp_size_t <var>r1n</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Generate a random number of length <var>r1n</var> and store it at <var>r1p</var>.  The
most significant limb is always non-zero.  <code>mpn_random</code> generates
uniformly distributed limb data, <code>mpn_random2</code> generates long strings of
zeros and ones in the binary representation.

<p><code>mpn_random2</code> is intended for testing the correctness of the <code>mpn</code>
routines. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">unsigned long int <b>mpn_popcount</b><i> (const mp_limb_t *<var>s1p</var>, mp_size_t <var>n</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Count the number of set bits in {<var>s1p</var>, <var>n</var>}. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">unsigned long int <b>mpn_hamdist</b><i> (const mp_limb_t *<var>s1p</var>, const mp_limb_t *<var>s2p</var>, mp_size_t <var>n</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Compute the hamming distance between {<var>s1p</var>, <var>n</var>} and {<var>s2p</var>,
<var>n</var>}. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>mpn_perfect_square_p</b><i> (const mp_limb_t *<var>s1p</var>, mp_size_t <var>n</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Return non-zero iff {<var>s1p</var>, <var>n</var>} is a perfect square. 
</td></tr>
</table>

<br><p>
<h3>Nails</h3>

<p><strong>Everything in this section is highly experimental and may disappear or
be subject to incompatible changes in a future version of GMP.</strong>

<p>Nails are an experimental feature whereby a few bits are left unused at the
top of each <code>mp_limb_t</code>.  This can significantly improve carry handling
on some processors.

<p>All the <code>mpn</code> functions accepting limb data will expect the nail bits to
be zero on entry, and will return data with the nails similarly all zero. 
This applies both to limb vectors and to single limb arguments.

<p>Nails can be enabled by configuring with <code>--enable-nails</code>.  By default
the number of bits will be chosen according to what suits the host processor,
but a particular number can be selected with <code>--enable-nails=N</code>.

<p>At the mpn level, a nail build is neither source nor binary compatible with a
non-nail build, strictly speaking.  But programs acting on limbs only through
the mpn functions are likely to work equally well with either build, and
judicious use of the definitions below should make any program compatible with
either build, at the source level.

<p>For the higher level routines, meaning <code>mpz</code> etc, a nail build should be
fully source and binary compatible with a non-nail build.

<p>
<table width="100%">
<tr>
<td align="left"><b>GMP_NAIL_BITS</b><i>
</i></td>
<td align="right">Macro</td>
</tr>

<tr>
<td align="left"><b>GMP_NUMB_BITS</b><i>
</i></td>
<td align="right">Macro</td>
</tr>

<tr>
<td align="left"><b>GMP_LIMB_BITS</b><i>
</i></td>
<td align="right">Macro</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
<code>GMP_NAIL_BITS</code> is the number of nail bits, or 0 when nails are not in
use.  <code>GMP_NUMB_BITS</code> is the number of data bits in a limb. 
<code>GMP_LIMB_BITS</code> is the total number of bits in an <code>mp_limb_t</code>.  In
all cases

<br><pre>GMP_LIMB_BITS == GMP_NAIL_BITS + GMP_NUMB_BITS
</pre>
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left"><b>GMP_NAIL_MASK</b><i>
</i></td>
<td align="right">Macro</td>
</tr>

<tr>
<td align="left"><b>GMP_NUMB_MASK</b><i>
</i></td>
<td align="right">Macro</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Bit masks for the nail and number parts of a limb.  <code>GMP_NAIL_MASK</code> is 0
when nails are not in use.

<p><code>GMP_NAIL_MASK</code> is not often needed, since the nail part can be obtained
with <code>x &gt;&gt; GMP_NUMB_BITS</code>, and that means one less large constant, which
can help various RISC chips. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left"><b>GMP_NUMB_MAX</b><i>
</i></td>
<td align="right">Macro</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The maximum value that can be stored in the number part of a limb.  This is
the same as <code>GMP_NUMB_MASK</code>, but can be used for clarity when doing
comparisons rather than bit-wise operations. 
</td></tr>
</table>

<p>The term "nails" comes from finger or toe nails, which are at the ends of a
limb (arm or leg).  "numb" is short for number, but is also how the
developers felt after trying for a long time to come up with sensible names
for these things.

<p>In the future (the distant future most likely) a non-zero nail might be
permitted, giving non-unique representations for numbers in a limb vector. 
This would help vector processors since carries would only ever need to
propagate one or two limbs.

<p><hr>
Node:<a name="Random%20Number%20Functions">Random Number Functions</a>,
Next:<a rel=next accesskey=n href="#Formatted%20Output">Formatted Output</a>,
Previous:<a rel=previous accesskey=p href="#Low-level%20Functions">Low-level Functions</a>,
Up:<a rel=up accesskey=u href="#Top">Top</a>
<br>

<h2>Random Number Functions</h2>

<p>Sequences of pseudo-random numbers in GMP are generated using a variable of
type <code>gmp_randstate_t</code>, which holds an algorithm selection and a current
state.  Such a variable must be initialized by a call to one of the
<code>gmp_randinit</code> functions, and can be seeded with one of the
<code>gmp_randseed</code> functions.

<p>The functions actually generating random numbers are described in <a href="#Integer%20Random%20Numbers">Integer Random Numbers</a>, and <a href="#Miscellaneous%20Float%20Functions">Miscellaneous Float Functions</a>.

<p>The older style random number functions don't accept a <code>gmp_randstate_t</code>
parameter but instead share a global variable of that type.  They use a
default algorithm and are currently not seeded (though perhaps that will
change in the future).  The new functions accepting a <code>gmp_randstate_t</code>
are recommended for applications that care about randomness.

<ul>
<li><a accesskey=1 href="#Random%20State%20Initialization">Random State Initialization</a>: 
<li><a accesskey=2 href="#Random%20State%20Seeding">Random State Seeding</a>: 
</ul>

<p><hr>
Node:<a name="Random%20State%20Initialization">Random State Initialization</a>,
Next:<a rel=next accesskey=n href="#Random%20State%20Seeding">Random State Seeding</a>,
Previous:<a rel=previous accesskey=p href="#Random%20Number%20Functions">Random Number Functions</a>,
Up:<a rel=up accesskey=u href="#Random%20Number%20Functions">Random Number Functions</a>
<br>

<h3>Random State Initialization</h3>

<p>
<table width="100%">
<tr>
<td align="left">void <b>gmp_randinit_default</b><i> (gmp_randstate_t <var>state</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Initialize <var>state</var> with a default algorithm.  This will be a compromise
between speed and randomness, and is recommended for applications with no
special requirements. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>gmp_randinit_lc_2exp</b><i> (gmp_randstate_t <var>state</var>, mpz_t <var>a</var>, unsigned&nbsp;long&nbsp;<var>c</var>, unsigned&nbsp;long&nbsp;<var>m2exp</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Initialize <var>state</var> with a linear congruential algorithm X = (<var>a</var>*X + <var>c</var>) mod 2^<var>m2exp</var>.

<p>The low bits of X in this algorithm are not very random.  The least
significant bit will have a period no more than 2, and the second bit no more
than 4, etc.  For this reason only the high half of each X is actually
used.

<p>When a random number of more than <var>m2exp</var>/2 bits is to be
generated, multiple iterations of the recurrence are used and the results
concatenated. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>gmp_randinit_lc_2exp_size</b><i> (gmp_randstate_t <var>state</var>, unsigned long <var>size</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Initialize <var>state</var> for a linear congruential algorithm as per
<code>gmp_randinit_lc_2exp</code>.  <var>a</var>, <var>c</var> and <var>m2exp</var> are selected
from a table, chosen so that <var>size</var> bits (or more) of each X will
be used, ie. <var>m2exp</var> &gt;= <var>size</var>/2.

<p>If successful the return value is non-zero.  If <var>size</var> is bigger than the
table data provides then the return value is zero.  The maximum <var>size</var>
currently supported is 128. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>gmp_randinit</b><i> (gmp_randstate_t <var>state</var>, gmp_randalg_t&nbsp;<var>alg</var>, ...)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
<strong>This function is obsolete.</strong>

<p>Initialize <var>state</var> with an algorithm selected by <var>alg</var>.  The only
choice is <code>GMP_RAND_ALG_LC</code>, which is <code>gmp_randinit_lc_2exp_size</code>. 
A third parameter of type <code>unsigned long</code> is required, this is the
<var>size</var> for that function.  <code>GMP_RAND_ALG_DEFAULT</code> or 0 are the same
as <code>GMP_RAND_ALG_LC</code>.

<p><code>gmp_randinit</code> sets bits in <code>gmp_errno</code> to indicate an error. 
<code>GMP_ERROR_UNSUPPORTED_ARGUMENT</code> if <var>alg</var> is unsupported, or
<code>GMP_ERROR_INVALID_ARGUMENT</code> if the <var>size</var> parameter is too big. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>gmp_randclear</b><i> (gmp_randstate_t <var>state</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Free all memory occupied by <var>state</var>. 
</td></tr>
</table>

<p><hr>
Node:<a name="Random%20State%20Seeding">Random State Seeding</a>,
Previous:<a rel=previous accesskey=p href="#Random%20State%20Initialization">Random State Initialization</a>,
Up:<a rel=up accesskey=u href="#Random%20Number%20Functions">Random Number Functions</a>
<br>

<h3>Random State Seeding</h3>

<p>
<table width="100%">
<tr>
<td align="left">void <b>gmp_randseed</b><i> (gmp_randstate_t <var>state</var>, mpz_t <var>seed</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>gmp_randseed_ui</b><i> (gmp_randstate_t <var>state</var>, unsigned&nbsp;long&nbsp;int&nbsp;<var>seed</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set an initial seed value into <var>state</var>.

<p>The size of a seed determines how many different sequences of random numbers
that it's possible to generate.  The "quality" of the seed is the randomness
of a given seed compared to the previous seed used, and this affects the
randomness of separate number sequences.  The method for choosing a seed is
critical if the generated numbers are to be used for important applications,
such as generating cryptographic keys.

<p>Traditionally the system time has been used to seed, but care needs to be
taken with this.  If an application seeds often and the resolution of the
system clock is low, then the same sequence of numbers might be repeated. 
Also, the system time is quite easy to guess, so if unpredictability is
required then it should definitely not be the only source for the seed value. 
On some systems there's a special device <code>/dev/random</code> which provides
random data better suited for use as a seed. 
</td></tr>
</table>

<p><hr>
Node:<a name="Formatted%20Output">Formatted Output</a>,
Next:<a rel=next accesskey=n href="#Formatted%20Input">Formatted Input</a>,
Previous:<a rel=previous accesskey=p href="#Random%20Number%20Functions">Random Number Functions</a>,
Up:<a rel=up accesskey=u href="#Top">Top</a>
<br>

<h2>Formatted Output</h2>

<ul>
<li><a accesskey=1 href="#Formatted%20Output%20Strings">Formatted Output Strings</a>: 
<li><a accesskey=2 href="#Formatted%20Output%20Functions">Formatted Output Functions</a>: 
<li><a accesskey=3 href="#C++%20Formatted%20Output">C++ Formatted Output</a>: 
</ul>

<p><hr>
Node:<a name="Formatted%20Output%20Strings">Formatted Output Strings</a>,
Next:<a rel=next accesskey=n href="#Formatted%20Output%20Functions">Formatted Output Functions</a>,
Previous:<a rel=previous accesskey=p href="#Formatted%20Output">Formatted Output</a>,
Up:<a rel=up accesskey=u href="#Formatted%20Output">Formatted Output</a>
<br>

<h3>Format Strings</h3>

<p><code>gmp_printf</code> and friends accept format strings similar to the standard C
<code>printf</code> (see <a href="libc.html#Formatted%20Output">Formatted Output</a>).  A format specification is of the form

<br><pre>% [flags] [width] [.[precision]] [type] conv
</pre>

<p>GMP adds types <code>Z</code>, <code>Q</code> and <code>F</code> for <code>mpz_t</code>, <code>mpq_t</code>
and <code>mpf_t</code> respectively, and <code>N</code> for an <code>mp_limb_t</code> array. 
<code>Z</code>, <code>Q</code> and <code>N</code> behave like integers.  <code>Q</code> will print a
<code>/</code> and a denominator, if needed.  <code>F</code> behaves like a float.  For
example,

<br><pre>mpz_t z;
gmp_printf ("%s is an mpz %Zd\n", "here", z);

mpq_t q;
gmp_printf ("a hex rational: %#40Qx\n", q);

mpf_t f;
int   n;
gmp_printf ("fixed point mpf %.*Ff with %d digits\n", n, f, n);

const mp_limb_t *ptr;
mp_size_t       size;
gmp_printf ("limb array %Nx\n", ptr, size);
</pre>

<p>For <code>N</code> the limbs are expected least significant first, as per the
<code>mpn</code> functions (see <a href="#Low-level%20Functions">Low-level Functions</a>).  A negative size can be
given to print the value as a negative.

<p>All the standard C <code>printf</code> types behave the same as the C library
<code>printf</code>, and can be freely intermixed with the GMP extensions.  In the
current implementation the standard parts of the format string are simply
handed to <code>printf</code> and only the GMP extensions handled directly.

<p>The flags accepted are as follows.  GLIBC style <code>'</code> is only for the
standard C types (not the GMP types), and only if the C library supports it.

<blockquote>
<p><table><tr align="left"><td valign="top"><code>0</code> </td><td valign="top">pad with zeros (rather than spaces)
<br></td></tr><tr align="left"><td valign="top"><code>#</code> </td><td valign="top">show the base with <code>0x</code>, <code>0X</code> or <code>0</code>
<br></td></tr><tr align="left"><td valign="top"><code>+</code> </td><td valign="top">always show a sign
<br></td></tr><tr align="left"><td valign="top">(space)    </td><td valign="top">show a space or a <code>-</code> sign
<br></td></tr><tr align="left"><td valign="top"><code>'</code> </td><td valign="top">group digits, GLIBC style (not GMP types)
<br></td></tr></table>
</blockquote>

<p>The optional width and precision can be given as a number within the format
string, or as a <code>*</code> to take an extra parameter of type <code>int</code>, the
same as the standard <code>printf</code>.

<p>The standard types accepted are as follows.  <code>h</code> and <code>l</code> are
portable, the rest will depend on the compiler (or include files) for the type
and the C library for the output.

<blockquote>
<p><table><tr align="left"><td valign="top"><code>h</code>  </td><td valign="top"><code>short</code>
<br></td></tr><tr align="left"><td valign="top"><code>hh</code> </td><td valign="top"><code>char</code>
<br></td></tr><tr align="left"><td valign="top"><code>j</code>  </td><td valign="top"><code>intmax_t</code> or <code>uintmax_t</code>
<br></td></tr><tr align="left"><td valign="top"><code>l</code>  </td><td valign="top"><code>long</code> or <code>wchar_t</code>
<br></td></tr><tr align="left"><td valign="top"><code>ll</code> </td><td valign="top">same as <code>L</code>
<br></td></tr><tr align="left"><td valign="top"><code>L</code>  </td><td valign="top"><code>long long</code> or <code>long double</code>
<br></td></tr><tr align="left"><td valign="top"><code>q</code>  </td><td valign="top"><code>quad_t</code> or <code>u_quad_t</code>
<br></td></tr><tr align="left"><td valign="top"><code>t</code>  </td><td valign="top"><code>ptrdiff_t</code>
<br></td></tr><tr align="left"><td valign="top"><code>z</code>  </td><td valign="top"><code>size_t</code>
<br></td></tr></table>
</blockquote>

<p>The GMP types are

<blockquote>
<p><table><tr align="left"><td valign="top"><code>F</code>  </td><td valign="top"><code>mpf_t</code>, float conversions
<br></td></tr><tr align="left"><td valign="top"><code>Q</code>  </td><td valign="top"><code>mpq_t</code>, integer conversions
<br></td></tr><tr align="left"><td valign="top"><code>N</code>  </td><td valign="top"><code>mp_limb_t</code> array, integer conversions
<br></td></tr><tr align="left"><td valign="top"><code>Z</code>  </td><td valign="top"><code>mpz_t</code>, integer conversions
<br></td></tr></table>
</blockquote>

<p>The conversions accepted are as follows.  <code>a</code> and <code>A</code> are always
supported for <code>mpf_t</code> but depend on the C library for standard C float
types.  <code>m</code> and <code>p</code> depend on the C library.

<blockquote>
<p><table><tr align="left"><td valign="top"><code>a</code> <code>A</code> </td><td valign="top">hex floats, GLIBC style
<br></td></tr><tr align="left"><td valign="top"><code>c</code>            </td><td valign="top">character
<br></td></tr><tr align="left"><td valign="top"><code>d</code>            </td><td valign="top">decimal integer
<br></td></tr><tr align="left"><td valign="top"><code>e</code> <code>E</code> </td><td valign="top">scientific format float
<br></td></tr><tr align="left"><td valign="top"><code>f</code>            </td><td valign="top">fixed point float
<br></td></tr><tr align="left"><td valign="top"><code>i</code>            </td><td valign="top">same as <code>d</code>
<br></td></tr><tr align="left"><td valign="top"><code>g</code> <code>G</code> </td><td valign="top">fixed or scientific float
<br></td></tr><tr align="left"><td valign="top"><code>m</code>            </td><td valign="top"><code>strerror</code> string, GLIBC style
<br></td></tr><tr align="left"><td valign="top"><code>n</code>            </td><td valign="top">store characters written so far
<br></td></tr><tr align="left"><td valign="top"><code>o</code>            </td><td valign="top">octal integer
<br></td></tr><tr align="left"><td valign="top"><code>p</code>            </td><td valign="top">pointer
<br></td></tr><tr align="left"><td valign="top"><code>s</code>            </td><td valign="top">string
<br></td></tr><tr align="left"><td valign="top"><code>u</code>            </td><td valign="top">unsigned integer
<br></td></tr><tr align="left"><td valign="top"><code>x</code> <code>X</code> </td><td valign="top">hex integer
<br></td></tr></table>
</blockquote>

<p><code>o</code>, <code>x</code> and <code>X</code> are unsigned for the standard C types, but for
types <code>Z</code>, <code>Q</code> and <code>N</code> they are signed.  <code>u</code> is not
meaningful for <code>Z</code>, <code>Q</code> and <code>N</code>.

<p><code>n</code> can be used with any type, even the GMP types.

<p>Other types or conversions that might be accepted by the C library
<code>printf</code> cannot be used through <code>gmp_printf</code>, this includes for
instance extensions registered with GLIBC <code>register_printf_function</code>. 
Also currently there's no support for POSIX <code>$</code> style numbered arguments
(perhaps this will be added in the future).

<p>The precision field has it's usual meaning for integer <code>Z</code> and float
<code>F</code> types, but is currently undefined for <code>Q</code> and should not be used
with that.

<p><code>mpf_t</code> conversions only ever generate as many digits as can be
accurately represented by the operand, the same as <code>mpf_get_str</code> does. 
Zeros will be used if necessary to pad to the requested precision.  This
happens even for an <code>f</code> conversion of an <code>mpf_t</code> which is an
integer, for instance 2^1024 in an <code>mpf_t</code> of 128 bits
precision will only produce about 20 digits, then pad with zeros to the
decimal point.  An empty precision field like <code>%.Fe</code> or <code>%.Ff</code> can
be used to specifically request just the significant digits.

<p>The decimal point character (or string) is taken from the current locale
settings on systems which provide <code>localeconv</code> (see <a href="libc.html#Locales">Locales and Internationalization</a>).  The C
library will normally do the same for standard float output.

<p><hr>
Node:<a name="Formatted%20Output%20Functions">Formatted Output Functions</a>,
Next:<a rel=next accesskey=n href="#C++%20Formatted%20Output">C++ Formatted Output</a>,
Previous:<a rel=previous accesskey=p href="#Formatted%20Output%20Strings">Formatted Output Strings</a>,
Up:<a rel=up accesskey=u href="#Formatted%20Output">Formatted Output</a>
<br>

<h3>Functions</h3>

<p>Each of the following functions is similar to the corresponding C library
function.  The basic <code>printf</code> forms take a variable argument list.  The
<code>vprintf</code> forms take an argument pointer, see <a href="libc.html#Variadic%20Functions">Variadic Functions</a>, or <code>man 3
va_start</code>.

<p>It should be emphasised that if a format string is invalid, or the arguments
don't match what the format specifies, then the behaviour of any of these
functions will be unpredictable.  GCC format string checking is not available,
since it doesn't recognise the GMP extensions.

<p>The file based functions <code>gmp_printf</code> and <code>gmp_fprintf</code> will return
-1 to indicate a write error.  All the functions can return -1
if the C library <code>printf</code> variant in use returns -1, but this
shouldn't normally occur.

<p>
<table width="100%">
<tr>
<td align="left">int <b>gmp_printf</b><i> (const char *<var>fmt</var>, ...)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">int <b>gmp_vprintf</b><i> (const char *<var>fmt</var>, va_list <var>ap</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Print to the standard output <code>stdout</code>.  Return the number of characters
written, or -1 if an error occurred. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>gmp_fprintf</b><i> (FILE *<var>fp</var>, const char *<var>fmt</var>, ...)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">int <b>gmp_vfprintf</b><i> (FILE *<var>fp</var>, const char *<var>fmt</var>, va_list <var>ap</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Print to the stream <var>fp</var>.  Return the number of characters written, or
-1 if an error occurred. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>gmp_sprintf</b><i> (char *<var>buf</var>, const char *<var>fmt</var>, ...)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">int <b>gmp_vsprintf</b><i> (char *<var>buf</var>, const char *<var>fmt</var>, va_list <var>ap</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Form a null-terminated string in <var>buf</var>.  Return the number of characters
written, excluding the terminating null.

<p>No overlap is permitted between the space at <var>buf</var> and the string
<var>fmt</var>.

<p>These functions are not recommended, since there's no protection against
exceeding the space available at <var>buf</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>gmp_snprintf</b><i> (char *<var>buf</var>, size_t <var>size</var>, const char *<var>fmt</var>, ...)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">int <b>gmp_vsnprintf</b><i> (char *<var>buf</var>, size_t <var>size</var>, const char *<var>fmt</var>, va_list <var>ap</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Form a null-terminated string in <var>buf</var>.  No more than <var>size</var> bytes
will be written.  To get the full output, <var>size</var> must be enough for the
string and null-terminator.

<p>The return value is the total number of characters which ought to have been
produced, excluding the terminating null.  If <var>retval</var> &gt;=
<var>size</var> then the actual output has been truncated to the first
<var>size</var>-1 characters, and a null appended.

<p>No overlap is permitted between the region {<var>buf</var>,<var>size</var>} and the
<var>fmt</var> string.

<p>Notice the return value is in ISO C99 <code>snprintf</code> style.  This is so even
if the C library <code>vsnprintf</code> is the older GLIBC 2.0.x style. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>gmp_asprintf</b><i> (char **<var>pp</var>, const char *<var>fmt</var>, ...)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">int <b>gmp_vasprintf</b><i> (char *<var>pp</var>, const char *<var>fmt</var>, va_list <var>ap</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Form a null-terminated string in a block of memory obtained from the current
memory allocation function (see <a href="#Custom%20Allocation">Custom Allocation</a>).  The block will be the
size of the string and null-terminator.  Put the address of the block in
*<var>pp</var>.  Return the number of characters produced, excluding the
null-terminator.

<p>Unlike the C library <code>asprintf</code>, <code>gmp_asprintf</code> doesn't return
-1 if there's no more memory available, it lets the current allocation
function handle that. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>gmp_obstack_printf</b><i> (struct obstack *<var>ob</var>, const char *<var>fmt</var>, ...)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">int <b>gmp_obstack_vprintf</b><i> (struct obstack *<var>ob</var>, const char *<var>fmt</var>, va_list <var>ap</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Append to the current obstack object, in the same style as
<code>obstack_printf</code>.  Return the number of characters written.  A
null-terminator is not written.

<p><var>fmt</var> cannot be within the current obstack object, since the object might
move as it grows.

<p>These functions are available only when the C library provides the obstack
feature, which probably means only on GNU systems, see
<a href="libc.html#Obstacks">Obstacks</a>. 
</td></tr>
</table>

<p><hr>
Node:<a name="C++%20Formatted%20Output">C++ Formatted Output</a>,
Previous:<a rel=previous accesskey=p href="#Formatted%20Output%20Functions">Formatted Output Functions</a>,
Up:<a rel=up accesskey=u href="#Formatted%20Output">Formatted Output</a>
<br>

<h3>C++ Formatted Output</h3>

<p>The following functions are provided in <code>libgmpxx</code>, which is built if C++
support is enabled (see <a href="#Build%20Options">Build Options</a>).  Prototypes are available from
<code>&lt;gmp.h&gt;</code>.

<p>
<table width="100%">
<tr>
<td align="left">ostream&amp; <b>operator&lt;&lt;</b><i> (ostream& <var>stream</var>, mpz_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Print <var>op</var> to <var>stream</var>, using its <code>ios</code> formatting settings. 
<code>ios::width</code> is reset to 0 after output, the same as the standard
<code>ostream operator&lt;&lt;</code> routines do.

<p>In hex or octal, <var>op</var> is printed as a signed number, the same as for
decimal.  This is unlike the standard <code>operator&lt;&lt;</code> routines on <code>int</code>
etc, which instead give twos complement. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">ostream&amp; <b>operator&lt;&lt;</b><i> (ostream& <var>stream</var>, mpq_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Print <var>op</var> to <var>stream</var>, using its <code>ios</code> formatting settings. 
<code>ios::width</code> is reset to 0 after output, the same as the standard
<code>ostream operator&lt;&lt;</code> routines do.

<p>Output will be a fraction like <code>5/9</code>, or if the denominator is 1 then
just a plain integer like <code>123</code>.

<p>In hex or octal, <var>op</var> is printed as a signed value, the same as for
decimal.  If <code>ios::showbase</code> is set then a base indicator is shown on
both the numerator and denominator (if the denominator is required). 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">ostream&amp; <b>operator&lt;&lt;</b><i> (ostream& <var>stream</var>, mpf_t <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Print <var>op</var> to <var>stream</var>, using its <code>ios</code> formatting settings. 
<code>ios::width</code> is reset to 0 after output, the same as the standard
<code>ostream operator&lt;&lt;</code> routines do.  The decimal point follows the current
locale, on systems providing <code>localeconv</code>.

<p>Hex and octal are supported, unlike the standard <code>operator&lt;&lt;</code> on
<code>double</code>.  The mantissa will be in hex or octal, the exponent will be in
decimal.  For hex the exponent delimiter is an <code>@</code>.  This is as per
<code>mpf_out_str</code>.

<p><code>ios::showbase</code> is supported, and will put a base on the mantissa, for
example hex <code>0x1.8</code> or <code>0x0.8</code>, or octal <code>01.4</code> or <code>00.4</code>. 
This last form is slightly strange, but at least differentiates itself from
decimal. 
</td></tr>
</table>

<p>These operators mean that GMP types can be printed in the usual C++ way, for
example,

<br><pre>mpz_t  z;
int    n;
...
cout &lt;&lt; "iteration " &lt;&lt; n &lt;&lt; " value " &lt;&lt; z &lt;&lt; "\n";
</pre>

<p>But note that <code>ostream</code> output (and <code>istream</code> input, see <a href="#C++%20Formatted%20Input">C++ Formatted Input</a>) is the only overloading available and using for instance
<code>+</code> with an <code>mpz_t</code> will have unpredictable results.

<p><hr>
Node:<a name="Formatted%20Input">Formatted Input</a>,
Next:<a rel=next accesskey=n href="#C++%20Class%20Interface">C++ Class Interface</a>,
Previous:<a rel=previous accesskey=p href="#Formatted%20Output">Formatted Output</a>,
Up:<a rel=up accesskey=u href="#Top">Top</a>
<br>

<h2>Formatted Input</h2>

<ul>
<li><a accesskey=1 href="#Formatted%20Input%20Strings">Formatted Input Strings</a>: 
<li><a accesskey=2 href="#Formatted%20Input%20Functions">Formatted Input Functions</a>: 
<li><a accesskey=3 href="#C++%20Formatted%20Input">C++ Formatted Input</a>: 
</ul>

<p><hr>
Node:<a name="Formatted%20Input%20Strings">Formatted Input Strings</a>,
Next:<a rel=next accesskey=n href="#Formatted%20Input%20Functions">Formatted Input Functions</a>,
Previous:<a rel=previous accesskey=p href="#Formatted%20Input">Formatted Input</a>,
Up:<a rel=up accesskey=u href="#Formatted%20Input">Formatted Input</a>
<br>

<h3>Formatted Input Strings</h3>

<p><code>gmp_scanf</code> and friends accept format strings similar to the standard C
<code>scanf</code> (see <a href="libc.html#Formatted%20Input">Formatted Input</a>).  A format specification is of the form

<br><pre>% [flags] [width] [type] conv
</pre>

<p>GMP adds types <code>Z</code>, <code>Q</code> and <code>F</code> for <code>mpz_t</code>, <code>mpq_t</code>
and <code>mpf_t</code> respectively.  <code>Z</code> and <code>Q</code> behave like integers. 
<code>Q</code> will read a <code>/</code> and a denominator, if present.  <code>F</code> behaves
like a float.

<p>GMP variables don't require an <code>&amp;</code> when passed to <code>gmp_scanf</code>, since
they're already "call-by-reference".  For example,

<br><pre>/* to read say "a(5) = 1234" */
int   n;
mpz_t z;
gmp_scanf ("a(%d) = %Zd\n", &amp;n, z);

mpq_t q1, q2;
gmp_sscanf ("0377 + 0x10/0x11", "%Qi + %Qi", q1, q2);

/* to read say "topleft (1.55,-2.66)" */
mpf_t x, y;
char  buf[32];
gmp_scanf ("%31s (%Ff,%Ff)", buf, x, y);
</pre>

<p>All the standard C <code>scanf</code> types behave the same as in the C library
<code>scanf</code>, and can be freely intermixed with the GMP extensions.  In the
current implementation the standard parts of the format string are simply
handed to <code>scanf</code> and only the GMP extensions handled directly.

<p>The flags accepted are as follows.  <code>a</code> and <code>'</code> will depend on
support from the C library, and <code>'</code> cannot be used with GMP types.

<blockquote>
<p><table><tr align="left"><td valign="top"><code>*</code> </td><td valign="top">read but don't store
<br></td></tr><tr align="left"><td valign="top"><code>a</code> </td><td valign="top">allocate a buffer (string conversions)
<br></td></tr><tr align="left"><td valign="top"><code>'</code> </td><td valign="top">group digits, GLIBC style (not GMP types)
<br></td></tr></table>
</blockquote>

<p>The standard types accepted are as follows.  <code>h</code> and <code>l</code> are
portable, the rest will depend on the compiler (or include files) for the type
and the C library for the input.

<blockquote>
<p><table><tr align="left"><td valign="top"><code>h</code>  </td><td valign="top"><code>short</code>
<br></td></tr><tr align="left"><td valign="top"><code>hh</code> </td><td valign="top"><code>char</code>
<br></td></tr><tr align="left"><td valign="top"><code>j</code>  </td><td valign="top"><code>intmax_t</code> or <code>uintmax_t</code>
<br></td></tr><tr align="left"><td valign="top"><code>l</code>  </td><td valign="top"><code>long</code> or <code>wchar_t</code>
<br></td></tr><tr align="left"><td valign="top"><code>ll</code> </td><td valign="top">same as <code>L</code>
<br></td></tr><tr align="left"><td valign="top"><code>L</code>  </td><td valign="top"><code>long long</code> or <code>long double</code>
<br></td></tr><tr align="left"><td valign="top"><code>q</code>  </td><td valign="top"><code>quad_t</code> or <code>u_quad_t</code>
<br></td></tr><tr align="left"><td valign="top"><code>t</code>  </td><td valign="top"><code>ptrdiff_t</code>
<br></td></tr><tr align="left"><td valign="top"><code>z</code>  </td><td valign="top"><code>size_t</code>
<br></td></tr></table>
</blockquote>

<p>The GMP types are

<blockquote>
<p><table><tr align="left"><td valign="top"><code>F</code>  </td><td valign="top"><code>mpf_t</code>, float conversions
<br></td></tr><tr align="left"><td valign="top"><code>Q</code>  </td><td valign="top"><code>mpq_t</code>, integer conversions
<br></td></tr><tr align="left"><td valign="top"><code>Z</code>  </td><td valign="top"><code>mpz_t</code>, integer conversions
<br></td></tr></table>
</blockquote>

<p>The conversions accepted are as follows.  <code>p</code> and <code>[</code> will depend on
support from the C library, the rest are standard.

<blockquote>
<p><table><tr align="left"><td valign="top"><code>c</code>            </td><td valign="top">character or characters
<br></td></tr><tr align="left"><td valign="top"><code>d</code>            </td><td valign="top">decimal integer
<br></td></tr><tr align="left"><td valign="top"><code>e</code> <code>E</code> <code>f</code> <code>g</code> <code>G</code>
                            </td><td valign="top">float
<br></td></tr><tr align="left"><td valign="top"><code>i</code>            </td><td valign="top">integer with base indicator
<br></td></tr><tr align="left"><td valign="top"><code>n</code>            </td><td valign="top">characters written so far
<br></td></tr><tr align="left"><td valign="top"><code>o</code>            </td><td valign="top">octal integer
<br></td></tr><tr align="left"><td valign="top"><code>p</code>            </td><td valign="top">pointer
<br></td></tr><tr align="left"><td valign="top"><code>s</code>            </td><td valign="top">string of non-whitespace characters
<br></td></tr><tr align="left"><td valign="top"><code>u</code>            </td><td valign="top">decimal integer
<br></td></tr><tr align="left"><td valign="top"><code>x</code> <code>X</code> </td><td valign="top">hex integer
<br></td></tr><tr align="left"><td valign="top"><code>[</code>            </td><td valign="top">string of characters in a set
<br></td></tr></table>
</blockquote>

<p><code>e</code>, <code>E</code>, <code>f</code>, <code>g</code> and <code>G</code> are identical, they all
read either fixed point or scientific format, and either <code>e</code> or <code>E</code>
for the exponent in scientific format.

<p><code>x</code> and <code>X</code> are identical, both accept both upper and lower case
hexadecimal.

<p><code>o</code>, <code>u</code>, <code>x</code> and <code>X</code> all read positive or negative
values.  For the standard C types these are described as "unsigned"
conversions, but that merely affects certain overflow handling, negatives are
still allowed (see <code>strtoul</code>, <a href="libc.html#Parsing%20of%20Integers">Parsing of Integers</a>).  For GMP types there are no overflows, and
<code>d</code> and <code>u</code> are identical.

<p><code>Q</code> type reads the numerator and (optional) denominator as given.  If the
value might not be in canonical form then <code>mpq_canonicalize</code> must be
called before using it in any calculations (see <a href="#Rational%20Number%20Functions">Rational Number Functions</a>).

<p><code>Qi</code> will read a base specification separately for the numerator and
denominator.  For example <code>0x10/11</code> would be 16/11, whereas
<code>0x10/0x11</code> would be 16/17.

<p><code>n</code> can be used with any of the types above, even the GMP types. 
<code>*</code> to suppress assignment is allowed, though the field would then do
nothing at all.

<p>Other conversions or types that might be accepted by the C library
<code>scanf</code> cannot be used through <code>gmp_scanf</code>.

<p>Whitespace is read and discarded before a field, except for <code>c</code> and
<code>[</code> conversions.

<p>For float conversions, the decimal point character (or string) expected is
taken from the current locale settings on systems which provide
<code>localeconv</code> (see <a href="libc.html#Locales">Locales and Internationalization</a>).  The C library will normally do the same for
standard float input.

<p><hr>
Node:<a name="Formatted%20Input%20Functions">Formatted Input Functions</a>,
Next:<a rel=next accesskey=n href="#C++%20Formatted%20Input">C++ Formatted Input</a>,
Previous:<a rel=previous accesskey=p href="#Formatted%20Input%20Strings">Formatted Input Strings</a>,
Up:<a rel=up accesskey=u href="#Formatted%20Input">Formatted Input</a>
<br>

<h3>Formatted Input Functions</h3>

<p>Each of the following functions is similar to the corresponding C library
function.  The plain <code>scanf</code> forms take a variable argument list.  The
<code>vscanf</code> forms take an argument pointer, see <a href="libc.html#Variadic%20Functions">Variadic Functions</a>, or <code>man 3
va_start</code>.

<p>It should be emphasised that if a format string is invalid, or the arguments
don't match what the format specifies, then the behaviour of any of these
functions will be unpredictable.  GCC format string checking is not available,
since it doesn't recognise the GMP extensions.

<p>No overlap is permitted between the <var>fmt</var> string and any of the results
produced.

<p>
<table width="100%">
<tr>
<td align="left">int <b>gmp_scanf</b><i> (const char *<var>fmt</var>, ...)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">int <b>gmp_vscanf</b><i> (const char *<var>fmt</var>, va_list <var>ap</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Read from the standard input <code>stdin</code>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>gmp_fscanf</b><i> (FILE *<var>fp</var>, const char *<var>fmt</var>, ...)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">int <b>gmp_vfscanf</b><i> (FILE *<var>fp</var>, const char *<var>fmt</var>, va_list <var>ap</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Read from the stream <var>fp</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>gmp_sscanf</b><i> (const char *<var>s</var>, const char *<var>fmt</var>, ...)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">int <b>gmp_vsscanf</b><i> (const char *<var>s</var>, const char *<var>fmt</var>, va_list <var>ap</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Read from a null-terminated string <var>s</var>. 
</td></tr>
</table>

<p>The return value from each of these functions is the same as the standard C99
<code>scanf</code>, namely the number of fields successfully parsed and stored. 
<code>%n</code> fields and fields read but suppressed by <code>*</code> don't count
towards the return value.

<p>If end of file or file error, or end of string, is reached when a match is
required, and when no previous non-suppressed fields have matched, then the
return value is EOF instead of 0.  A match is required for a literal character
in the format string or a field other than <code>%n</code>.  Whitespace in the
format string is only an optional match and won't induce an EOF in this
fashion.  Leading whitespace read and discarded for a field doesn't count as a
match.

<p><hr>
Node:<a name="C++%20Formatted%20Input">C++ Formatted Input</a>,
Previous:<a rel=previous accesskey=p href="#Formatted%20Input%20Functions">Formatted Input Functions</a>,
Up:<a rel=up accesskey=u href="#Formatted%20Input">Formatted Input</a>
<br>

<h3>C++ Formatted Input</h3>

<p>The following functions are provided in <code>libgmpxx</code>, which is built only
if C++ support is enabled (see <a href="#Build%20Options">Build Options</a>).  Prototypes are available
from <code>&lt;gmp.h&gt;</code>.

<p>
<table width="100%">
<tr>
<td align="left">istream&amp; <b>operator&gt;&gt;</b><i> (istream& <var>stream</var>, mpz_t <var>rop</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Read <var>rop</var> from <var>stream</var>, using its <code>ios</code> formatting settings. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">istream&amp; <b>operator&gt;&gt;</b><i> (istream& <var>stream</var>, mpq_t <var>rop</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Read <var>rop</var> from <var>stream</var>, using its <code>ios</code> formatting settings.

<p>An integer like <code>123</code> will be read, or a fraction like <code>5/9</code>.  If
the fraction is not in canonical form then <code>mpq_canonicalize</code> must be
called (see <a href="#Rational%20Number%20Functions">Rational Number Functions</a>). 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">istream&amp; <b>operator&gt;&gt;</b><i> (istream& <var>stream</var>, mpf_t <var>rop</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Read <var>rop</var> from <var>stream</var>, using its <code>ios</code> formatting settings.

<p>Hex or octal floats are not supported, but might be in the future. 
</td></tr>
</table>

<p>These operators mean that GMP types can be read in the usual C++ way, for
example,

<br><pre>mpz_t  z;
...
cin &gt;&gt; z;
</pre>

<p>But note that <code>istream</code> input (and <code>ostream</code> output, see <a href="#C++%20Formatted%20Output">C++ Formatted Output</a>) is the only overloading available and using for instance
<code>+</code> with an <code>mpz_t</code> will have unpredictable results.

<p><hr>
Node:<a name="C++%20Class%20Interface">C++ Class Interface</a>,
Next:<a rel=next accesskey=n href="#BSD%20Compatible%20Functions">BSD Compatible Functions</a>,
Previous:<a rel=previous accesskey=p href="#Formatted%20Input">Formatted Input</a>,
Up:<a rel=up accesskey=u href="#Top">Top</a>
<br>

<h2>C++ Class Interface</h2>

<p>This chapter describes the C++ class based interface to GMP.

<p>All GMP C language types and functions can be used in C++ programs, since
<code>gmp.h</code> has <code>extern "C"</code> qualifiers, but the class interface offers
overloaded functions and operators which may be more convenient.

<p>Due to the implementation of this interface, a reasonably recent C++ compiler
is required, one supporting namespaces, partial specialization of templates
and member templates.  For GCC this means version 2.91 or later.

<p><strong>Everything described in this chapter is to be considered preliminary
and might be subject to incompatible changes if some unforeseen difficulty
reveals itself.</strong>

<ul>
<li><a accesskey=1 href="#C++%20Interface%20General">C++ Interface General</a>: 
<li><a accesskey=2 href="#C++%20Interface%20Integers">C++ Interface Integers</a>: 
<li><a accesskey=3 href="#C++%20Interface%20Rationals">C++ Interface Rationals</a>: 
<li><a accesskey=4 href="#C++%20Interface%20Floats">C++ Interface Floats</a>: 
<li><a accesskey=5 href="#C++%20Interface%20MPFR">C++ Interface MPFR</a>: 
<li><a accesskey=6 href="#C++%20Interface%20Random%20Numbers">C++ Interface Random Numbers</a>: 
<li><a accesskey=7 href="#C++%20Interface%20Limitations">C++ Interface Limitations</a>: 
</ul>

<p><hr>
Node:<a name="C++%20Interface%20General">C++ Interface General</a>,
Next:<a rel=next accesskey=n href="#C++%20Interface%20Integers">C++ Interface Integers</a>,
Previous:<a rel=previous accesskey=p href="#C++%20Class%20Interface">C++ Class Interface</a>,
Up:<a rel=up accesskey=u href="#C++%20Class%20Interface">C++ Class Interface</a>
<br>

<h3>C++ Interface General</h3>

<p>All the C++ classes and functions are available with

<br><pre>#include &lt;gmpxx.h&gt;
</pre>

<p>The classes defined are

<p>
<table width="100%">
<tr>
<td align="left"><b>mpz_class</b><i>
</i></td>
<td align="right">Class</td>
</tr>

<tr>
<td align="left"><b>mpq_class</b><i>
</i></td>
<td align="right">Class</td>
</tr>

<tr>
<td align="left"><b>mpf_class</b><i>
</i></td>
<td align="right">Class</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
</td></tr>
</table>

<p>The standard operators and various standard functions are overloaded to allow
arithmetic with these classes.  For example,

<br><pre>int
main (void)
{
  mpz_class a, b, c;

  a = 1234;
  b = "-5678";
  c = a+b;
  cout &lt;&lt; "sum is " &lt;&lt; c &lt;&lt; "\n";
  cout &lt;&lt; "absolute value is " &lt;&lt; abs(c) &lt;&lt; "\n";

  return 0;
}
</pre>

<p>An important feature of the implementation is that an expression like
<code>a=b+c</code> results in a single call to the corresponding <code>mpz_add</code>,
without using a temporary for the <code>b+c</code> part.  Expressions which by their
nature imply intermediate values, like <code>a=b*c+d*e</code>, still use temporaries
though.

<p>The classes can be freely intermixed in expressions, as can the classes and
the standard types <code>long</code>, <code>unsigned long</code> and <code>double</code>. 
Smaller types like <code>int</code> or <code>float</code> can also be intermixed, since
C++ will promote them.

<p>Note that <code>bool</code> is not accepted directly, but must be explicitly cast to
an <code>int</code> first.  This is because C++ will automatically convert any
pointer to a <code>bool</code>, so if GMP accepted <code>bool</code> it would make all
sorts of invalid class and pointer combinations compile but almost certainly
not do anything sensible.

<p>Conversions back from the classes to standard C++ types aren't done
automatically, instead member functions like <code>get_si</code> are provided (see
the following sections for details).

<p>Also there are no automatic conversions from the classes to the corresponding
GMP C types, instead a reference to the underlying C object can be obtained
with the following functions,

<p>
<table width="100%">
<tr>
<td align="left">mpz_t <b>mpz_class::get_mpz_t</b><i> ()
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">mpq_t <b>mpq_class::get_mpq_t</b><i> ()
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">mpf_t <b>mpf_class::get_mpf_t</b><i> ()
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
</td></tr>
</table>

<p>These can be used to call a C function which doesn't have a C++ class
interface.  For example to set <code>a</code> to the GCD of <code>b</code> and <code>c</code>,

<br><pre>mpz_class a, b, c;
...
mpz_gcd (a.get_mpz_t(), b.get_mpz_t(), c.get_mpz_t());
</pre>

<p>In the other direction, a class can be initialized from the corresponding GMP
C type, or assigned to if an explicit constructor is used.  In both cases this
makes a copy of the value, it doesn't create any sort of association.  For
example,

<br><pre>mpz_t z;
// ... init and calculate z ...
mpz_class x(z);
mpz_class y;
y = mpz_class (z);
</pre>

<p>There are no namespace setups in <code>gmpxx.h</code>, all types and functions are
simply put into the global namespace.  This is what <code>gmp.h</code> has done in
the past, and continues to do for compatibility.  The extras provided by
<code>gmpxx.h</code> follow GMP naming conventions and are unlikely to clash with
anything.

<p><hr>
Node:<a name="C++%20Interface%20Integers">C++ Interface Integers</a>,
Next:<a rel=next accesskey=n href="#C++%20Interface%20Rationals">C++ Interface Rationals</a>,
Previous:<a rel=previous accesskey=p href="#C++%20Interface%20General">C++ Interface General</a>,
Up:<a rel=up accesskey=u href="#C++%20Class%20Interface">C++ Class Interface</a>
<br>

<h3>C++ Interface Integers</h3>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpz_class::mpz_class</b><i> (type <var>n</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Construct an <code>mpz_class</code>.  All the standard C++ types may be used, except
<code>long long</code> and <code>long double</code>, and all the GMP C++ classes can be
used.  Any necessary conversion follows the corresponding C function, for
example <code>double</code> follows <code>mpz_set_d</code> (see <a href="#Assigning%20Integers">Assigning Integers</a>). 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpz_class::mpz_class</b><i> (mpz_t <var>z</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Construct an <code>mpz_class</code> from an <code>mpz_t</code>.  The value in <var>z</var> is
copied into the new <code>mpz_class</code>, there won't be any permanent association
between it and <var>z</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpz_class::mpz_class</b><i> (const char *<var>s</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpz_class::mpz_class</b><i> (const char *<var>s</var>, int base)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpz_class::mpz_class</b><i> (const string& <var>s</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpz_class::mpz_class</b><i> (const string& <var>s</var>, int base)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Construct an <code>mpz_class</code> converted from a string using
<code>mpz_set_str</code>, (see <a href="#Assigning%20Integers">Assigning Integers</a>).  If the <var>base</var> is not
given then 0 is used. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">mpz_class <b>operator/</b><i> (mpz_class <var>a</var>, mpz_class <var>d</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">mpz_class <b>operator%</b><i> (mpz_class <var>a</var>, mpz_class <var>d</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Divisions involving <code>mpz_class</code> round towards zero, as per the
<code>mpz_tdiv_q</code> and <code>mpz_tdiv_r</code> functions (see <a href="#Integer%20Division">Integer Division</a>). 
This corresponds to the rounding used for plain <code>int</code> calculations on
most machines.

<p>The <code>mpz_fdiv...</code> or <code>mpz_cdiv...</code> functions can always be called
directly if desired.  For example,

<br><pre>mpz_class q, a, d;
...
mpz_fdiv_q (q.get_mpz_t(), a.get_mpz_t(), d.get_mpz_t());
</pre>
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">mpz_class <b>abs</b><i> (mpz_class <var>op1</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">int <b>cmp</b><i> (mpz_class <var>op1</var>, type <var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">int <b>cmp</b><i> (type <var>op1</var>, mpz_class <var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">double <b>mpz_class::get_d</b><i> (void)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">long <b>mpz_class::get_si</b><i> (void)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">unsigned long <b>mpz_class::get_ui</b><i> (void)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<tr>
<td align="left">bool <b>mpz_class::fits_sint_p</b><i> (void)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">bool <b>mpz_class::fits_slong_p</b><i> (void)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">bool <b>mpz_class::fits_sshort_p</b><i> (void)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<tr>
<td align="left">bool <b>mpz_class::fits_uint_p</b><i> (void)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">bool <b>mpz_class::fits_ulong_p</b><i> (void)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">bool <b>mpz_class::fits_ushort_p</b><i> (void)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<tr>
<td align="left">int <b>sgn</b><i> (mpz_class <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">mpz_class <b>sqrt</b><i> (mpz_class <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
These functions provide a C++ class interface to the corresponding GMP C
routines.

<p><code>cmp</code> can be used with any of the classes or the standard C++ types,
except <code>long long</code> and <code>long double</code>. 
</td></tr>
</table>

<br><p>
<p>Overloaded operators for combinations of <code>mpz_class</code> and <code>double</code>
are provided for completeness, but it should be noted that if the given
<code>double</code> is not an integer then the way any rounding is done is currently
unspecified.  The rounding might take place at the start, in the middle, or at
the end of the operation, and it might change in the future.

<p>Conversions between <code>mpz_class</code> and <code>double</code>, however, are defined
to follow the corresponding C functions <code>mpz_get_d</code> and <code>mpz_set_d</code>. 
And comparisons are always made exactly, as per <code>mpz_cmp_d</code>.

<p><hr>
Node:<a name="C++%20Interface%20Rationals">C++ Interface Rationals</a>,
Next:<a rel=next accesskey=n href="#C++%20Interface%20Floats">C++ Interface Floats</a>,
Previous:<a rel=previous accesskey=p href="#C++%20Interface%20Integers">C++ Interface Integers</a>,
Up:<a rel=up accesskey=u href="#C++%20Class%20Interface">C++ Class Interface</a>
<br>

<h3>C++ Interface Rationals</h3>

<p>In all the following constructors, if a fraction is given then it should be in
canonical form, or if not then <code>mpq_class::canonicalize</code> called.

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpq_class::mpq_class</b><i> (type <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpq_class::mpq_class</b><i> (integer <var>num</var>, integer <var>den</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Construct an <code>mpq_class</code>.  The initial value can be a single value of any
type, or a pair of integers (<code>mpz_class</code> or standard C++ integer types)
representing a fraction, except that <code>long long</code> and <code>long double</code>
are not supported.  For example,

<br><pre>mpq_class q (99);
mpq_class q (1.75);
mpq_class q (1, 3);
</pre>
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpq_class::mpq_class</b><i> (mpq_t <var>q</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Construct an <code>mpq_class</code> from an <code>mpq_t</code>.  The value in <var>q</var> is
copied into the new <code>mpq_class</code>, there won't be any permanent association
between it and <var>q</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpq_class::mpq_class</b><i> (const char *<var>s</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpq_class::mpq_class</b><i> (const char *<var>s</var>, int base)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpq_class::mpq_class</b><i> (const string& <var>s</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpq_class::mpq_class</b><i> (const string& <var>s</var>, int base)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Construct an <code>mpq_class</code> converted from a string using
<code>mpq_set_str</code>, (see <a href="#Initializing%20Rationals">Initializing Rationals</a>).  If the <var>base</var> is
not given then 0 is used. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mpq_class::canonicalize</b><i> ()
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Put an <code>mpq_class</code> into canonical form, as per <a href="#Rational%20Number%20Functions">Rational Number Functions</a>.  All arithmetic operators require their operands in canonical
form, and will return results in canonical form. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">mpq_class <b>abs</b><i> (mpq_class <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">int <b>cmp</b><i> (mpq_class <var>op1</var>, type <var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">int <b>cmp</b><i> (type <var>op1</var>, mpq_class <var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<tr>
<td align="left">double <b>mpq_class::get_d</b><i> (void)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">int <b>sgn</b><i> (mpq_class <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
These functions provide a C++ class interface to the corresponding GMP C
routines.

<p><code>cmp</code> can be used with any of the classes or the standard C++ types,
except <code>long long</code> and <code>long double</code>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">mpz_class&amp; <b>mpq_class::get_num</b><i> ()
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">mpz_class&amp; <b>mpq_class::get_den</b><i> ()
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Get a reference to an <code>mpz_class</code> which is the numerator or denominator
of an <code>mpq_class</code>.  This can be used both for read and write access.  If
the object returned is modified, it modifies the original <code>mpq_class</code>.

<p>If direct manipulation might produce a non-canonical value, then
<code>mpq_class::canonicalize</code> must be called before further operations. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">mpz_t <b>mpq_class::get_num_mpz_t</b><i> ()
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">mpz_t <b>mpq_class::get_den_mpz_t</b><i> ()
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Get a reference to the underlying <code>mpz_t</code> numerator or denominator of an
<code>mpq_class</code>.  This can be passed to C functions expecting an
<code>mpz_t</code>.  Any modifications made to the <code>mpz_t</code> will modify the
original <code>mpq_class</code>.

<p>If direct manipulation might produce a non-canonical value, then
<code>mpq_class::canonicalize</code> must be called before further operations. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">istream&amp; <b>operator&gt;&gt;</b><i> (istream& <var>stream</var>, mpq_class& <var>rop</var>);
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Read <var>rop</var> from <var>stream</var>, using its <code>ios</code> formatting settings,
the same as <code>mpq_t operator&gt;&gt;</code> (see <a href="#C++%20Formatted%20Input">C++ Formatted Input</a>).

<p>If the <var>rop</var> read might not be in canonical form then
<code>mpq_class::canonicalize</code> must be called. 
</td></tr>
</table>

<p><hr>
Node:<a name="C++%20Interface%20Floats">C++ Interface Floats</a>,
Next:<a rel=next accesskey=n href="#C++%20Interface%20MPFR">C++ Interface MPFR</a>,
Previous:<a rel=previous accesskey=p href="#C++%20Interface%20Rationals">C++ Interface Rationals</a>,
Up:<a rel=up accesskey=u href="#C++%20Class%20Interface">C++ Class Interface</a>
<br>

<h3>C++ Interface Floats</h3>

<p>When an expression requires the use of temporary intermediate <code>mpf_class</code>
values, like <code>f=g*h+x*y</code>, those temporaries will have the same precision
as the destination <code>f</code>.  Explicit constructors can be used if this
doesn't suit.

<p>
<table width="100%">
<tr>
<td align="left"> <b>mpf_class::mpf_class</b><i> (type <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left"> <b>mpf_class::mpf_class</b><i> (type <var>op</var>, unsigned long <var>prec</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Construct an <code>mpf_class</code>.  Any standard C++ type can be used, except
<code>long long</code> and <code>long double</code>, and any of the GMP C++ classes can be
used.

<p>If <var>prec</var> is given, the initial precision is that value, in bits.  If
<var>prec</var> is not given, then the initial precision is determined by the type
of <var>op</var> given.  An <code>mpz_class</code>, <code>mpq_class</code>, string, or C++
builtin type will give the default <code>mpf</code> precision (see <a href="#Initializing%20Floats">Initializing Floats</a>).  An <code>mpf_class</code> or expression will give the precision of that
value.  The precision of a binary expression is the higher of the two
operands.

<br><pre>mpf_class f(1.5);        // default precision
mpf_class f(1.5, 500);   // 500 bits (at least)
mpf_class f(x);          // precision of x
mpf_class f(abs(x));     // precision of x
mpf_class f(-g, 1000);   // 1000 bits (at least)
mpf_class f(x+y);        // greater of precisions of x and y
</pre>
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">mpf_class <b>abs</b><i> (mpf_class <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">mpf_class <b>ceil</b><i> (mpf_class <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">int <b>cmp</b><i> (mpf_class <var>op1</var>, type <var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">int <b>cmp</b><i> (type <var>op1</var>, mpf_class <var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<tr>
<td align="left">mpf_class <b>floor</b><i> (mpf_class <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">mpf_class <b>hypot</b><i> (mpf_class <var>op1</var>, mpf_class <var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">double <b>mpf_class::get_d</b><i> (void)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">long <b>mpf_class::get_si</b><i> (void)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">unsigned long <b>mpf_class::get_ui</b><i> (void)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<tr>
<td align="left">bool <b>mpf_class::fits_sint_p</b><i> (void)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">bool <b>mpf_class::fits_slong_p</b><i> (void)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">bool <b>mpf_class::fits_sshort_p</b><i> (void)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<tr>
<td align="left">bool <b>mpf_class::fits_uint_p</b><i> (void)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">bool <b>mpf_class::fits_ulong_p</b><i> (void)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">bool <b>mpf_class::fits_ushort_p</b><i> (void)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>

<tr>
<td align="left">int <b>sgn</b><i> (mpf_class <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">mpf_class <b>sqrt</b><i> (mpf_class <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">mpf_class <b>trunc</b><i> (mpf_class <var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
These functions provide a C++ class interface to the corresponding GMP C
routines.

<p><code>cmp</code> can be used with any of the classes or the standard C++ types,
except <code>long long</code> and <code>long double</code>.

<p>The accuracy provided by <code>hypot</code> is not currently guaranteed. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">unsigned long int <b>mpf_class::get_prec</b><i> ()
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpf_class::set_prec</b><i> (unsigned long <var>prec</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>mpf_class::set_prec_raw</b><i> (unsigned long <var>prec</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Get or set the current precision of an <code>mpf_class</code>.

<p>The restrictions described for <code>mpf_set_prec_raw</code> (see <a href="#Initializing%20Floats">Initializing Floats</a>) apply to <code>mpf_class::set_prec_raw</code>.  Note in particular that the
<code>mpf_class</code> must be restored to it's allocated precision before being
destroyed.  This must be done by application code, there's no automatic
mechanism for it. 
</td></tr>
</table>

<p><hr>
Node:<a name="C++%20Interface%20MPFR">C++ Interface MPFR</a>,
Next:<a rel=next accesskey=n href="#C++%20Interface%20Random%20Numbers">C++ Interface Random Numbers</a>,
Previous:<a rel=previous accesskey=p href="#C++%20Interface%20Floats">C++ Interface Floats</a>,
Up:<a rel=up accesskey=u href="#C++%20Class%20Interface">C++ Class Interface</a>
<br>

<h3>C++ Interface MPFR</h3>

<p>The C++ class interface to MPFR is provided if MPFR is enabled (see <a href="#Build%20Options">Build Options</a>).  This interface must be regarded as preliminary and possibly
subject to incompatible changes in the future, since MPFR itself is
preliminary.  All definitions can be obtained with

<br><pre>#include &lt;mpfrxx.h&gt;
</pre>

<p>This defines

<p>
<table width="100%">
<tr>
<td align="left"><b>mpfr_class</b><i>
</i></td>
<td align="right">Class</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
</td></tr>
</table>

<p>which behaves similarly to <code>mpf_class</code> (see <a href="#C++%20Interface%20Floats">C++ Interface Floats</a>).

<p><hr>
Node:<a name="C++%20Interface%20Random%20Numbers">C++ Interface Random Numbers</a>,
Next:<a rel=next accesskey=n href="#C++%20Interface%20Limitations">C++ Interface Limitations</a>,
Previous:<a rel=previous accesskey=p href="#C++%20Interface%20MPFR">C++ Interface MPFR</a>,
Up:<a rel=up accesskey=u href="#C++%20Class%20Interface">C++ Class Interface</a>
<br>

<h3>C++ Interface Random Numbers</h3>

<p>
<table width="100%">
<tr>
<td align="left"><b>gmp_randclass</b><i>
</i></td>
<td align="right">Class</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
The C++ class interface to the GMP random number functions uses
<code>gmp_randclass</code> to hold an algorithm selection and current state, as per
<code>gmp_randstate_t</code>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left"> <b>gmp_randclass::gmp_randclass</b><i> (void (*<var>randinit</var>) (gmp_randstate_t, ...), ...)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Construct a <code>gmp_randclass</code>, using a call to the given <var>randinit</var>
function (see <a href="#Random%20State%20Initialization">Random State Initialization</a>).  The arguments expected are
the same as <var>randinit</var>, but with <code>mpz_class</code> instead of <code>mpz_t</code>. 
For example,

<br><pre>gmp_randclass r1 (gmp_randinit_default);
gmp_randclass r2 (gmp_randinit_lc_2exp_size, 32);
gmp_randclass r3 (gmp_randinit_lc_2exp, a, c, m2exp);
</pre>

<p><code>gmp_randinit_lc_2exp_size</code> can fail if the size requested is too big,
the behaviour of <code>gmp_randclass::gmp_randclass</code> is undefined in this case
(perhaps this will change in the future). 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left"> <b>gmp_randclass::gmp_randclass</b><i> (gmp_randalg_t <var>alg</var>, ...)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Construct a <code>gmp_randclass</code> using the same parameters as
<code>gmp_randinit</code> (see <a href="#Random%20State%20Initialization">Random State Initialization</a>).  This function is
obsolete and the above <var>randinit</var> style should be preferred. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>gmp_randclass::seed</b><i> (unsigned long int <var>s</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>gmp_randclass::seed</b><i> (mpz_class <var>s</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Seed a random number generator.  See see <a href="#Random%20Number%20Functions">Random Number Functions</a>, for how
to choose a good seed. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">mpz_class <b>gmp_randclass::get_z_bits</b><i> (unsigned long <var>bits</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">mpz_class <b>gmp_randclass::get_z_bits</b><i> (mpz_class <var>bits</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Generate a random integer with a specified number of bits. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">mpz_class <b>gmp_randclass::get_z_range</b><i> (mpz_class <var>n</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Generate a random integer in the range 0 to <var>n</var>-1 inclusive. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">mpf_class <b>gmp_randclass::get_f</b><i> ()
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">mpf_class <b>gmp_randclass::get_f</b><i> (unsigned long <var>prec</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Generate a random float <var>f</var> in the range 0 &lt;= <var>f</var> &lt; 1.  <var>f</var>
will be to <var>prec</var> bits precision, or if <var>prec</var> is not given then to
the precision of the destination.  For example,

<br><pre>gmp_randclass  r;
...
mpf_class  f (0, 512);   // 512 bits precision
f = r.get_f();           // random number, 512 bits
</pre>
</td></tr>
</table>

<p><hr>
Node:<a name="C++%20Interface%20Limitations">C++ Interface Limitations</a>,
Previous:<a rel=previous accesskey=p href="#C++%20Interface%20Random%20Numbers">C++ Interface Random Numbers</a>,
Up:<a rel=up accesskey=u href="#C++%20Class%20Interface">C++ Class Interface</a>
<br>

<h3>C++ Interface Limitations</h3>

<dl>
<dt><code>mpq_class</code> and Templated Reading
<dd>A generic piece of template code probably won't know that <code>mpq_class</code>
requires a <code>canonicalize</code> call if inputs read with <code>operator&gt;&gt;</code>
might be non-canonical.  This can lead to incorrect results.

<p><code>operator&gt;&gt;</code> behaves as it does for reasons of efficiency.  A
canonicalize can be quite time consuming on large operands, and is best
avoided if it's not necessary.

<p>But this potential difficulty reduces the usefulness of <code>mpq_class</code>. 
Perhaps a mechanism to tell <code>operator&gt;&gt;</code> what to do will be adopted in
the future, maybe a preprocessor define, a global flag, or an <code>ios</code> flag
pressed into service.  Or maybe, at the risk of inconsistency, the
<code>mpq_class</code> <code>operator&gt;&gt;</code> could canonicalize and leave <code>mpq_t</code>
<code>operator&gt;&gt;</code> not doing so, for use on those occasions when that's
acceptable.  Send feedback or alternate ideas to <a href="mailto:bug-gmp@gnu.org">bug-gmp@gnu.org</a>.

<br><dt>Subclassing
<dd>Subclassing the GMP C++ classes works, but is not currently recommended.

<p>Expressions involving subclasses resolve correctly (or seem to), but in normal
C++ fashion the subclass doesn't inherit constructors and assignments. 
There's many of those in the GMP classes, and a good way to reestablish them
in a subclass is not yet provided.

<br><dt>Templated Expressions
<dd>
A subtle difficulty exists when using expressions together with
application-defined template functions.  Consider the following, with <code>T</code>
intended to be some numeric type,

<br><pre>template &lt;class T&gt;
T fun (const T &amp;, const T &amp;);
</pre>

<p>When used with, say, plain <code>mpz_class</code> variables, it works fine: <code>T</code>
is resolved as <code>mpz_class</code>.

<br><pre>mpz_class f(1), g(2);
fun (f, g);    // Good
</pre>

<p>But when one of the arguments is an expression, it doesn't work.

<br><pre>mpz_class f(1), g(2), h(3);
fun (f, g+h);  // Bad
</pre>

<p>This is because <code>g+h</code> ends up being a certain expression template type
internal to <code>gmpxx.h</code>, which the C++ template resolution rules are unable
to automatically convert to <code>mpz_class</code>.  The workaround is simply to add
an explicit cast.

<br><pre>mpz_class f(1), g(2), h(3);
fun (f, mpz_class(g+h));  // Good
</pre>

<p>Similarly, within <code>fun</code> it may be necessary to cast an expression to type
<code>T</code> when calling a templated <code>fun2</code>.

<br><pre>template &lt;class T&gt;
void fun (T f, T g)
{
  fun2 (f, f+g);     // Bad
}

template &lt;class T&gt;
void fun (T f, T g)
{
  fun2 (f, T(f+g));  // Good
}
</pre>
</dl>

<p><hr>
Node:<a name="BSD%20Compatible%20Functions">BSD Compatible Functions</a>,
Next:<a rel=next accesskey=n href="#Custom%20Allocation">Custom Allocation</a>,
Previous:<a rel=previous accesskey=p href="#C++%20Class%20Interface">C++ Class Interface</a>,
Up:<a rel=up accesskey=u href="#Top">Top</a>
<br>

<h2>Berkeley MP Compatible Functions</h2>

<p>These functions are intended to be fully compatible with the Berkeley MP
library which is available on many BSD derived U*ix systems.  The
<code>--enable-mpbsd</code> option must be used when building GNU MP to make these
available (see <a href="#Installing%20GMP">Installing GMP</a>).

<p>The original Berkeley MP library has a usage restriction: you cannot use the
same variable as both source and destination in a single function call.  The
compatible functions in GNU MP do not share this restriction--inputs and
outputs may overlap.

<p>It is not recommended that new programs are written using these functions. 
Apart from the incomplete set of functions, the interface for initializing
<code>MINT</code> objects is more error prone, and the <code>pow</code> function collides
with <code>pow</code> in <code>libm.a</code>.

<p>Include the header <code>mp.h</code> to get the definition of the necessary types and
functions.  If you are on a BSD derived system, make sure to include GNU
<code>mp.h</code> if you are going to link the GNU <code>libmp.a</code> to your program. 
This means that you probably need to give the <code>-I&lt;dir&gt;</code> option to the
compiler, where <code>&lt;dir&gt;</code> is the directory where you have GNU <code>mp.h</code>.

<p>
<table width="100%">
<tr>
<td align="left">MINT * <b>itom</b><i> (signed short int <var>initial_value</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Allocate an integer consisting of a <code>MINT</code> object and dynamic limb space. 
Initialize the integer to <var>initial_value</var>.  Return a pointer to the
<code>MINT</code> object. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">MINT * <b>xtom</b><i> (char *<var>initial_value</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Allocate an integer consisting of a <code>MINT</code> object and dynamic limb space. 
Initialize the integer from <var>initial_value</var>, a hexadecimal,
null-terminated C string.  Return a pointer to the <code>MINT</code> object. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>move</b><i> (MINT *<var>src</var>, MINT *<var>dest</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>dest</var> to <var>src</var> by copying.  Both variables must be previously
initialized. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>madd</b><i> (MINT *<var>src_1</var>, MINT *<var>src_2</var>, MINT *<var>destination</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Add <var>src_1</var> and <var>src_2</var> and put the sum in <var>destination</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>msub</b><i> (MINT *<var>src_1</var>, MINT *<var>src_2</var>, MINT *<var>destination</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Subtract <var>src_2</var> from <var>src_1</var> and put the difference in
<var>destination</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mult</b><i> (MINT *<var>src_1</var>, MINT *<var>src_2</var>, MINT *<var>destination</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Multiply <var>src_1</var> and <var>src_2</var> and put the product in <var>destination</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mdiv</b><i> (MINT *<var>dividend</var>, MINT *<var>divisor</var>, MINT *<var>quotient</var>, MINT *<var>remainder</var>)
</i></td>
<td align="right">Function</td>
</tr>

<tr>
<td align="left">void <b>sdiv</b><i> (MINT *<var>dividend</var>, signed short int <var>divisor</var>, MINT *<var>quotient</var>, signed short int *<var>remainder</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>quotient</var> to <var>dividend</var>/<var>divisor</var>, and <var>remainder</var> to
<var>dividend</var> mod <var>divisor</var>.  The quotient is rounded towards zero; the
remainder has the same sign as the dividend unless it is zero.

<p>Some implementations of these functions work differently--or not at all--for
negative arguments. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>msqrt</b><i> (MINT *<var>op</var>, MINT *<var>root</var>, MINT *<var>remainder</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>root</var> to the truncated integer part
of the square root of <var>op</var>, like <code>mpz_sqrt</code>.  Set <var>remainder</var> to
<var>op</var>-<var>root</var>*<var>root</var>, i.e. 
zero if <var>op</var> is a perfect square.

<p>If <var>root</var> and <var>remainder</var> are the same variable, the results are
undefined. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>pow</b><i> (MINT *<var>base</var>, MINT *<var>exp</var>, MINT *<var>mod</var>, MINT *<var>dest</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>dest</var> to (<var>base</var> raised to <var>exp</var>) modulo <var>mod</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>rpow</b><i> (MINT *<var>base</var>, signed short int <var>exp</var>, MINT *<var>dest</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>dest</var> to <var>base</var> raised to <var>exp</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>gcd</b><i> (MINT *<var>op1</var>, MINT *<var>op2</var>, MINT *<var>res</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Set <var>res</var> to the greatest common divisor of <var>op1</var> and <var>op2</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">int <b>mcmp</b><i> (MINT *<var>op1</var>, MINT *<var>op2</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Compare <var>op1</var> and <var>op2</var>.  Return a positive value if <var>op1</var> &gt;
<var>op2</var>, zero if <var>op1</var> = <var>op2</var>, and a negative value if <var>op1</var> &lt;
<var>op2</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>min</b><i> (MINT *<var>dest</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Input a decimal string from <code>stdin</code>, and put the read integer in
<var>dest</var>.  SPC and TAB are allowed in the number string, and are ignored. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mout</b><i> (MINT *<var>src</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Output <var>src</var> to <code>stdout</code>, as a decimal string.  Also output a newline. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">char * <b>mtox</b><i> (MINT *<var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Convert <var>op</var> to a hexadecimal string, and return a pointer to the string. 
The returned string is allocated using the default memory allocation function,
<code>malloc</code> by default.  It will be <code>strlen(str)+1</code> bytes, that being
exactly enough for the string and null-terminator. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>mfree</b><i> (MINT *<var>op</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
De-allocate, the space used by <var>op</var>.  <strong>This function should only be
passed a value returned by <code>itom</code> or <code>xtom</code>.</strong>
</td></tr>
</table>

<p><hr>
Node:<a name="Custom%20Allocation">Custom Allocation</a>,
Next:<a rel=next accesskey=n href="#Language%20Bindings">Language Bindings</a>,
Previous:<a rel=previous accesskey=p href="#BSD%20Compatible%20Functions">BSD Compatible Functions</a>,
Up:<a rel=up accesskey=u href="#Top">Top</a>
<br>

<h2>Custom Allocation</h2>

<p>By default GMP uses <code>malloc</code>, <code>realloc</code> and <code>free</code> for memory
allocation, and if they fail GMP prints a message to the standard error output
and terminates the program.

<p>Alternate functions can be specified to allocate memory in a different way or
to have a different error action on running out of memory.

<p>This feature is available in the Berkeley compatibility library (see <a href="#BSD%20Compatible%20Functions">BSD Compatible Functions</a>) as well as the main GMP library.

<p>
<table width="100%">
<tr>
<td align="left">void <b>mp_set_memory_functions</b><i> (<br> void *(*<var>alloc_func_ptr</var>) (size_t), <br> void *(*<var>realloc_func_ptr</var>) (void *, size_t, size_t), <br> void (*<var>free_func_ptr</var>) (void *, size_t))
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Replace the current allocation functions from the arguments.  If an argument
is <code>NULL</code>, the corresponding default function is used.

<p>These functions will be used for all memory allocation done by GMP, apart from
temporary space from <code>alloca</code> if that function is available and GMP is
configured to use it (see <a href="#Build%20Options">Build Options</a>).

<p><strong>Be sure to call <code>mp_set_memory_functions</code> only when there are no
active GMP objects allocated using the previous memory functions!  Usually
that means calling it before any other GMP function.</strong>
</td></tr>
</table>

<p>The functions supplied should fit the following declarations:

<p>
<table width="100%">
<tr>
<td align="left">void * <b>allocate_function</b><i> (size_t <var>alloc_size</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Return a pointer to newly allocated space with at least <var>alloc_size</var>
bytes. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void * <b>reallocate_function</b><i> (void *<var>ptr</var>, size_t <var>old_size</var>, size_t <var>new_size</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
Resize a previously allocated block <var>ptr</var> of <var>old_size</var> bytes to be
<var>new_size</var> bytes.

<p>The block may be moved if necessary or if desired, and in that case the
smaller of <var>old_size</var> and <var>new_size</var> bytes must be copied to the new
location.  The return value is a pointer to the resized block, that being the
new location if moved or just <var>ptr</var> if not.

<p><var>ptr</var> is never <code>NULL</code>, it's always a previously allocated block. 
<var>new_size</var> may be bigger or smaller than <var>old_size</var>. 
</td></tr>
</table>

<p>
<table width="100%">
<tr>
<td align="left">void <b>deallocate_function</b><i> (void *<var>ptr</var>, size_t <var>size</var>)
</i></td>
<td align="right">Function</td>
</tr>
</table>
<table width="95%" align="center">
<tr><td>
De-allocate the space pointed to by <var>ptr</var>.

<p><var>ptr</var> is never <code>NULL</code>, it's always a previously allocated block of
<var>size</var> bytes. 
</td></tr>
</table>

<p>A <dfn>byte</dfn> here means the unit used by the <code>sizeof</code> operator.

<p>The <var>old_size</var> parameters to <var>reallocate_function</var> and
<var>deallocate_function</var> are passed for convenience, but of course can be
ignored if not needed.  The default functions using <code>malloc</code> and friends
for instance don't use them.

<p>No error return is allowed from any of these functions, if they return then
they must have performed the specified operation.  In particular note that
<var>allocate_function</var> or <var>reallocate_function</var> mustn't return
<code>NULL</code>.

<p>Getting a different fatal error action is a good use for custom allocation
functions, for example giving a graphical dialog rather than the default print
to <code>stderr</code>.  How much is possible when genuinely out of memory is
another question though.

<p>There's currently no defined way for the allocation functions to recover from
an error such as out of memory, they must terminate program execution.  A
<code>longjmp</code> or throwing a C++ exception will have undefined results.  This
may change in the future.

<p>GMP may use allocated blocks to hold pointers to other allocated blocks.  This
will limit the assumptions a conservative garbage collection scheme can make.

<p>Since the default GMP allocation uses <code>malloc</code> and friends, those
functions will be linked in even if the first thing a program does is an
<code>mp_set_memory_functions</code>.  It's necessary to change the GMP sources if
this is a problem.

<p><hr>
Node:<a name="Language%20Bindings">Language Bindings</a>,
Next:<a rel=next accesskey=n href="#Algorithms">Algorithms</a>,
Previous:<a rel=previous accesskey=p href="#Custom%20Allocation">Custom Allocation</a>,
Up:<a rel=up accesskey=u href="#Top">Top</a>
<br>

<h2>Language Bindings</h2>

<p>The following packages and projects offer access to GMP from languages other
than C, though perhaps with varying levels of functionality and efficiency.

<br><p>
<dl>
<dt>C++
<dd>
<ul>
<li>GMP C++ class interface, see <a href="#C++%20Class%20Interface">C++ Class Interface</a> <br> Straightforward
interface, expression templates to eliminate temporaries. 
<li>ALP <a href="http://www.inria.fr/saga/logiciels/ALP">http://www.inria.fr/saga/logiciels/ALP</a> <br> Linear algebra and
polynomials using templates. 
<li>CLN <a href="http://clisp.cons.org/~haible/packages-cln.html">http://clisp.cons.org/~haible/packages-cln.html</a> <br> High level
classes for arithmetic. 
<li>LiDIA <a href="http://www.informatik.tu-darmstadt.de/TI/LiDIA">http://www.informatik.tu-darmstadt.de/TI/LiDIA</a> <br> A C++
library for computational number theory. 
<li>NTL <a href="http://www.shoup.net/ntl">http://www.shoup.net/ntl</a> <br> A C++ number theory library. 
</ul>

<br><dt>Fortran
<dd>
<ul>
<li>Omni F77 <a href="http://pdplab.trc.rwcp.or.jp/pdperf/Omni/home.html">http://pdplab.trc.rwcp.or.jp/pdperf/Omni/home.html</a> <br>
Arbitrary precision floats. 
</ul>

<br><dt>Haskell
<dd>
<ul>
<li>Glasgow Haskell Compiler <a href="http://www.haskell.org/ghc">http://www.haskell.org/ghc</a>
</ul>

<br><dt>Java
<dd>
<ul>
<li>Kaffe <a href="http://www.kaffe.org">http://www.kaffe.org</a>
<li>Kissme <a href="http://kissme.sourceforge.net">http://kissme.sourceforge.net</a>
</ul>

<br><dt>Lisp
<dd>
<ul>
<li>GNU Common Lisp <a href="http://www.gnu.org/software/gcl/gcl.html">http://www.gnu.org/software/gcl/gcl.html</a> <br> In the
process of switching to GMP for bignums. 
<li>Librep <a href="http://librep.sourceforge.net">http://librep.sourceforge.net</a>
</ul>

<br><dt>M4
<dd>
<ul>
<li>GNU m4 betas <a href="http://www.seindal.dk/rene/gnu">http://www.seindal.dk/rene/gnu</a> <br> Optionally provides
an arbitrary precision <code>mpeval</code>. 
</ul>

<br><dt>ML
<dd>
<ul>
<li>MLton compiler <a href="http://www.sourcelight.com/MLton">http://www.sourcelight.com/MLton</a>
</ul>

<br><dt>Oz
<dd>
<ul>
<li>Mozart <a href="http://www.mozart-oz.org">http://www.mozart-oz.org</a>
</ul>

<br><dt>Pascal
<dd>
<ul>
<li>GNU Pascal Compiler <a href="http://www.gnu-pascal.de">http://www.gnu-pascal.de</a> <br> GMP unit. 
</ul>

<br><dt>Perl
<dd>
<ul>
<li>GMP module, see <code>demos/perl</code> in the GMP sources. 
<li>Math::GMP <a href="http://www.cpan.org">http://www.cpan.org</a> <br> Compatible with Math::BigInt, but
not as many functions as the GMP module above. 
<li>Math::BigInt::GMP <a href="http://www.cpan.org">http://www.cpan.org</a> <br> Plug Math::GMP into
normal Math::BigInt operations. 
</ul>

<br><dt>Pike
<dd>
<ul>
<li>mpz module in the standard distribution, <a href="http://pike.idonex.com">http://pike.idonex.com</a>
</ul>

<br><dt>Prolog
<dd>
<ul>
<li>SWI Prolog <a href="http://www.swi.psy.uva.nl/projects/SWI-Prolog">http://www.swi.psy.uva.nl/projects/SWI-Prolog</a> <br>
Arbitrary precision floats. 
</ul>

<br><dt>Python
<dd>
<ul>
<li>mpz module in the standard distribution, <a href="http://www.python.org">http://www.python.org</a>
<li>GMPY <a href="http://gmpy.sourceforge.net">http://gmpy.sourceforge.net</a>
</ul>

<br><dt>Scheme
<dd>
<ul>
<li>RScheme <a href="http://www.rscheme.org">http://www.rscheme.org</a>
<li>STklos <a href="http://kaolin.unice.fr/STklos">http://kaolin.unice.fr/STklos</a>
</ul>

<br><dt>Smalltalk
<dd>
<ul>
<li>GNU Smalltalk <a href="http://www.smalltalk.org/versions/GNUSmalltalk.html">http://www.smalltalk.org/versions/GNUSmalltalk.html</a>
</ul>

<br><dt>Other
<dd>
<ul>
<li>DrGenius <a href="http://drgenius.seul.org">http://drgenius.seul.org</a> <br> Geometry system and
mathematical programming language. 
<li>GiNaC <a href="http://www.ginac.de">http://www.ginac.de</a> <br> C++ computer algebra using CLN. 
<li>Maxima <a href="http://www.ma.utexas.edu/users/wfs/maxima.html">http://www.ma.utexas.edu/users/wfs/maxima.html</a> <br> Macsyma
computer algebra using GCL. 
<li>Q <a href="http://www.musikwissenschaft.uni-mainz.de/~ag/q">http://www.musikwissenschaft.uni-mainz.de/~ag/q</a> <br> Equational
programming system. 
<li>Regina <a href="http://regina.sourceforge.net">http://regina.sourceforge.net</a> <br> Topological calculator. 
<li>Yacas <a href="http://www.xs4all.nl/~apinkus/yacas.html">http://www.xs4all.nl/~apinkus/yacas.html</a> <br> Yet another
computer algebra system. 
</ul>

</dl>

<p><hr>
Node:<a name="Algorithms">Algorithms</a>,
Next:<a rel=next accesskey=n href="#Internals">Internals</a>,
Previous:<a rel=previous accesskey=p href="#Language%20Bindings">Language Bindings</a>,
Up:<a rel=up accesskey=u href="#Top">Top</a>
<br>

<h2>Algorithms</h2>

<p>This chapter is an introduction to some of the algorithms used for various GMP
operations.  The code is likely to be hard to understand without knowing
something about the algorithms.

<p>Some GMP internals are mentioned, but applications that expect to be
compatible with future GMP releases should take care to use only the
documented functions.

<ul>
<li><a accesskey=1 href="#Multiplication%20Algorithms">Multiplication Algorithms</a>: 
<li><a accesskey=2 href="#Division%20Algorithms">Division Algorithms</a>: 
<li><a accesskey=3 href="#Greatest%20Common%20Divisor%20Algorithms">Greatest Common Divisor Algorithms</a>: 
<li><a accesskey=4 href="#Powering%20Algorithms">Powering Algorithms</a>: 
<li><a accesskey=5 href="#Root%20Extraction%20Algorithms">Root Extraction Algorithms</a>: 
<li><a accesskey=6 href="#Radix%20Conversion%20Algorithms">Radix Conversion Algorithms</a>: 
<li><a accesskey=7 href="#Other%20Algorithms">Other Algorithms</a>: 
<li><a accesskey=8 href="#Assembler%20Coding">Assembler Coding</a>: 
</ul>

<p><hr>
Node:<a name="Multiplication%20Algorithms">Multiplication Algorithms</a>,
Next:<a rel=next accesskey=n href="#Division%20Algorithms">Division Algorithms</a>,
Previous:<a rel=previous accesskey=p href="#Algorithms">Algorithms</a>,
Up:<a rel=up accesskey=u href="#Algorithms">Algorithms</a>
<br>

<h3>Multiplication</h3>

<p>NxN limb multiplications and squares are done using one of four
algorithms, as the size N increases.

<blockquote>
<p><table><tr align="left"><td valign="top">Algorithm </td><td valign="top">Threshold
<br></td></tr><tr align="left"><td valign="top">Basecase  </td><td valign="top">(none)
<br></td></tr><tr align="left"><td valign="top">Karatsuba </td><td valign="top"><code>MUL_KARATSUBA_THRESHOLD</code>
<br></td></tr><tr align="left"><td valign="top">Toom-3    </td><td valign="top"><code>MUL_TOOM3_THRESHOLD</code>
<br></td></tr><tr align="left"><td valign="top">FFT       </td><td valign="top"><code>MUL_FFT_THRESHOLD</code>
<br></td></tr></table>
</blockquote>

<p>Similarly for squaring, with the <code>SQR</code> thresholds.  Note though that the
FFT is only used if GMP is configured with <code>--enable-fft</code>, see <a href="#Build%20Options">Build Options</a>.

<p>NxM multiplications of operands with different sizes above
<code>MUL_KARATSUBA_THRESHOLD</code> are currently done by splitting into MxM
pieces.  The Karatsuba and Toom-3 routines then operate only on equal size
operands.  This is not very efficient, and is slated for improvement in the
future.

<ul>
<li><a accesskey=1 href="#Basecase%20Multiplication">Basecase Multiplication</a>: 
<li><a accesskey=2 href="#Karatsuba%20Multiplication">Karatsuba Multiplication</a>: 
<li><a accesskey=3 href="#Toom-Cook%203-Way%20Multiplication">Toom-Cook 3-Way Multiplication</a>: 
<li><a accesskey=4 href="#FFT%20Multiplication">FFT Multiplication</a>: 
<li><a accesskey=5 href="#Other%20Multiplication">Other Multiplication</a>: 
</ul>

<p><hr>
Node:<a name="Basecase%20Multiplication">Basecase Multiplication</a>,
Next:<a rel=next accesskey=n href="#Karatsuba%20Multiplication">Karatsuba Multiplication</a>,
Previous:<a rel=previous accesskey=p href="#Multiplication%20Algorithms">Multiplication Algorithms</a>,
Up:<a rel=up accesskey=u href="#Multiplication%20Algorithms">Multiplication Algorithms</a>
<br>

<h4>Basecase Multiplication</h4>

<p>Basecase NxM multiplication is a straightforward rectangular set of
cross-products, the same as long multiplication done by hand and for that
reason sometimes known as the schoolbook or grammar school method.  This is an
O(N*M) algorithm.  See Knuth section 4.3.1 algorithm M
(see <a href="#References">References</a>), and the <code>mpn/generic/mul_basecase.c</code> code.

<p>Assembler implementations of <code>mpn_mul_basecase</code> are essentially the same
as the generic C code, but have all the usual assembler tricks and
obscurities introduced for speed.

<p>A square can be done in roughly half the time of a multiply, by using the fact
that the cross products above and below the diagonal are the same.  A triangle
of products below the diagonal is formed, doubled (left shift by one bit), and
then the products on the diagonal added.  This can be seen in
<code>mpn/generic/sqr_basecase.c</code>.  Again the assembler implementations take
essentially the same approach.

<br><pre>     u0  u1  u2  u3  u4
   +---+---+---+---+---+
u0 | d |   |   |   |   |
   +---+---+---+---+---+
u1 |   | d |   |   |   |
   +---+---+---+---+---+
u2 |   |   | d |   |   |
   +---+---+---+---+---+
u3 |   |   |   | d |   |
   +---+---+---+---+---+
u4 |   |   |   |   | d |
   +---+---+---+---+---+
</pre>

<p>In practice squaring isn't a full 2x faster than multiplying, it's
usually around 1.5x.  Less than 1.5x probably indicates
<code>mpn_sqr_basecase</code> wants improving on that CPU.

<p>On some CPUs <code>mpn_mul_basecase</code> can be faster than the generic C
<code>mpn_sqr_basecase</code>.  <code>SQR_BASECASE_THRESHOLD</code> is the size at which
to use <code>mpn_sqr_basecase</code>, this will be zero if that routine should be
used always.

<p><hr>
Node:<a name="Karatsuba%20Multiplication">Karatsuba Multiplication</a>,
Next:<a rel=next accesskey=n href="#Toom-Cook%203-Way%20Multiplication">Toom-Cook 3-Way Multiplication</a>,
Previous:<a rel=previous accesskey=p href="#Basecase%20Multiplication">Basecase Multiplication</a>,
Up:<a rel=up accesskey=u href="#Multiplication%20Algorithms">Multiplication Algorithms</a>
<br>

<h4>Karatsuba Multiplication</h4>

<p>The Karatsuba multiplication algorithm is described in Knuth section 4.3.3
part A, and various other textbooks.  A brief description is given here.

<p>The inputs x and y are treated as each split into two parts of
equal length (or the most significant part one limb shorter if N is odd).

<br><pre> high              low
+----------+----------+
|    x1    |    x0    |
+----------+----------+

+----------+----------+
|    y1    |    y0    |
+----------+----------+
</pre>

<p>Let b be the power of 2 where the split occurs, ie. if x0 is
k limbs (y0 the same) then
b=2^(k*mp_bits_per_limb). 
With that x=x1*b+x0 and y=y1*b+y0, and the
following holds,

<br><pre>x*y = (b^2+b)*x1*y1 - b*(x1-x0)*(y1-y0) + (b+1)*x0*y0
</pre>

<p>This formula means doing only three multiplies of (N/2)x(N/2) limbs,
whereas a basecase multiply of NxN limbs is equivalent to four
multiplies of (N/2)x(N/2).  The factors (b^2+b) etc represent
the positions where the three products must be added.

<br><pre> high                              low
+--------+--------+ +--------+--------+
|      x1*y1      | |      x0*y0      |
+--------+--------+ +--------+--------+
          +--------+--------+
      add |      x1*y1      |
          +--------+--------+
          +--------+--------+
      add |      x0*y0      |
          +--------+--------+
          +--------+--------+
      sub | (x1-x0)*(y1-y0) |
          +--------+--------+
</pre>

<p>The term (x1-x0)*(y1-y0) is best calculated as an
absolute value, and the sign used to choose to add or subtract.  Notice the
sum high(x0*y0)+low(x1*y1) occurs twice, so it's possible to do 5*k limb
additions, rather than 6*k, but in GMP extra function call overheads
outweigh the saving.

<p>Squaring is similar to multiplying, but with x=y the formula reduces to
an equivalent with three squares,

<br><pre>x^2 = (b^2+b)*x1^2 - b*(x1-x0)^2 + (b+1)*x0^2
</pre>

<p>The final result is accumulated from those three squares the same way as for
the three multiplies above.  The middle term (x1-x0)^2 is now
always positive.

<p>A similar formula for both multiplying and squaring can be constructed with a
middle term (x1+x0)*(y1+y0).  But those sums can exceed
k limbs, leading to more carry handling and additions than the form
above.

<p>Karatsuba multiplication is asymptotically an O(N^1.585) algorithm,
the exponent being log(3)/log(2), representing 3 multiplies
each 1/2 the size of the inputs.  This is a big improvement over the basecase
multiply at O(N^2) and the advantage soon overcomes the extra additions
Karatsuba performs.

<p><code>MUL_KARATSUBA_THRESHOLD</code> can be as little as 10 limbs.  The <code>SQR</code>
threshold is usually about twice the <code>MUL</code>.  The basecase algorithm will
take a time of the form M(N) = a*N^2 + b*N + c and
the Karatsuba algorithm K(N) = 3*M(N/2) + d*N +
e.  Clearly per-crossproduct speedups in the basecase code reduce a
and decrease the threshold, but linear style speedups reducing b will
actually increase the threshold.  The latter can be seen for instance when
adding an optimized <code>mpn_sqr_diagonal</code> to <code>mpn_sqr_basecase</code>.  Of
course all speedups reduce total time, and in that sense the algorithm
thresholds are merely of academic interest.

<p><hr>
Node:<a name="Toom-Cook%203-Way%20Multiplication">Toom-Cook 3-Way Multiplication</a>,
Next:<a rel=next accesskey=n href="#FFT%20Multiplication">FFT Multiplication</a>,
Previous:<a rel=previous accesskey=p href="#Karatsuba%20Multiplication">Karatsuba Multiplication</a>,
Up:<a rel=up accesskey=u href="#Multiplication%20Algorithms">Multiplication Algorithms</a>
<br>

<h4>Toom-Cook 3-Way Multiplication</h4>

<p>The Karatsuba formula is the simplest case of a general approach to splitting
inputs that leads to both Toom-Cook and FFT algorithms.  A description of
Toom-Cook can be found in Knuth section 4.3.3, with an example 3-way
calculation after Theorem A.  The 3-way form used in GMP is described here.

<p>The operands are each considered split into 3 pieces of equal length (or the
most significant part 1 or 2 limbs shorter than the others).

<br><pre> high                         low
+----------+----------+----------+
|    x2    |    x1    |    x0    |
+----------+----------+----------+

+----------+----------+----------+
|    y2    |    y1    |    y0    |
+----------+----------+----------+
</pre>

<p>These parts are treated as the coefficients of two polynomials

<br><pre>X(t) = x2*t^2 + x1*t + x0
Y(t) = y2*t^2 + y1*t + y0
</pre>

<p>Again let b equal the power of 2 which is the size of the x0,
x1, y0 and y1 pieces, ie. if they're k limbs each
then b=2^(k*mp_bits_per_limb).  With this x=X(b) and y=Y(b).

<p>Let a polynomial W(t)=X(t)*Y(t) and suppose its coefficients
are

<br><pre>W(t) = w4*t^4 + w3*t^3 + w2*t^2 + w1*t + w0
</pre>

<p>The w[i] are going to be determined, and when they are they'll give
the final result using w=W(b), since
x*y=X(b)*Y(b)=W(b).  The coefficients will be roughly
b^2 each, and the final W(b) will be an addition like,

<br><pre> high                                        low
+-------+-------+
|       w4      |
+-------+-------+
       +--------+-------+
       |        w3      |
       +--------+-------+
               +--------+-------+
               |        w2      |
               +--------+-------+
                       +--------+-------+
                       |        w1      |
                       +--------+-------+
                                +-------+-------+
                                |       w0      |
                                +-------+-------+
</pre>

<p>The w[i] coefficients could be formed by a simple set of cross
products, like w4=x2*y2, w3=x2*y1+x1*y2,
w2=x2*y0+x1*y1+x0*y2 etc, but this would need all
nine x[i]*y[j] for i,j=0,1,2, and would be equivalent merely
to a basecase multiply.  Instead the following approach is used.

<p>X(t) and Y(t) are evaluated and multiplied at 5 points, giving
values of W(t) at those points.  The points used can be chosen in
various ways, but in GMP the following are used

<blockquote>
<p><table><tr align="left"><td valign="top">Point                 </td><td valign="top">Value
<br></td></tr><tr align="left"><td valign="top">t=0            </td><td valign="top">x0*y0, which gives w0 immediately
<br></td></tr><tr align="left"><td valign="top">t=2            </td><td valign="top">(4*x2+2*x1+x0)*(4*y2+2*y1+y0)
<br></td></tr><tr align="left"><td valign="top">t=1            </td><td valign="top">(x2+x1+x0)*(y2+y1+y0)
<br></td></tr><tr align="left"><td valign="top">t=1/2 </td><td valign="top">(x2+2*x1+4*x0)*(y2+2*y1+4*y0)
<br></td></tr><tr align="left"><td valign="top">t=inf    </td><td valign="top">x2*y2, which gives w4 immediately
<br></td></tr></table>
</blockquote>

<p>At t=1/2 the value calculated is actually
16*X(1/2)*Y(1/2), giving a value for
16*W(1/2), and this is always an integer.  At
t=inf the value is actually X(t)*Y(t)/t^4 in the limit as t approaches infinity, but it's much
easier to think of as simply x2*y2 giving w4 immediately
(much like x0*y0 at t=0 gives w0 immediately).

<p>Now each of the points substituted into
W(t)=w4*t^4+<small>...</small>+w0 gives a linear combination
of the w[i] coefficients, and the value of those combinations has just
been calculated.

<br><pre>   W(0)   =                                 w0
16*W(1/2) =    w4 + 2*w3 + 4*w2 + 8*w1 + 16*w0
   W(1)   =    w4 +   w3 +   w2 +   w1 +    w0
   W(2)   = 16*w4 + 8*w3 + 4*w2 + 2*w1 +    w0
   W(inf) =    w4
</pre>

<p>This is a set of five equations in five unknowns, and some elementary linear
algebra quickly isolates each w[i], by subtracting multiples of one
equation from another.

<p>In the code the set of five values W(0),<small>...</small>,W(inf)
will represent those certain linear combinations.  By adding or subtracting
one from another as necessary, values which are each w[i] alone are
arrived at.  This involves only a few subtractions of small multiples (some of
which are powers of 2), and so is fast.  A couple of divisions remain by
powers of 2 and one division by 3 (or by 6 rather), and that last uses the
special <code>mpn_divexact_by3</code> (see <a href="#Exact%20Division">Exact Division</a>).

<p>In the code the values w4, w2 and w0 are formed in the
destination with pointers <code>E</code>, <code>C</code> and <code>A</code>, and w3 and
w1 in temporary space <code>D</code> and <code>B</code> are added to them.  There
are extra limbs <code>tD</code>, <code>tC</code> and <code>tB</code> at the high end of
w3, w2 and w1 which are handled separately.  The final
addition then is as follows.

<br><pre> high                                        low
+-------+-------+-------+-------+-------+-------+
|       E       |       C       |       A       |
+-------+-------+-------+-------+-------+-------+
         +------+-------++------+-------+
         |      D       ||      B       |
         +------+-------++------+-------+
      --      --      --
     |tD|    |tC|    |tB|
      --      --      --
</pre>

<p>The conversion of W(t) values to the coefficients is interpolation.  A
polynomial of degree 4 like W(t) is uniquely determined by values known
at 5 different points.  The points can be chosen to make the linear equations
come out with a convenient set of steps for isolating the w[i].

<p>In <code>mpn/generic/mul_n.c</code> the <code>interpolate3</code> routine performs the
interpolation.  The open-coded one-pass version may be a bit hard to
understand, the steps performed can be better seen in the <code>USE_MORE_MPN</code>
version.

<p>Squaring follows the same procedure as multiplication, but there's only one
X(t) and it's evaluated at 5 points, and those values squared to give
values of W(t).  The interpolation is then identical, and in fact the
same <code>interpolate3</code> subroutine is used for both squaring and multiplying.

<p>Toom-3 is asymptotically O(N^1.465), the exponent being
log(5)/log(3), representing 5 recursive multiplies of 1/3 the
original size.  This is an improvement over Karatsuba at O(N^1.585),
though Toom-Cook does more work in the evaluation and interpolation and so it
only realizes its advantage above a certain size.

<p>Near the crossover between Toom-3 and Karatsuba there's generally a range of
sizes where the difference between the two is small. 
<code>MUL_TOOM3_THRESHOLD</code> is a somewhat arbitrary point in that range and
successive runs of the tune program can give different values due to small
variations in measuring.  A graph of time versus size for the two shows the
effect, see <code>tune/README</code>.

<p>At the fairly small sizes where the Toom-3 thresholds occur it's worth
remembering that the asymptotic behaviour for Karatsuba and Toom-3 can't be
expected to make accurate predictions, due of course to the big influence of
all sorts of overheads, and the fact that only a few recursions of each are
being performed.  Even at large sizes there's a good chance machine dependent
effects like cache architecture will mean actual performance deviates from
what might be predicted.

<p>The formula given above for the Karatsuba algorithm has an equivalent for
Toom-3 involving only five multiplies, but this would be complicated and
unenlightening.

<p>An alternate view of Toom-3 can be found in Zuras (see <a href="#References">References</a>), using
a vector to represent the x and y splits and a matrix
multiplication for the evaluation and interpolation stages.  The matrix
inverses are not meant to be actually used, and they have elements with values
much greater than in fact arise in the interpolation steps.  The diagram shown
for the 3-way is attractive, but again doesn't have to be implemented that way
and for example with a bit of rearrangement just one division by 6 can be
done.

<p><hr>
Node:<a name="FFT%20Multiplication">FFT Multiplication</a>,
Next:<a rel=next accesskey=n href="#Other%20Multiplication">Other Multiplication</a>,
Previous:<a rel=previous accesskey=p href="#Toom-Cook%203-Way%20Multiplication">Toom-Cook 3-Way Multiplication</a>,
Up:<a rel=up accesskey=u href="#Multiplication%20Algorithms">Multiplication Algorithms</a>
<br>

<h4>FFT Multiplication</h4>

<p>At large to very large sizes a Fermat style FFT multiplication is used,
following Sch&ouml;nhage and Strassen (see <a href="#References">References</a>).  Descriptions of FFTs
in various forms can be found in many textbooks, for instance Knuth section
4.3.3 part C or Lipson chapter IX.  A brief description of the form used in
GMP is given here.

<p>The multiplication done is x*y mod 2^N+1, for a given
N.  A full product x*y is obtained by choosing N&gt;=bits(x)+bits(y) and padding
x and y with high zero limbs.  The modular product is the native
form for the algorithm, so padding to get a full product is unavoidable.

<p>The algorithm follows a split, evaluate, pointwise multiply, interpolate and
combine similar to that described above for Karatsuba and Toom-3.  A k
parameter controls the split, with an FFT-k splitting into 2^k
pieces of M=N/2^k bits each.  N must be a multiple of
(2^k)*<code>mp_bits_per_limb</code> so
the split falls on limb boundaries, avoiding bit shifts in the split and
combine stages.

<p>The evaluations, pointwise multiplications, and interpolation, are all done
modulo 2^N'+1 where N' is 2M+k+3 rounded up to a
multiple of 2^k and of <code>mp_bits_per_limb</code>.  The results of
interpolation will be the following negacyclic convolution of the input
pieces, and the choice of N' ensures these sums aren't truncated.

<br><pre>           ---
           \         b
w[n] =     /     (-1) * x[i] * y[j]
           ---
       i+j==b*2^k+n
          b=0,1
</pre>

<p>The points used for the evaluation are g^i for i=0 to
2^k-1 where g=2^(2N'/2^k).  g is a
2^k'th root of unity mod 2^N'+1, which produces necessary
cancellations at the interpolation stage, and it's also a power of 2 so the
fast fourier transforms used for the evaluation and interpolation do only
shifts, adds and negations.

<p>The pointwise multiplications are done modulo 2^N'+1 and either
recurse into a further FFT or use a plain multiplication (Toom-3, Karatsuba or
basecase), whichever is optimal at the size N'.  The interpolation is
an inverse fast fourier transform.  The resulting set of sums of x[i]*y[j] are added at appropriate offsets to give the final result.

<p>Squaring is the same, but x is the only input so it's one transform at
the evaluate stage and the pointwise multiplies are squares.  The
interpolation is the same.

<p>For a mod 2^N+1 product, an FFT-k is an O(N^(k/(k-1))) algorithm, the exponent representing 2^k recursed
modular multiplies each 1/2^(k-1) the size of the original. 
Each successive k is an asymptotic improvement, but overheads mean each
is only faster at bigger and bigger sizes.  In the code, <code>MUL_FFT_TABLE</code>
and <code>SQR_FFT_TABLE</code> are the thresholds where each k is used.  Each
new k effectively swaps some multiplying for some shifts, adds and
overheads.

<p>A mod 2^N+1 product can be formed with a normal
NxN-&gt;2N bit multiply plus a subtraction, so an FFT
and Toom-3 etc can be compared directly.  A k=4 FFT at
O(N^1.333) can be expected to be the first faster than Toom-3 at
O(N^1.465).  In practice this is what's found, with
<code>MUL_FFT_MODF_THRESHOLD</code> and <code>SQR_FFT_MODF_THRESHOLD</code> being between
300 and 1000 limbs, depending on the CPU.  So far it's been found that only
very large FFTs recurse into pointwise multiplies above these sizes.

<p>When an FFT is to give a full product, the change of N to 2N
doesn't alter the theoretical complexity for a given k, but for the
purposes of considering where an FFT might be first used it can be assumed
that the FFT is recursing into a normal multiply and that on that basis it's
doing 2^k recursed multiplies each 1/2^(k-2) the size of
the inputs, making it O(N^(k/(k-2))).  This would mean
k=7 at O(N^1.4) would be the first FFT faster than Toom-3. 
In practice <code>MUL_FFT_THRESHOLD</code> and <code>SQR_FFT_THRESHOLD</code> have been
found to be in the k=8 range, somewhere between 3000 and 10000 limbs.

<p>The way N is split into 2^k pieces and then 2M+k+3 is
rounded up to a multiple of 2^k and <code>mp_bits_per_limb</code> means that
when 2^k&gt;=<code>mp_bits_per_limb</code> the effective N is a
multiple of 2^(2k-1) bits.  The +k+3 means some values of
N just under such a multiple will be rounded to the next.  The
complexity calculations above assume that a favourable size is used, meaning
one which isn't padded through rounding, and it's also assumed that the extra
+k+3 bits are negligible at typical FFT sizes.

<p>The practical effect of the 2^(2k-1) constraint is to introduce a
step-effect into measured speeds.  For example k=8 will round N
up to a multiple of 32768 bits, so for a 32-bit limb there'll be 512 limb
groups of sizes for which <code>mpn_mul_n</code> runs at the same speed.  Or for
k=9 groups of 2048 limbs, k=10 groups of 8192 limbs, etc.  In
practice it's been found each k is used at quite small multiples of its
size constraint and so the step effect is quite noticeable in a time versus
size graph.

<p>The threshold determinations currently measure at the mid-points of size
steps, but this is sub-optimal since at the start of a new step it can happen
that it's better to go back to the previous k for a while.  Something
more sophisticated for <code>MUL_FFT_TABLE</code> and <code>SQR_FFT_TABLE</code> will be
needed.

<p><hr>
Node:<a name="Other%20Multiplication">Other Multiplication</a>,
Previous:<a rel=previous accesskey=p href="#FFT%20Multiplication">FFT Multiplication</a>,
Up:<a rel=up accesskey=u href="#Multiplication%20Algorithms">Multiplication Algorithms</a>
<br>

<h4>Other Multiplication</h4>

<p>The 3-way Toom-Cook algorithm described above (see <a href="#Toom-Cook%203-Way%20Multiplication">Toom-Cook 3-Way Multiplication</a>) generalizes to split into an arbitrary number of pieces, as
per Knuth section 4.3.3 algorithm C.  This is not currently used, though it's
possible a Toom-4 might fit in between Toom-3 and the FFTs.  The notes here
are merely for interest.

<p>In general a split into r+1 pieces is made, and evaluations and
pointwise multiplications done at 2*r+1 points.  A 4-way split does 7
pointwise multiplies, 5-way does 9, etc.  Asymptotically an (r+1)-way
algorithm is O(N^(log(2*r+1)/log(r+1))).  Only
the pointwise multiplications count towards big-O complexity, but the
time spent in the evaluate and interpolate stages grows with r and has
a significant practical impact, with the asymptotic advantage of each r
realized only at bigger and bigger sizes.  The overheads grow as
O(N*r), whereas in an r=2^k FFT they grow only as O(N*log(r)).

<p>Knuth algorithm C evaluates at points 0,1,2,<small>...</small>,2*r, but exercise 4
uses -r,<small>...</small>,0,<small>...</small>,r and the latter saves some small
multiplies in the evaluate stage (or rather trades them for additions), and
has a further saving of nearly half the interpolate steps.  The idea is to
separate odd and even final coefficients and then perform algorithm C steps C7
and C8 on them separately.  The divisors at step C7 become j^2 and the
multipliers at C8 become 2*t*j-j^2.

<p>Splitting odd and even parts through positive and negative points can be
thought of as using -1 as a square root of unity.  If a 4th root of
unity was available then a further split and speedup would be possible, but no
such root exists for plain integers.  Going to complex integers with
i=sqrt(-1) doesn't help, essentially because in cartesian
form it takes three real multiplies to do a complex multiply.  The existence
of 2^k'th roots of unity in a suitable ring or field lets the fast
fourier transform keep splitting and get to O(N*log(r)).

<p>Floating point FFTs use complex numbers approximating Nth roots of unity. 
Some processors have special support for such FFTs.  But these are not used in
GMP since it's very difficult to guarantee an exact result (to some number of
bits).  An occasional difference of 1 in the last bit might not matter to a
typical signal processing algorithm, but is of course of vital importance to
GMP.

<p><hr>
Node:<a name="Division%20Algorithms">Division Algorithms</a>,
Next:<a rel=next accesskey=n href="#Greatest%20Common%20Divisor%20Algorithms">Greatest Common Divisor Algorithms</a>,
Previous:<a rel=previous accesskey=p href="#Multiplication%20Algorithms">Multiplication Algorithms</a>,
Up:<a rel=up accesskey=u href="#Algorithms">Algorithms</a>
<br>

<h3>Division Algorithms</h3>

<ul>
<li><a accesskey=1 href="#Single%20Limb%20Division">Single Limb Division</a>: 
<li><a accesskey=2 href="#Basecase%20Division">Basecase Division</a>: 
<li><a accesskey=3 href="#Divide%20and%20Conquer%20Division">Divide and Conquer Division</a>: 
<li><a accesskey=4 href="#Exact%20Division">Exact Division</a>: 
<li><a accesskey=5 href="#Exact%20Remainder">Exact Remainder</a>: 
<li><a accesskey=6 href="#Small%20Quotient%20Division">Small Quotient Division</a>: 
</ul>

<p><hr>
Node:<a name="Single%20Limb%20Division">Single Limb Division</a>,
Next:<a rel=next accesskey=n href="#Basecase%20Division">Basecase Division</a>,
Previous:<a rel=previous accesskey=p href="#Division%20Algorithms">Division Algorithms</a>,
Up:<a rel=up accesskey=u href="#Division%20Algorithms">Division Algorithms</a>
<br>

<h4>Single Limb Division</h4>

<p>Nx1 division is implemented using repeated 2x1 divisions from
high to low, either with a hardware divide instruction or a multiplication by
inverse, whichever is best on a given CPU.

<p>The multiply by inverse follows section 8 of "Division by Invariant Integers
using Multiplication" by Granlund and Montgomery (see <a href="#References">References</a>) and is
implemented as <code>udiv_qrnnd_preinv</code> in <code>gmp-impl.h</code>.  The idea is to
have a fixed-point approximation to 1/d (see <code>invert_limb</code>) and
then multiply by the high limb (plus one bit) of the dividend to get a
quotient q.  With d normalized (high bit set), q is no
more than 1 too small.  Subtracting q*d from the dividend gives a
remainder, and reveals whether q or q-1 is correct.

<p>The result is a division done with two multiplications and four or five
arithmetic operations.  On CPUs with low latency multipliers this can be much
faster than a hardware divide, though the cost of calculating the inverse at
the start may mean it's only better on inputs bigger than say 4 or 5 limbs.

<p>When a divisor must be normalized, either for the generic C
<code>__udiv_qrnnd_c</code> or the multiply by inverse, the division performed is
actually a*2^k by d*2^k where a is the dividend and
k is the power necessary to have the high bit of d*2^k set. 
The bit shifts for the dividend are usually accomplished "on the fly"
meaning by extracting the appropriate bits at each step.  Done this way the
quotient limbs come out aligned ready to store.  When only the remainder is
wanted, an alternative is to take the dividend limbs unshifted and calculate
r = a mod d*2^k followed by an extra final step r*2^k mod d*2^k.  This can help on CPUs with poor bit shifts or
few registers.

<p>The multiply by inverse can be done two limbs at a time.  The calculation is
basically the same, but the inverse is two limbs and the divisor treated as if
padded with a low zero limb.  This means more work, since the inverse will
need a 2x2 multiply, but the four 1x1s to do that are
independent and can therefore be done partly or wholly in parallel.  Likewise
for a 2x1 calculating q*d.  The net effect is to process two
limbs with roughly the same two multiplies worth of latency that one limb at a
time gives.  This extends to 3 or 4 limbs at a time, though the extra work to
apply the inverse will almost certainly soon reach the limits of multiplier
throughput.

<p>A similar approach in reverse can be taken to process just half a limb at a
time if the divisor is only a half limb.  In this case the 1x1 multiply
for the inverse effectively becomes two (1/2)x1 for each
limb, which can be a saving on CPUs with a fast half limb multiply, or in fact
if the only multiply is a half limb, and especially if it's not pipelined.

<p><hr>
Node:<a name="Basecase%20Division">Basecase Division</a>,
Next:<a rel=next accesskey=n href="#Divide%20and%20Conquer%20Division">Divide and Conquer Division</a>,
Previous:<a rel=previous accesskey=p href="#Single%20Limb%20Division">Single Limb Division</a>,
Up:<a rel=up accesskey=u href="#Division%20Algorithms">Division Algorithms</a>
<br>

<h4>Basecase Division</h4>

<p>Basecase NxM division is like long division done by hand, but in base
2^mp_bits_per_limb.  See Knuth
section 4.3.1 algorithm D, and <code>mpn/generic/sb_divrem_mn.c</code>.

<p>Briefly stated, while the dividend remains larger than the divisor, a high
quotient limb is formed and the Nx1 product q*d subtracted at
the top end of the dividend.  With a normalized divisor (most significant bit
set), each quotient limb can be formed with a 2x1 division and a
1x1 multiplication plus some subtractions.  The 2x1 division is
by the high limb of the divisor and is done either with a hardware divide or a
multiply by inverse (the same as in <a href="#Single%20Limb%20Division">Single Limb Division</a>) whichever is
faster.  Such a quotient is sometimes one too big, requiring an addback of the
divisor, but that happens rarely.

<p>With Q=N-M being the number of quotient limbs, this is an
O(Q*M) algorithm and will run at a speed similar to a basecase
QxM multiplication, differing in fact only in the extra multiply and
divide for each of the Q quotient limbs.

<p><hr>
Node:<a name="Divide%20and%20Conquer%20Division">Divide and Conquer Division</a>,
Next:<a rel=next accesskey=n href="#Exact%20Division">Exact Division</a>,
Previous:<a rel=previous accesskey=p href="#Basecase%20Division">Basecase Division</a>,
Up:<a rel=up accesskey=u href="#Division%20Algorithms">Division Algorithms</a>
<br>

<h4>Divide and Conquer Division</h4>

<p>For divisors larger than <code>DIV_DC_THRESHOLD</code>, division is done by dividing. 
Or to be precise by a recursive divide and conquer algorithm based on work by
Moenck and Borodin, Jebelean, and Burnikel and Ziegler (see <a href="#References">References</a>).

<p>The algorithm consists essentially of recognising that a 2NxN division
can be done with the basecase division algorithm (see <a href="#Basecase%20Division">Basecase Division</a>),
but using N/2 limbs as a base, not just a single limb.  This way the
multiplications that arise are (N/2)x(N/2) and can take advantage of
Karatsuba and higher multiplication algorithms (see <a href="#Multiplication%20Algorithms">Multiplication Algorithms</a>).  The "digits" of the quotient are formed by recursive
Nx(N/2) divisions.

<p>If the (N/2)x(N/2) multiplies are done with a basecase multiplication
then the work is about the same as a basecase division, but with more function
call overheads and with some subtractions separated from the multiplies. 
These overheads mean that it's only when N/2 is above
<code>MUL_KARATSUBA_THRESHOLD</code> that divide and conquer is of use.

<p><code>DIV_DC_THRESHOLD</code> is based on the divisor size N, so it will be somewhere
above twice <code>MUL_KARATSUBA_THRESHOLD</code>, but how much above depends on the
CPU.  An optimized <code>mpn_mul_basecase</code> can lower <code>DIV_DC_THRESHOLD</code> a
little by offering a ready-made advantage over repeated <code>mpn_submul_1</code>
calls.

<p>Divide and conquer is asymptotically O(M(N)*log(N)) where
M(N) is the time for an NxN multiplication done with FFTs.  The
actual time is a sum over multiplications of the recursed sizes, as can be
seen near the end of section 2.2 of Burnikel and Ziegler.  For example, within
the Toom-3 range, divide and conquer is 2.63*M(N).  With higher
algorithms the M(N) term improves and the multiplier tends to log(N).  In practice, at moderate to large sizes, a 2NxN division
is about 2 to 4 times slower than an NxN multiplication.

<p>Newton's method used for division is asymptotically O(M(N)) and should
therefore be superior to divide and conquer, but it's believed this would only
be for large to very large N.

<p><hr>
Node:<a name="Exact%20Division">Exact Division</a>,
Next:<a rel=next accesskey=n href="#Exact%20Remainder">Exact Remainder</a>,
Previous:<a rel=previous accesskey=p href="#Divide%20and%20Conquer%20Division">Divide and Conquer Division</a>,
Up:<a rel=up accesskey=u href="#Division%20Algorithms">Division Algorithms</a>
<br>

<h4>Exact Division</h4>

<p>A so-called exact division is when the dividend is known to be an exact
multiple of the divisor.  Jebelean's exact division algorithm uses this
knowledge to make some significant optimizations (see <a href="#References">References</a>).

<p>The idea can be illustrated in decimal for example with 368154 divided by
543.  Because the low digit of the dividend is 4, the low digit of the
quotient must be 8.  This is arrived at from 4*7 mod 10, using the fact 7 is the modular inverse of 3 (the low digit of
the divisor), since 3*7
== 1 mod 10.  So 8*543=4344 can be
subtracted from the dividend leaving 363810.  Notice the low digit has become
zero.

<p>The procedure is repeated at the second digit, with the next quotient digit 7
(7 == 1*7 mod 10), subtracting
7*543=3801, leaving 325800.  And finally at
the third digit with quotient digit 6 (8*7
mod 10), subtracting 6*543=3258 leaving 0. 
So the quotient is 678.

<p>Notice however that the multiplies and subtractions don't need to extend past
the low three digits of the dividend, since that's enough to determine the
three quotient digits.  For the last quotient digit no subtraction is needed
at all.  On a 2NxN division like this one, only about half the work of
a normal basecase division is necessary.

<p>For an NxM exact division producing Q=N-M quotient limbs, the
saving over a normal basecase division is in two parts.  Firstly, each of the
Q quotient limbs needs only one multiply, not a 2x1 divide and
multiply.  Secondly, the crossproducts are reduced when Q&gt;M to
Q*M-M*(M+1)/2, or when Q&lt;=M to Q*(Q-1)/2.  Notice the savings are complementary.  If Q is big then many
divisions are saved, or if Q is small then the crossproducts reduce to a small
number.

<p>The modular inverse used is calculated efficiently by <code>modlimb_invert</code> in
<code>gmp-impl.h</code>.  This does four multiplies for a 32-bit limb, or six for a
64-bit limb.  <code>tune/modlinv.c</code> has some alternate implementations that
might suit processors better at bit twiddling than multiplying.

<p>The sub-quadratic exact division described by Jebelean in "Exact Division
with Karatsuba Complexity" is not currently implemented.  It uses a
rearrangement similar to the divide and conquer for normal division
(see <a href="#Divide%20and%20Conquer%20Division">Divide and Conquer Division</a>), but operating from low to high.  A
further possibility not currently implemented is "Bidirectional Exact Integer
Division" by Krandick and Jebelean which forms quotient limbs from both the
high and low ends of the dividend, and can halve once more the number of
crossproducts needed in a 2NxN division.

<p>A special case exact division by 3 exists in <code>mpn_divexact_by3</code>,
supporting Toom-3 multiplication and <code>mpq</code> canonicalizations.  It forms
quotient digits with a multiply by the modular inverse of 3 (which is
<code>0xAA..AAB</code>) and uses two comparisons to determine a borrow for the next
limb.  The multiplications don't need to be on the dependent chain, as long as
the effect of the borrows is applied.  Only a few optimized assembler
implementations currently exist.

<p><hr>
Node:<a name="Exact%20Remainder">Exact Remainder</a>,
Next:<a rel=next accesskey=n href="#Small%20Quotient%20Division">Small Quotient Division</a>,
Previous:<a rel=previous accesskey=p href="#Exact%20Division">Exact Division</a>,
Up:<a rel=up accesskey=u href="#Division%20Algorithms">Division Algorithms</a>
<br>

<h4>Exact Remainder</h4>

<p>If the exact division algorithm is done with a full subtraction at each stage
and the dividend isn't a multiple of the divisor, then low zero limbs are
produced but with a remainder in the high limbs.  For dividend a,
divisor d, quotient q, and b = 2^mp_bits_per_limb, then this
remainder r is of the form

<br><pre>a = q*d + r*b^n
</pre>

<p>n represents the number of zero limbs produced by the subtractions,
that being the number of limbs produced for q.  r will be in the
range 0&lt;=r&lt;d and can be viewed as a remainder, but one shifted up by
a factor of b^n.

<p>Carrying out full subtractions at each stage means the same number of cross
products must be done as a normal division, but there's still some single limb
divisions saved.  When d is a single limb some simplifications arise,
providing good speedups on a number of processors.

<p><code>mpn_bdivmod</code>, <code>mpn_divexact_by3</code>, <code>mpn_modexact_1_odd</code> and the
<code>redc</code> function in <code>mpz_powm</code> differ subtly in how they return
r, leading to some negations in the above formula, but all are
essentially the same.

<p>Clearly r is zero when a is a multiple of d, and this
leads to divisibility or congruence tests which are potentially more efficient
than a normal division.

<p>The factor of b^n on r can be ignored in a GCD when d is
odd, hence the use of <code>mpn_bdivmod</code> in <code>mpn_gcd</code>, and the use of
<code>mpn_modexact_1_odd</code> by <code>mpn_gcd_1</code> and <code>mpz_kronecker_ui</code> etc
(see <a href="#Greatest%20Common%20Divisor%20Algorithms">Greatest Common Divisor Algorithms</a>).

<p>Montgomery's REDC method for modular multiplications uses operands of the form
of x*b^-n and y*b^-n and on calculating (x*b^-n)*(y*b^-n) uses the factor of b^n in the exact
remainder to reach a product in the same form (x*y)*b^-n
(see <a href="#Modular%20Powering%20Algorithm">Modular Powering Algorithm</a>).

<p>Notice that r generally gives no useful information about the ordinary
remainder a mod d since b^n mod d could be anything.  If
however b^n == 1 mod d, then r is the negative of the
ordinary remainder.  This occurs whenever d is a factor of
b^n-1, as for example with 3 in <code>mpn_divexact_by3</code>.  Other such
factors include 5, 17 and 257, but no particular use has been found for this.

<p><hr>
Node:<a name="Small%20Quotient%20Division">Small Quotient Division</a>,
Previous:<a rel=previous accesskey=p href="#Exact%20Remainder">Exact Remainder</a>,
Up:<a rel=up accesskey=u href="#Division%20Algorithms">Division Algorithms</a>
<br>

<h4>Small Quotient Division</h4>

<p>An NxM division where the number of quotient limbs Q=N-M is
small can be optimized somewhat.

<p>An ordinary basecase division normalizes the divisor by shifting it to make
the high bit set, shifting the dividend accordingly, and shifting the
remainder back down at the end of the calculation.  This is wasteful if only a
few quotient limbs are to be formed.  Instead a division of just the top
2*Q limbs of the dividend by the top Q limbs of the divisor can be
used to form a trial quotient.  This requires only those limbs normalized, not
the whole of the divisor and dividend.

<p>A multiply and subtract then applies the trial quotient to the M-Q
unused limbs of the divisor and N-Q dividend limbs (which includes Q
limbs remaining from the trial quotient division).  The starting trial
quotient can be 1 or 2 too big, but all cases of 2 too big and most cases of 1
too big are detected by first comparing the most significant limbs that will
arise from the subtraction.  An addback is done if the quotient still turns
out to be 1 too big.

<p>This whole procedure is essentially the same as one step of the basecase
algorithm done in a Q limb base, though with the trial quotient test done only
with the high limbs, not an entire Q limb "digit" product.  The correctness
of this weaker test can be established by following the argument of Knuth
section 4.3.1 exercise 20 but with the v2*q&gt;b*r+u2 condition appropriately relaxed.

<p><hr>
Node:<a name="Greatest%20Common%20Divisor%20Algorithms">Greatest Common Divisor Algorithms</a>,
Next:<a rel=next accesskey=n href="#Powering%20Algorithms">Powering Algorithms</a>,
Previous:<a rel=previous accesskey=p href="#Division%20Algorithms">Division Algorithms</a>,
Up:<a rel=up accesskey=u href="#Algorithms">Algorithms</a>
<br>

<h3>Greatest Common Divisor</h3>

<ul>
<li><a accesskey=1 href="#Binary%20GCD">Binary GCD</a>: 
<li><a accesskey=2 href="#Accelerated%20GCD">Accelerated GCD</a>: 
<li><a accesskey=3 href="#Extended%20GCD">Extended GCD</a>: 
<li><a accesskey=4 href="#Jacobi%20Symbol">Jacobi Symbol</a>: 
</ul>

<p><hr>
Node:<a name="Binary%20GCD">Binary GCD</a>,
Next:<a rel=next accesskey=n href="#Accelerated%20GCD">Accelerated GCD</a>,
Previous:<a rel=previous accesskey=p href="#Greatest%20Common%20Divisor%20Algorithms">Greatest Common Divisor Algorithms</a>,
Up:<a rel=up accesskey=u href="#Greatest%20Common%20Divisor%20Algorithms">Greatest Common Divisor Algorithms</a>
<br>

<h4>Binary GCD</h4>

<p>At small sizes GMP uses an O(N^2) binary style GCD.  This is described
in many textbooks, for example Knuth section 4.5.2 algorithm B.  It simply
consists of successively reducing operands a and b using
gcd(a,b) = gcd(min(a,b),abs(a-b)), and also that if
a and b are first made odd then abs(a-b) is even and
factors of two can be discarded.

<p>Variants like letting a-b become negative and doing a different next
step are of interest only as far as they suit particular CPUs, since on small
operands it's machine dependent factors that determine performance.

<p>The Euclidean GCD algorithm, as per Knuth algorithms E and A, reduces using
a mod b but this has so far been found to be slower everywhere.  One
reason the binary method does well is that the implied quotient at each step
is usually small, so often only one or two subtractions are needed to get the
same effect as a division.  Quotients 1, 2 and 3 for example occur 67.7% of
the time, see Knuth section 4.5.3 Theorem E.

<p>When the implied quotient is large, meaning b is much smaller than
a, then a division is worthwhile.  This is the basis for the initial
a mod b reductions in <code>mpn_gcd</code> and <code>mpn_gcd_1</code> (the latter
for both Nx1 and 1x1 cases).  But after that initial reduction,
big quotients occur too rarely to make it worth checking for them.

<p><hr>
Node:<a name="Accelerated%20GCD">Accelerated GCD</a>,
Next:<a rel=next accesskey=n href="#Extended%20GCD">Extended GCD</a>,
Previous:<a rel=previous accesskey=p href="#Binary%20GCD">Binary GCD</a>,
Up:<a rel=up accesskey=u href="#Greatest%20Common%20Divisor%20Algorithms">Greatest Common Divisor Algorithms</a>
<br>

<h4>Accelerated GCD</h4>

<p>For sizes above <code>GCD_ACCEL_THRESHOLD</code>, GMP uses the Accelerated GCD
algorithm described independently by Weber and Jebelean (the latter as the
"Generalized Binary" algorithm), see <a href="#References">References</a>.  This algorithm is
still O(N^2), but is much faster than the binary algorithm since it
does fewer multi-precision operations.  It consists of alternating the
k-ary reduction by Sorenson, and a "dmod" exact remainder reduction.

<p>For operands u and v the k-ary reduction replaces
u with n*v-d*u where n and d are single limb
values chosen to give two trailing zero limbs on that value, which can be
stripped.  n and d are calculated using an algorithm similar to
half of a two limb GCD (see <code>find_a</code> in <code>mpn/generic/gcd.c</code>).

<p>When u and v differ in size by more than a certain number of
bits, a dmod is performed to zero out bits at the low end of the larger.  It
consists of an exact remainder style division applied to an appropriate number
of bits (see <a href="#Exact%20Division">Exact Division</a>, and see <a href="#Exact%20Remainder">Exact Remainder</a>).  This is faster
than a k-ary reduction but useful only when the operands differ in
size.  There's a dmod after each k-ary reduction, and if the dmod
leaves the operands still differing in size then it's repeated.

<p>The k-ary reduction step can introduce spurious factors into the GCD
calculated, and these are eliminated at the end by taking GCDs with the
original inputs gcd(u,gcd(v,g)) using the binary algorithm. 
Since g is almost always small this takes very little time.

<p>At small sizes the algorithm needs a good implementation of <code>find_a</code>.  At
larger sizes it's dominated by <code>mpn_addmul_1</code> applying n and
d.

<p><hr>
Node:<a name="Extended%20GCD">Extended GCD</a>,
Next:<a rel=next accesskey=n href="#Jacobi%20Symbol">Jacobi Symbol</a>,
Previous:<a rel=previous accesskey=p href="#Accelerated%20GCD">Accelerated GCD</a>,
Up:<a rel=up accesskey=u href="#Greatest%20Common%20Divisor%20Algorithms">Greatest Common Divisor Algorithms</a>
<br>

<h4>Extended GCD</h4>

<p>The extended GCD calculates gcd(a,b) and also cofactors x and
y satisfying a*x+b*y=gcd(a,b).  Lehmer's
multi-step improvement of the extended Euclidean algorithm is used.  See Knuth
section 4.5.2 algorithm L, and <code>mpn/generic/gcdext.c</code>.  This is an
O(N^2) algorithm.

<p>The multipliers at each step are found using single limb calculations for
sizes up to <code>GCDEXT_THRESHOLD</code>, or double limb calculations above that. 
The single limb code is faster but doesn't produce full-limb multipliers,
hence not making full use of the <code>mpn_addmul_1</code> calls.

<p>When a CPU has a data-dependent multiplier, meaning one which is faster on
operands with fewer bits, the extra work in the double-limb calculation might
only save some looping overheads, leading to a large <code>GCDEXT_THRESHOLD</code>.

<p>Currently the single limb calculation doesn't optimize for the small quotients
that often occur, and this can lead to unusually low values of
<code>GCDEXT_THRESHOLD</code>, depending on the CPU.

<p>An analysis of double-limb calculations can be found in "A Double-Digit
Lehmer-Euclid Algorithm" by Jebelean (see <a href="#References">References</a>).  The code in GMP
was developed independently.

<p>It should be noted that when a double limb calculation is used, it's used for
the whole of that GCD, it doesn't fall back to single limb part way through. 
This is because as the algorithm proceeds, the inputs a and b
are reduced, but the cofactors x and y grow, so the multipliers
at each step are applied to a roughly constant total number of limbs.

<p><hr>
Node:<a name="Jacobi%20Symbol">Jacobi Symbol</a>,
Previous:<a rel=previous accesskey=p href="#Extended%20GCD">Extended GCD</a>,
Up:<a rel=up accesskey=u href="#Greatest%20Common%20Divisor%20Algorithms">Greatest Common Divisor Algorithms</a>
<br>

<h4>Jacobi Symbol</h4>

<p><code>mpz_jacobi</code> and <code>mpz_kronecker</code> are currently implemented with a
simple binary algorithm similar to that described for the GCDs (see <a href="#Binary%20GCD">Binary GCD</a>).  They're not very fast when both inputs are large.  Lehmer's multi-step
improvement or a binary based multi-step algorithm is likely to be better.

<p>When one operand fits a single limb, and that includes <code>mpz_kronecker_ui</code>
and friends, an initial reduction is done with either <code>mpn_mod_1</code> or
<code>mpn_modexact_1_odd</code>, followed by the binary algorithm on a single limb. 
The binary algorithm is well suited to a single limb, and the whole
calculation in this case is quite efficient.

<p>In all the routines sign changes for the result are accumulated using some bit
twiddling, avoiding table lookups or conditional jumps.

<p><hr>
Node:<a name="Powering%20Algorithms">Powering Algorithms</a>,
Next:<a rel=next accesskey=n href="#Root%20Extraction%20Algorithms">Root Extraction Algorithms</a>,
Previous:<a rel=previous accesskey=p href="#Greatest%20Common%20Divisor%20Algorithms">Greatest Common Divisor Algorithms</a>,
Up:<a rel=up accesskey=u href="#Algorithms">Algorithms</a>
<br>

<h3>Powering Algorithms</h3>

<ul>
<li><a accesskey=1 href="#Normal%20Powering%20Algorithm">Normal Powering Algorithm</a>: 
<li><a accesskey=2 href="#Modular%20Powering%20Algorithm">Modular Powering Algorithm</a>: 
</ul>

<p><hr>
Node:<a name="Normal%20Powering%20Algorithm">Normal Powering Algorithm</a>,
Next:<a rel=next accesskey=n href="#Modular%20Powering%20Algorithm">Modular Powering Algorithm</a>,
Previous:<a rel=previous accesskey=p href="#Powering%20Algorithms">Powering Algorithms</a>,
Up:<a rel=up accesskey=u href="#Powering%20Algorithms">Powering Algorithms</a>
<br>

<h4>Normal Powering</h4>

<p>Normal <code>mpz</code> or <code>mpf</code> powering uses a simple binary algorithm,
successively squaring and then multiplying by the base when a 1 bit is seen in
the exponent, as per Knuth section 4.6.3.  The "left to right"
variant described there is used rather than algorithm A, since it's just as
easy and can be done with somewhat less temporary memory.

<p><hr>
Node:<a name="Modular%20Powering%20Algorithm">Modular Powering Algorithm</a>,
Previous:<a rel=previous accesskey=p href="#Normal%20Powering%20Algorithm">Normal Powering Algorithm</a>,
Up:<a rel=up accesskey=u href="#Powering%20Algorithms">Powering Algorithms</a>
<br>

<h4>Modular Powering</h4>

<p>Modular powering is implemented using a 2^k-ary sliding window
algorithm, as per "Handbook of Applied Cryptography" algorithm 14.85
(see <a href="#References">References</a>).  k is chosen according to the size of the
exponent.  Larger exponents use larger values of k, the choice being
made to minimize the average number of multiplications that must supplement
the squaring.

<p>The modular multiplies and squares use either a simple division or the REDC
method by Montgomery (see <a href="#References">References</a>).  REDC is a little faster,
essentially saving N single limb divisions in a fashion similar to an exact
remainder (see <a href="#Exact%20Remainder">Exact Remainder</a>).  The current REDC has some limitations. 
It's only O(N^2) so above <code>POWM_THRESHOLD</code> division becomes faster
and is used.  It doesn't attempt to detect small bases, but rather always uses
a REDC form, which is usually a full size operand.  And lastly it's only
applied to odd moduli.

<p><hr>
Node:<a name="Root%20Extraction%20Algorithms">Root Extraction Algorithms</a>,
Next:<a rel=next accesskey=n href="#Radix%20Conversion%20Algorithms">Radix Conversion Algorithms</a>,
Previous:<a rel=previous accesskey=p href="#Powering%20Algorithms">Powering Algorithms</a>,
Up:<a rel=up accesskey=u href="#Algorithms">Algorithms</a>
<br>

<h3>Root Extraction Algorithms</h3>

<ul>
<li><a accesskey=1 href="#Square%20Root%20Algorithm">Square Root Algorithm</a>: 
<li><a accesskey=2 href="#Nth%20Root%20Algorithm">Nth Root Algorithm</a>: 
<li><a accesskey=3 href="#Perfect%20Square%20Algorithm">Perfect Square Algorithm</a>: 
<li><a accesskey=4 href="#Perfect%20Power%20Algorithm">Perfect Power Algorithm</a>: 
</ul>

<p><hr>
Node:<a name="Square%20Root%20Algorithm">Square Root Algorithm</a>,
Next:<a rel=next accesskey=n href="#Nth%20Root%20Algorithm">Nth Root Algorithm</a>,
Previous:<a rel=previous accesskey=p href="#Root%20Extraction%20Algorithms">Root Extraction Algorithms</a>,
Up:<a rel=up accesskey=u href="#Root%20Extraction%20Algorithms">Root Extraction Algorithms</a>
<br>

<h4>Square Root</h4>

<p>Square roots are taken using the "Karatsuba Square Root" algorithm by Paul
Zimmermann (see <a href="#References">References</a>).  This is expressed in a divide and conquer
form, but as noted in the paper it can also be viewed as a discrete variant of
Newton's method.

<p>In the Karatsuba multiplication range this is an O(1.5*M(N/2)) algorithm, where M(n) is the time to multiply
two numbers of n limbs.  In the FFT multiplication range this grows to
a bound of O(6*M(N/2)).  In practice a factor of about 1.5 to
1.8 is found in the Karatsuba and Toom-3 ranges, growing to 2 or 3 in the FFT
range.

<p>The algorithm does all its calculations in integers and the resulting
<code>mpn_sqrtrem</code> is used for both <code>mpz_sqrt</code> and <code>mpf_sqrt</code>. 
The extended precision given by <code>mpf_sqrt_ui</code> is obtained by
padding with zero limbs.

<p><hr>
Node:<a name="Nth%20Root%20Algorithm">Nth Root Algorithm</a>,
Next:<a rel=next accesskey=n href="#Perfect%20Square%20Algorithm">Perfect Square Algorithm</a>,
Previous:<a rel=previous accesskey=p href="#Square%20Root%20Algorithm">Square Root Algorithm</a>,
Up:<a rel=up accesskey=u href="#Root%20Extraction%20Algorithms">Root Extraction Algorithms</a>
<br>

<h4>Nth Root</h4>

<p>Integer Nth roots are taken using Newton's method with the following
iteration, where A is the input and n is the root to be taken.

<br><pre>         1         A
a[i+1] = - * ( --------- + (n-1)*a[i] )
         n     a[i]^(n-1)
</pre>

<p>The initial approximation a[1] is generated bitwise by successively
powering a trial root with or without new 1 bits, aiming to be just above the
true root.  The iteration converges quadratically when started from a good
approximation.  When n is large more initial bits are needed to get
good convergence.  The current implementation is not particularly well
optimized.

<p><hr>
Node:<a name="Perfect%20Square%20Algorithm">Perfect Square Algorithm</a>,
Next:<a rel=next accesskey=n href="#Perfect%20Power%20Algorithm">Perfect Power Algorithm</a>,
Previous:<a rel=previous accesskey=p href="#Nth%20Root%20Algorithm">Nth Root Algorithm</a>,
Up:<a rel=up accesskey=u href="#Root%20Extraction%20Algorithms">Root Extraction Algorithms</a>
<br>

<h4>Perfect Square</h4>

<p><code>mpz_perfect_square_p</code> is able to quickly exclude most non-squares by
checking whether the input is a quadratic residue modulo some small integers.

<p>The first test is modulo 256 which means simply examining the least
significant byte.  Only 44 different values occur as the low byte of a square,
so 82.8% of non-squares can be immediately excluded.  Similar tests modulo
primes from 3 to 29 exclude 99.5% of those remaining, or if a limb is 64 bits
then primes up to 53 are used, excluding 99.99%.  A single Nx1
remainder using <code>PP</code> from <code>gmp-impl.h</code> quickly gives all these
remainders.

<p>A square root must still be taken for any value that passes the residue tests,
to verify it's really a square and not one of the 0.086% (or 0.000156% for 64
bits) non-squares that get through.  See <a href="#Square%20Root%20Algorithm">Square Root Algorithm</a>.

<p><hr>
Node:<a name="Perfect%20Power%20Algorithm">Perfect Power Algorithm</a>,
Previous:<a rel=previous accesskey=p href="#Perfect%20Square%20Algorithm">Perfect Square Algorithm</a>,
Up:<a rel=up accesskey=u href="#Root%20Extraction%20Algorithms">Root Extraction Algorithms</a>
<br>

<h4>Perfect Power</h4>

<p>Detecting perfect powers is required by some factorization algorithms. 
Currently <code>mpz_perfect_power_p</code> is implemented using repeated Nth root
extractions, though naturally only prime roots need to be considered. 
(See <a href="#Nth%20Root%20Algorithm">Nth Root Algorithm</a>.)

<p>If a prime divisor p with multiplicity e can be found, then only
roots which are divisors of e need to be considered, much reducing the
work necessary.  To this end divisibility by a set of small primes is checked.

<p><hr>
Node:<a name="Radix%20Conversion%20Algorithms">Radix Conversion Algorithms</a>,
Next:<a rel=next accesskey=n href="#Other%20Algorithms">Other Algorithms</a>,
Previous:<a rel=previous accesskey=p href="#Root%20Extraction%20Algorithms">Root Extraction Algorithms</a>,
Up:<a rel=up accesskey=u href="#Algorithms">Algorithms</a>
<br>

<h3>Radix Conversion</h3>

<p>Radix conversions are less important than other algorithms.  A program
dominated by conversions should probably use a different data representation.

<ul>
<li><a accesskey=1 href="#Binary%20to%20Radix">Binary to Radix</a>: 
<li><a accesskey=2 href="#Radix%20to%20Binary">Radix to Binary</a>: 
</ul>

<p><hr>
Node:<a name="Binary%20to%20Radix">Binary to Radix</a>,
Next:<a rel=next accesskey=n href="#Radix%20to%20Binary">Radix to Binary</a>,
Previous:<a rel=previous accesskey=p href="#Radix%20Conversion%20Algorithms">Radix Conversion Algorithms</a>,
Up:<a rel=up accesskey=u href="#Radix%20Conversion%20Algorithms">Radix Conversion Algorithms</a>
<br>

<h4>Binary to Radix</h4>

<p>Conversions from binary to a power-of-2 radix use a simple and fast
O(N) bit extraction algorithm.

<p>Conversions from binary to other radices use one of two algorithms.  Sizes
below <code>GET_STR_PRECOMPUTE_THRESHOLD</code> use a basic O(N^2) method. 
Repeated divisions by b^n are made, where b is the radix and
n is the biggest power that fits in a limb.  But instead of simply
using the remainder r from such divisions, an extra divide step is done
to give a fractional limb representing r/b^n.  The digits of r
can then be extracted using multiplications by b rather than divisions. 
Special case code is provided for decimal, allowing multiplications by 10 to
optimize to shifts and adds.

<p>Above <code>GET_STR_PRECOMPUTE_THRESHOLD</code> a sub-quadratic algorithm is used. 
For an input t, powers b^(n*2^i) of the radix are
calculated, until a power between t and sqrt(t) is
reached.  t is then divided by that largest power, giving a quotient
which is the digits above that power, and a remainder which is those below. 
These two parts are in turn divided by the second highest power, and so on
recursively.  When a piece has been divided down to less than
<code>GET_STR_DC_THRESHOLD</code> limbs, the basecase algorithm described above is
used.

<p>The advantage of this algorithm is that big divisions can make use of the
sub-quadratic divide and conquer division (see <a href="#Divide%20and%20Conquer%20Division">Divide and Conquer Division</a>), and big divisions tend to have less overheads than lots of
separate single limb divisions anyway.  But in any case the cost of
calculating the powers b^(n*2^i) must first be overcome.

<p><code>GET_STR_PRECOMPUTE_THRESHOLD</code> and <code>GET_STR_DC_THRESHOLD</code> represent
the same basic thing, the point where it becomes worth doing a big division to
cut the input in half.  <code>GET_STR_PRECOMPUTE_THRESHOLD</code> includes the cost
of calculating the radix power required, whereas <code>GET_STR_DC_THRESHOLD</code>
assumes that's already available, which is the case when recursing.

<p>Since the base case produces digits from least to most significant but they
want to be stored from most to least, it's necessary to calculate in advance
how many digits there will be, or at least be sure not to underestimate that. 
For GMP the number of input bits is multiplied by <code>chars_per_bit_exactly</code>
from <code>mp_bases</code>, rounding up.  The result is either correct or one too
big.

<p>Examining some of the high bits of the input could increase the chance of
getting the exact number of digits, but an exact result every time would not
be practical, since in general the difference between numbers 100<small>...</small> and
99<small>...</small> is only in the last few bits and the work to identify 99<small>...</small>
might well be almost as much as a full conversion.

<p><code>mpf_get_str</code> doesn't currently use the algorithm described here, it
multiplies or divides by a power of b to move the radix point to the
just above the highest non-zero digit (or at worst one above that location),
then multiplies by b^n to bring out digits.  This is O(N^2) and
is certainly not optimal.

<p>The r/b^n scheme described above for using multiplications to bring out
digits might be useful for more than a single limb.  Some brief experiments
with it on the base case when recursing didn't give a noticable improvement,
but perhaps that was only due to the implementation.  Something similar would
work for the sub-quadratic divisions too, though there would be the cost of
calculating a bigger radix power.

<p>Another possible improvement for the sub-quadratic part would be to arrange
for radix powers that balanced the sizes of quotient and remainder produced,
ie. the highest power would be an b^(n*k) approximately equal to
sqrt(t), not restricted to a 2^i factor.  That ought to
smooth out a graph of times against sizes, but may or may not be a net
speedup.

<p><hr>
Node:<a name="Radix%20to%20Binary">Radix to Binary</a>,
Previous:<a rel=previous accesskey=p href="#Binary%20to%20Radix">Binary to Radix</a>,
Up:<a rel=up accesskey=u href="#Radix%20Conversion%20Algorithms">Radix Conversion Algorithms</a>
<br>

<h4>Radix to Binary</h4>

<p>Conversions from a power-of-2 radix into binary use a simple and fast
O(N) bitwise concatenation algorithm.

<p>Conversions from other radices use one of two algorithms.  Sizes below
<code>SET_STR_THRESHOLD</code> use a basic O(N^2) method.  Groups of n
digits are converted to limbs, where n is the biggest power of the base
b which will fit in a limb, then those groups are accumulated into the
result by multiplying by b^n and adding.  This saves multi-precision
operations, as per Knuth section 4.4 part E (see <a href="#References">References</a>).  Some
special case code is provided for decimal, giving the compiler a chance to
optimize multiplications by 10.

<p>Above <code>SET_STR_THRESHOLD</code> a sub-quadratic algorithm is used.  First
groups of n digits are converted into limbs.  Then adjacent limbs are
combined into limb pairs with x*b^n+y, where x and y
are the limbs.  Adjacent limb pairs are combined into quads similarly with
x*b^(2n)+y.  This continues until a single block remains, that
being the result.

<p>The advantage of this method is that the multiplications for each x are
big blocks, allowing Karatsuba and higher algorithms to be used.  But the cost
of calculating the powers b^(n*2^i) must be overcome. 
<code>SET_STR_THRESHOLD</code> usually ends up quite big, around 5000 digits, and on
some processors much bigger still.

<p><code>SET_STR_THRESHOLD</code> is based on the input digits (and tuned for decimal),
though it might be better based on a limb count, so as to be independent of
the base.  But that sort of count isn't used by the base case and so would
need some sort of initial calculation or estimate.

<p>The main reason <code>SET_STR_THRESHOLD</code> is so much bigger than the
corresponding <code>GET_STR_PRECOMPUTE_THRESHOLD</code> is that <code>mpn_mul_1</code> is
much faster than <code>mpn_divrem_1</code> (often by a factor of 10, or more).

<p><hr>
Node:<a name="Other%20Algorithms">Other Algorithms</a>,
Next:<a rel=next accesskey=n href="#Assembler%20Coding">Assembler Coding</a>,
Previous:<a rel=previous accesskey=p href="#Radix%20Conversion%20Algorithms">Radix Conversion Algorithms</a>,
Up:<a rel=up accesskey=u href="#Algorithms">Algorithms</a>
<br>

<h3>Other Algorithms</h3>

<ul>
<li><a accesskey=1 href="#Factorial%20Algorithm">Factorial Algorithm</a>: 
<li><a accesskey=2 href="#Binomial%20Coefficients%20Algorithm">Binomial Coefficients Algorithm</a>: 
<li><a accesskey=3 href="#Fibonacci%20Numbers%20Algorithm">Fibonacci Numbers Algorithm</a>: 
<li><a accesskey=4 href="#Lucas%20Numbers%20Algorithm">Lucas Numbers Algorithm</a>: 
</ul>

<p><hr>
Node:<a name="Factorial%20Algorithm">Factorial Algorithm</a>,
Next:<a rel=next accesskey=n href="#Binomial%20Coefficients%20Algorithm">Binomial Coefficients Algorithm</a>,
Previous:<a rel=previous accesskey=p href="#Other%20Algorithms">Other Algorithms</a>,
Up:<a rel=up accesskey=u href="#Other%20Algorithms">Other Algorithms</a>
<br>

<h4>Factorial</h4>

<p>Factorials n! are calculated by a simple product from 1 to
n, but arranged into certain sub-products.

<p>First as many factors as fit in a limb are accumulated, then two of those
multiplied to give a 2-limb product.  When two 2-limb products are ready
they're multiplied to a 4-limb product, and when two 4-limbs are ready they're
multiplied to an 8-limb product, etc.  A stack of outstanding products is
built up, with two of the same size multiplied together when ready.

<p>Arranging for multiplications to have operands the same (or nearly the same)
size means the Karatsuba and higher multiplication algorithms can be used. 
And even on sizes below the Karatsuba threshold an NxN multiply will
give a basecase multiply more to work on.

<p>An obvious improvement not currently implemented would be to strip factors of
2 from the products and apply them at the end with a bit shift.  Another
possibility would be to determine the prime factorization of the result (which
can be done easily), and use a powering method, at each stage squaring then
multiplying in those primes with a 1 in their exponent at that point.  The
advantage would be some multiplies turned into squares.

<p><hr>
Node:<a name="Binomial%20Coefficients%20Algorithm">Binomial Coefficients Algorithm</a>,
Next:<a rel=next accesskey=n href="#Fibonacci%20Numbers%20Algorithm">Fibonacci Numbers Algorithm</a>,
Previous:<a rel=previous accesskey=p href="#Factorial%20Algorithm">Factorial Algorithm</a>,
Up:<a rel=up accesskey=u href="#Other%20Algorithms">Other Algorithms</a>
<br>

<h4>Binomial Coefficients</h4>

<p>Binomial coefficients C(n,k) are calculated
by first arranging k &lt;= n/2 using C(n,k) = C(n,n-k) if necessary, and then
evaluating the following product simply from i=2 to i=k.

<br><pre>                      k  (n-k+i)
C(n,k) =  (n-k+1) * prod -------
                     i=2    i
</pre>

<p>It's easy to show that each denominator i will divide the product so
far, so the exact division algorithm is used (see <a href="#Exact%20Division">Exact Division</a>).

<p>The numerators n-k+i and denominators i are first accumulated
into as many fit a limb, to save multi-precision operations, though for
<code>mpz_bin_ui</code> this applies only to the divisors, since n is an
<code>mpz_t</code> and n-k+i in general won't fit in a limb at all.

<p>An obvious improvement would be to strip factors of 2 from each multiplier and
divisor and count them separately, to be applied with a bit shift at the end. 
Factors of 3 and perhaps 5 could even be handled similarly.  Another
possibility, if n is not too big, would be to determine the prime
factorization of the result based on the factorials involved, and power up
those primes appropriately.  This would help most when k is near
n/2.

<p><hr>
Node:<a name="Fibonacci%20Numbers%20Algorithm">Fibonacci Numbers Algorithm</a>,
Next:<a rel=next accesskey=n href="#Lucas%20Numbers%20Algorithm">Lucas Numbers Algorithm</a>,
Previous:<a rel=previous accesskey=p href="#Binomial%20Coefficients%20Algorithm">Binomial Coefficients Algorithm</a>,
Up:<a rel=up accesskey=u href="#Other%20Algorithms">Other Algorithms</a>
<br>

<h4>Fibonacci Numbers</h4>

<p>The Fibonacci functions <code>mpz_fib_ui</code> and <code>mpz_fib2_ui</code> are designed
for calculating isolated F[n] or F[n],F[n-1]
values efficiently.

<p>For small n, a table of single limb values in <code>__gmp_fib_table</code> is
used.  On a 32-bit limb this goes up to F[47], or on a 64-bit limb
up to F[93].  For convenience the table starts at F[-1].

<p>Beyond the table, values are generated with a binary powering algorithm,
calculating a pair F[n] and F[n-1] working from high to
low across the bits of n.  The formulas used are

<br><pre>F[2k+1] = 4*F[k]^2 - F[k-1]^2 + 2*(-1)^k
F[2k-1] =   F[k]^2 + F[k-1]^2

F[2k] = F[2k+1] - F[2k-1]
</pre>

<p>At each step, k is the high b bits of n.  If the next bit
of n is 0 then F[2k],F[2k-1] is used, or if
it's a 1 then F[2k+1],F[2k] is used, and the process
repeated until all bits of n are incorporated.  Notice these formulas
require just two squares per bit of n.

<p>It'd be possible to handle the first few n above the single limb table
with simple additions, using the defining Fibonacci recurrence F[k+1]=F[k]+F[k-1], but this is not done since it usually
turns out to be faster for only about 10 or 20 values of n, and
including a block of code for just those doesn't seem worthwhile.  If they
really mattered it'd be better to extend the data table.

<p>Using a table avoids lots of calculations on small numbers, and makes small
n go fast.  A bigger table would make more small n go fast, it's
just a question of balancing size against desired speed.  For GMP the code is
kept compact, with the emphasis primarily on a good powering algorithm.

<p><code>mpz_fib2_ui</code> returns both F[n] and F[n-1], but
<code>mpz_fib_ui</code> is only interested in F[n].  In this case the last
step of the algorithm can become one multiply instead of two squares.  One of
the following two formulas is used, according as n is odd or even.

<br><pre>F[2k]   = F[k]*(F[k]+2F[k-1])

F[2k+1] = (2F[k]+F[k-1])*(2F[k]-F[k-1]) + 2*(-1)^k
</pre>

<p>F[2k+1] here is the same as above, just rearranged to be a
multiply.  For interest, the 2*(-1)^k term both here and above
can be applied just to the low limb of the calculation, without a carry or
borrow into further limbs, which saves some code size.  See comments with
<code>mpz_fib_ui</code> and the internal <code>mpn_fib2_ui</code> for how this is done.

<p><hr>
Node:<a name="Lucas%20Numbers%20Algorithm">Lucas Numbers Algorithm</a>,
Previous:<a rel=previous accesskey=p href="#Fibonacci%20Numbers%20Algorithm">Fibonacci Numbers Algorithm</a>,
Up:<a rel=up accesskey=u href="#Other%20Algorithms">Other Algorithms</a>
<br>

<h4>Lucas Numbers</h4>

<p><code>mpz_lucnum2_ui</code> derives a pair of Lucas numbers from a pair of Fibonacci
numbers with the following simple formulas.

<br><pre>L[k]   =   F[k] + 2*F[k-1]
L[k-1] = 2*F[k] -   F[k-1]
</pre>

<p><code>mpz_lucnum_ui</code> is only interested in L[n], and some work can be
saved.  Trailing zero bits on n can be handled with a single square
each.

<br><pre>L[2k] = L[k]^2 - 2*(-1)^k
</pre>

<p>And the lowest 1 bit can be handled with one multiply of a pair of Fibonacci
numbers, similar to what <code>mpz_fib_ui</code> does.

<br><pre>L[2k+1] = 5*F[k-1]*(2*F[k]+F[k-1]) - 4*(-1)^k
</pre>

<p><hr>
Node:<a name="Assembler%20Coding">Assembler Coding</a>,
Previous:<a rel=previous accesskey=p href="#Other%20Algorithms">Other Algorithms</a>,
Up:<a rel=up accesskey=u href="#Algorithms">Algorithms</a>
<br>

<h3>Assembler Coding</h3>

<p>The assembler subroutines in GMP are the most significant source of speed at
small to moderate sizes.  At larger sizes algorithm selection becomes more
important, but of course speedups in low level routines will still speed up
everything proportionally.

<p>Carry handling and widening multiplies that are important for GMP can't be
easily expressed in C.  GCC <code>asm</code> blocks help a lot and are provided in
<code>longlong.h</code>, but hand coding low level routines invariably offers a
speedup over generic C by a factor of anything from 2 to 10.

<ul>
<li><a accesskey=1 href="#Assembler%20Code%20Organisation">Assembler Code Organisation</a>: 
<li><a accesskey=2 href="#Assembler%20Basics">Assembler Basics</a>: 
<li><a accesskey=3 href="#Assembler%20Carry%20Propagation">Assembler Carry Propagation</a>: 
<li><a accesskey=4 href="#Assembler%20Cache%20Handling">Assembler Cache Handling</a>: 
<li><a accesskey=5 href="#Assembler%20Floating%20Point">Assembler Floating Point</a>: 
<li><a accesskey=6 href="#Assembler%20SIMD%20Instructions">Assembler SIMD Instructions</a>: 
<li><a accesskey=7 href="#Assembler%20Software%20Pipelining">Assembler Software Pipelining</a>: 
<li><a accesskey=8 href="#Assembler%20Loop%20Unrolling">Assembler Loop Unrolling</a>: 
</ul>

<p><hr>
Node:<a name="Assembler%20Code%20Organisation">Assembler Code Organisation</a>,
Next:<a rel=next accesskey=n href="#Assembler%20Basics">Assembler Basics</a>,
Previous:<a rel=previous accesskey=p href="#Assembler%20Coding">Assembler Coding</a>,
Up:<a rel=up accesskey=u href="#Assembler%20Coding">Assembler Coding</a>
<br>

<h4>Code Organisation</h4>

<p>The various <code>mpn</code> subdirectories contain machine-dependent code, written
in C or assembler.  The <code>mpn/generic</code> subdirectory contains default code,
used when there's no machine-specific version of a particular file.

<p>Each <code>mpn</code> subdirectory is for an ISA family.  Generally 32-bit and
64-bit variants in a family cannot share code and will have separate
directories.  Within a family further subdirectories may exist for CPU
variants.

<p><hr>
Node:<a name="Assembler%20Basics">Assembler Basics</a>,
Next:<a rel=next accesskey=n href="#Assembler%20Carry%20Propagation">Assembler Carry Propagation</a>,
Previous:<a rel=previous accesskey=p href="#Assembler%20Code%20Organisation">Assembler Code Organisation</a>,
Up:<a rel=up accesskey=u href="#Assembler%20Coding">Assembler Coding</a>
<br>

<h4>Assembler Basics</h4>

<p><code>mpn_addmul_1</code> and <code>mpn_submul_1</code> are the most important routines
for overall GMP performance.  All multiplications and divisions come down to
repeated calls to these.  <code>mpn_add_n</code>, <code>mpn_sub_n</code>,
<code>mpn_lshift</code> and <code>mpn_rshift</code> are next most important.

<p>On some CPUs assembler versions of the internal functions
<code>mpn_mul_basecase</code> and <code>mpn_sqr_basecase</code> give significant speedups,
mainly through avoiding function call overheads.  They can also potentially
make better use of a wide superscalar processor.

<p>The restrictions on overlaps between sources and destinations
(see <a href="#Low-level%20Functions">Low-level Functions</a>) are designed to facilitate a variety of
implementations.  For example, knowing <code>mpn_add_n</code> won't have partly
overlapping sources and destination means reading can be done far ahead of
writing on superscalar processors, and loops can be vectorized on a vector
processor, depending on the carry handling.

<p><hr>
Node:<a name="Assembler%20Carry%20Propagation">Assembler Carry Propagation</a>,
Next:<a rel=next accesskey=n href="#Assembler%20Cache%20Handling">Assembler Cache Handling</a>,
Previous:<a rel=previous accesskey=p href="#Assembler%20Basics">Assembler Basics</a>,
Up:<a rel=up accesskey=u href="#Assembler%20Coding">Assembler Coding</a>
<br>

<h4>Carry Propagation</h4>

<p>The problem that presents most challenges in GMP is propagating carries from
one limb to the next.  In functions like <code>mpn_addmul_1</code> and
<code>mpn_add_n</code>, carries are the only dependencies between limb operations.

<p>On processors with carry flags, a straightforward CISC style <code>adc</code> is
generally best.  AMD K6 <code>mpn_addmul_1</code> however is an example of an
unusual set of circumstances where a branch works out better.

<p>On RISC processors generally an add and compare for overflow is used.  This
sort of thing can be seen in <code>mpn/generic/aors_n.c</code>.  Some carry
propagation schemes require 4 instructions, meaning at least 4 cycles per
limb, but other schemes may use just 1 or 2.  On wide superscalar processors
performance may be completely determined by the number of dependent
instructions between carry-in and carry-out for each limb.

<p>On vector processors good use can be made of the fact that a carry bit only
very rarely propagates more than one limb.  When adding a single bit to a
limb, there's only a carry out if that limb was <code>0xFF...FF</code> which on
random data will be only 1 in 2^mp_bits_per_limb.  <code>mpn/cray/add_n.c</code> is an example of this, it adds
all limbs in parallel, adds one set of carry bits in parallel and then only
rarely needs to fall through to a loop propagating further carries.

<p>On the x86s, GCC (as of version 2.95.2) doesn't generate particularly good code
for the RISC style idioms that are necessary to handle carry bits in
C.  Often conditional jumps are generated where <code>adc</code> or <code>sbb</code> forms
would be better.  And so unfortunately almost any loop involving carry bits
needs to be coded in assembler for best results.

<p><hr>
Node:<a name="Assembler%20Cache%20Handling">Assembler Cache Handling</a>,
Next:<a rel=next accesskey=n href="#Assembler%20Floating%20Point">Assembler Floating Point</a>,
Previous:<a rel=previous accesskey=p href="#Assembler%20Carry%20Propagation">Assembler Carry Propagation</a>,
Up:<a rel=up accesskey=u href="#Assembler%20Coding">Assembler Coding</a>
<br>

<h4>Cache Handling</h4>

<p>GMP aims to perform well both on operands that fit entirely in L1 cache and
those which don't.

<p>Basic routines like <code>mpn_add_n</code> or <code>mpn_lshift</code> are often used on
large operands, so L2 and main memory performance is important for them. 
<code>mpn_mul_1</code> and <code>mpn_addmul_1</code> are mostly used for multiply and
square basecases, so L1 performance matters most for them, unless assembler
versions of <code>mpn_mul_basecase</code> and <code>mpn_sqr_basecase</code> exist, in
which case the remaining uses are mostly for larger operands.

<p>For L2 or main memory operands, memory access times will almost certainly be
more than the calculation time.  The aim therefore is to maximize memory
throughput, by starting a load of the next cache line which processing the
contents of the previous one.  Clearly this is only possible if the chip has a
lock-up free cache or some sort of prefetch instruction.  Most current chips
have both these features.

<p>Prefetching sources combines well with loop unrolling, since a prefetch can be
initiated once per unrolled loop (or more than once if the loop covers more
than one cache line).

<p>On CPUs without write-allocate caches, prefetching destinations will ensure
individual stores don't go further down the cache hierarchy, limiting
bandwidth.  Of course for calculations which are slow anyway, like
<code>mpn_divrem_1</code>, write-throughs might be fine.

<p>The distance ahead to prefetch will be determined by memory latency versus
throughput.  The aim of course is to have data arriving continuously, at peak
throughput.  Some CPUs have limits on the number of fetches or prefetches in
progress.

<p>If a special prefetch instruction doesn't exist then a plain load can be used,
but in that case care must be taken not to attempt to read past the end of an
operand, since that might produce a segmentation violation.

<p>Some CPUs or systems have hardware that detects sequential memory accesses and
initiates suitable cache movements automatically, making life easy.

<p><hr>
Node:<a name="Assembler%20Floating%20Point">Assembler Floating Point</a>,
Next:<a rel=next accesskey=n href="#Assembler%20SIMD%20Instructions">Assembler SIMD Instructions</a>,
Previous:<a rel=previous accesskey=p href="#Assembler%20Cache%20Handling">Assembler Cache Handling</a>,
Up:<a rel=up accesskey=u href="#Assembler%20Coding">Assembler Coding</a>
<br>

<h4>Floating Point</h4>

<p>Floating point arithmetic is used in GMP for multiplications on CPUs with poor
integer multipliers.  It's mostly useful for <code>mpn_mul_1</code>,
<code>mpn_addmul_1</code> and <code>mpn_submul_1</code> on 64-bit machines, and
<code>mpn_mul_basecase</code> on both 32-bit and 64-bit machines.

<p>With IEEE 53-bit double precision floats, integer multiplications producing up
to 53 bits will give exact results.  Breaking a 64x64 multiplication
into eight 16x32-&gt;48 bit pieces is convenient.  With
some care though six 21x32-&gt;53 bit products can be
used, if one of the lower two 21-bit pieces also uses the sign bit.

<p>For the <code>mpn_mul_1</code> family of functions on a 64-bit machine, the
invariant single limb is split at the start, into 3 or 4 pieces.  Inside the
loop, the bignum operand is split into 32-bit pieces.  Fast conversion of
these unsigned 32-bit pieces to floating point is highly machine-dependent. 
In some cases, reading the data into the integer unit, zero-extending to
64-bits, then transferring to the floating point unit back via memory is the
only option.

<p>Converting partial products back to 64-bit limbs is usually best done as a
signed conversion.  Since all values are smaller than 2^53, signed
and unsigned are the same, but most processors lack unsigned conversions.

<br><p>
<br><p>
<p>Here is a diagram showing 16x32 bit products for an <code>mpn_mul_1</code> or
<code>mpn_addmul_1</code> with a 64-bit limb.  The single limb operand V is split
into four 16-bit parts.  The multi-limb operand U is split in the loop into
two 32-bit parts.

<br><pre>                +---+---+---+---+
                |v48|v32|v16|v00|    V operand
                +---+---+---+---+

                +-------+---+---+
            x   |  u32  |  u00  |    U operand (one limb)
                +---------------+

---------------------------------

                    +-----------+
                    | u00 x v00 |    p00    48-bit products
                    +-----------+
                +-----------+
                | u00 x v16 |        p16
                +-----------+
            +-----------+
            | u00 x v32 |            p32
            +-----------+
        +-----------+
        | u00 x v48 |                p48
        +-----------+
            +-----------+
            | u32 x v00 |            r32
            +-----------+
        +-----------+
        | u32 x v16 |                r48
        +-----------+
    +-----------+
    | u32 x v32 |                    r64
    +-----------+
+-----------+
| u32 x v48 |                        r80
+-----------+
</pre>

<p>p32 and r32 can be summed using floating-point addition, and
likewise p48 and r48.  p00 and p16 can be summed
with r64 and r80 from the previous iteration.

<p>For each loop then, four 49-bit quantities are transfered to the integer unit,
aligned as follows,

<br><pre>|-----64bits----|-----64bits----|
                   +------------+
                   | p00 + r64' |    i00
                   +------------+
               +------------+
               | p16 + r80' |        i16
               +------------+
           +------------+
           | p32 + r32  |            i32
           +------------+
       +------------+
       | p48 + r48  |                i48
       +------------+
</pre>

<p>The challenge then is to sum these efficiently and add in a carry limb,
generating a low 64-bit result limb and a high 33-bit carry limb (i48
extends 33 bits into the high half).

<p><hr>
Node:<a name="Assembler%20SIMD%20Instructions">Assembler SIMD Instructions</a>,
Next:<a rel=next accesskey=n href="#Assembler%20Software%20Pipelining">Assembler Software Pipelining</a>,
Previous:<a rel=previous accesskey=p href="#Assembler%20Floating%20Point">Assembler Floating Point</a>,
Up:<a rel=up accesskey=u href="#Assembler%20Coding">Assembler Coding</a>
<br>

<h4>SIMD Instructions</h4>

<p>The single-instruction multiple-data support in current microprocessors is
aimed at signal processing algorithms where each data point can be treated
more or less independently.  There's generally not much support for
propagating the sort of carries that arise in GMP.

<p>SIMD multiplications of say four 16x16 bit multiplies only do as much
work as one 32x32 from GMP's point of view, and need some shifts and
adds besides.  But of course if say the SIMD form is fully pipelined and uses
less instruction decoding then it may still be worthwhile.

<p>On the 80x86 chips, MMX has so far found a use in <code>mpn_rshift</code> and
<code>mpn_lshift</code> since it allows 64-bit operations, and is used in a special
case for 16-bit multipliers in the P55 <code>mpn_mul_1</code>.  3DNow and SSE
haven't found a use so far.

<p><hr>
Node:<a name="Assembler%20Software%20Pipelining">Assembler Software Pipelining</a>,
Next:<a rel=next accesskey=n href="#Assembler%20Loop%20Unrolling">Assembler Loop Unrolling</a>,
Previous:<a rel=previous accesskey=p href="#Assembler%20SIMD%20Instructions">Assembler SIMD Instructions</a>,
Up:<a rel=up accesskey=u href="#Assembler%20Coding">Assembler Coding</a>
<br>

<h4>Software Pipelining</h4>

<p>Software pipelining consists of scheduling instructions around the branch
point in a loop.  For example a loop taking a checksum of an array of limbs
might have a load and an add, but the load wouldn't be for that add, rather
for the one next time around the loop.  Each load then is effectively
scheduled back in the previous iteration, allowing latency to be hidden.

<p>Naturally this is wanted only when doing things like loads or multiplies that
take a few cycles to complete, and only where a CPU has multiple functional
units so that other work can be done while waiting.

<p>A pipeline with several stages will have a data value in progress at each
stage and each loop iteration moves them along one stage.  This is like
juggling.

<p>Within the loop some moves between registers may be necessary to have the
right values in the right places for each iteration.  Loop unrolling can help
this, with each unrolled block able to use different registers for different
values, even if some shuffling is still needed just before going back to the
top of the loop.

<p><hr>
Node:<a name="Assembler%20Loop%20Unrolling">Assembler Loop Unrolling</a>,
Previous:<a rel=previous accesskey=p href="#Assembler%20Software%20Pipelining">Assembler Software Pipelining</a>,
Up:<a rel=up accesskey=u href="#Assembler%20Coding">Assembler Coding</a>
<br>

<h4>Loop Unrolling</h4>

<p>Loop unrolling consists of replicating code so that several limbs are
processed in each loop.  At a minimum this reduces loop overheads by a
corresponding factor, but it can also allow better register usage, for example
alternately using one register combination and then another.  Judicious use of
<code>m4</code> macros can help avoid lots of duplication in the source code.

<p>Unrolling is commonly done to a power of 2 multiple so the number of unrolled
loops and the number of remaining limbs can be calculated with a shift and
mask.  But other multiples can be used too, just by subtracting each <var>n</var>
limbs processed from a counter and waiting for less than <var>n</var> remaining (or
offsetting the counter by <var>n</var> so it goes negative when there's less than
<var>n</var> remaining).

<p>The limbs not a multiple of the unrolling can be handled in various ways, for
example

<ul>
<li>A simple loop at the end (or the start) to process the excess.  Care will be
wanted that it isn't too much slower than the unrolled part.

<li>A set of binary tests, for example after an 8-limb unrolling, test for 4 more
limbs to process, then a further 2 more or not, and finally 1 more or not. 
This will probably take more code space than a simple loop.

<li>A <code>switch</code> statement, providing separate code for each possible excess,
for example an 8-limb unrolling would have separate code for 0 remaining, 1
remaining, etc, up to 7 remaining.  This might take a lot of code, but may be
the best way to optimize all cases in combination with a deep pipelined loop.

<li>A computed jump into the middle of the loop, thus making the first iteration
handle the excess.  This should make times smoothly increase with size, which
is attractive, but setups for the jump and adjustments for pointers can be
tricky and could become quite difficult in combination with deep pipelining. 
</ul>

<p>One way to write the setups and finishups for a pipelined unrolled loop is
simply to duplicate the loop at the start and the end, then delete
instructions at the start which have no valid antecedents, and delete
instructions at the end whose results are unwanted.  Sizes not a multiple of
the unrolling can then be handled as desired.

<p><hr>
Node:<a name="Internals">Internals</a>,
Next:<a rel=next accesskey=n href="#Contributors">Contributors</a>,
Previous:<a rel=previous accesskey=p href="#Algorithms">Algorithms</a>,
Up:<a rel=up accesskey=u href="#Top">Top</a>
<br>

<h2>Internals</h2>

<p><strong>This chapter is provided only for informational purposes and the
various internals described here may change in future GMP releases. 
Applications expecting to be compatible with future releases should use only
the documented interfaces described in previous chapters.</strong>

<ul>
<li><a accesskey=1 href="#Integer%20Internals">Integer Internals</a>: 
<li><a accesskey=2 href="#Rational%20Internals">Rational Internals</a>: 
<li><a accesskey=3 href="#Float%20Internals">Float Internals</a>: 
<li><a accesskey=4 href="#Raw%20Output%20Internals">Raw Output Internals</a>: 
<li><a accesskey=5 href="#C++%20Interface%20Internals">C++ Interface Internals</a>: 
</ul>

<p><hr>
Node:<a name="Integer%20Internals">Integer Internals</a>,
Next:<a rel=next accesskey=n href="#Rational%20Internals">Rational Internals</a>,
Previous:<a rel=previous accesskey=p href="#Internals">Internals</a>,
Up:<a rel=up accesskey=u href="#Internals">Internals</a>
<br>

<h3>Integer Internals</h3>

<p><code>mpz_t</code> variables represent integers using sign and magnitude, in space
dynamically allocated and reallocated.  The fields are as follows.

<dl>
<dt><code>_mp_size</code>
<dd>The number of limbs, or the negative of that when representing a negative
integer.  Zero is represented by <code>_mp_size</code> set to zero, in which case
the <code>_mp_d</code> data is unused.

<br><dt><code>_mp_d</code>
<dd>A pointer to an array of limbs which is the magnitude.  These are stored
"little endian" as per the <code>mpn</code> functions, so <code>_mp_d[0]</code> is the
least significant limb and <code>_mp_d[ABS(_mp_size)-1]</code> is the most
significant.  Whenever <code>_mp_size</code> is non-zero, the most significant limb
is non-zero.

<p>Currently there's always at least one limb allocated, so for instance
<code>mpz_set_ui</code> never needs to reallocate, and <code>mpz_get_ui</code> can fetch
<code>_mp_d[0]</code> unconditionally (though its value is then only wanted if
<code>_mp_size</code> is non-zero).

<br><dt><code>_mp_alloc</code>
<dd><code>_mp_alloc</code> is the number of limbs currently allocated at <code>_mp_d</code>,
and naturally <code>_mp_alloc &gt;= ABS(_mp_size)</code>.  When an <code>mpz</code> routine
is about to (or might be about to) increase <code>_mp_size</code>, it checks
<code>_mp_alloc</code> to see whether there's enough space, and reallocates if not. 
<code>MPZ_REALLOC</code> is generally used for this. 
</dl>

<p>The various bitwise logical functions like <code>mpz_and</code> behave as if
negative values were twos complement.  But sign and magnitude is always used
internally, and necessary adjustments are made during the calculations. 
Sometimes this isn't pretty, but sign and magnitude are best for other
routines.

<p>Some internal temporary variables are setup with <code>MPZ_TMP_INIT</code> and these
have <code>_mp_d</code> space obtained from <code>TMP_ALLOC</code> rather than the memory
allocation functions.  Care is taken to ensure that these are big enough that
no reallocation is necessary (since it would have unpredictable consequences).

<p><hr>
Node:<a name="Rational%20Internals">Rational Internals</a>,
Next:<a rel=next accesskey=n href="#Float%20Internals">Float Internals</a>,
Previous:<a rel=previous accesskey=p href="#Integer%20Internals">Integer Internals</a>,
Up:<a rel=up accesskey=u href="#Internals">Internals</a>
<br>

<h3>Rational Internals</h3>

<p><code>mpq_t</code> variables represent rationals using an <code>mpz_t</code> numerator and
denominator (see <a href="#Integer%20Internals">Integer Internals</a>).

<p>The canonical form adopted is denominator positive (and non-zero), no common
factors between numerator and denominator, and zero uniquely represented as
0/1.

<p>It's believed that casting out common factors at each stage of a calculation
is best in general.  A GCD is an O(N^2) operation so it's better to do
a few small ones immediately than to delay and have to do a big one later. 
Knowing the numerator and denominator have no common factors can be used for
example in <code>mpq_mul</code> to make only two cross GCDs necessary, not four.

<p>This general approach to common factors is badly sub-optimal in the presence
of simple factorizations or little prospect for cancellation, but GMP has no
way to know when this will occur.  As per <a href="#Efficiency">Efficiency</a>, that's left to
applications.  The <code>mpq_t</code> framework might still suit, with
<code>mpq_numref</code> and <code>mpq_denref</code> for direct access to the numerator and
denominator, or of course <code>mpz_t</code> variables can be used directly.

<p><hr>
Node:<a name="Float%20Internals">Float Internals</a>,
Next:<a rel=next accesskey=n href="#Raw%20Output%20Internals">Raw Output Internals</a>,
Previous:<a rel=previous accesskey=p href="#Rational%20Internals">Rational Internals</a>,
Up:<a rel=up accesskey=u href="#Internals">Internals</a>
<br>

<h3>Float Internals</h3>

<p>Efficient calculation is the primary aim of GMP floats and the use of whole
limbs and simple rounding facilitates this.

<p><code>mpf_t</code> floats have a variable precision mantissa and a single machine
word signed exponent.  The mantissa is represented using sign and magnitude.

<br><pre>   most                   least
significant            significant
   limb                   limb

                            _mp_d
 |---- _mp_exp ---&gt;           |
  _____ _____ _____ _____ _____
 |_____|_____|_____|_____|_____|
                   . &lt;------------ radix point

  &lt;-------- _mp_size ---------&gt;
<br><p>
</pre>

<p>The fields are as follows.

<dl>
<dt><code>_mp_size</code>
<dd>The number of limbs currently in use, or the negative of that when
representing a negative value.  Zero is represented by <code>_mp_size</code> and
<code>_mp_exp</code> both set to zero, and in that case the <code>_mp_d</code> data is
unused.  (In the future <code>_mp_exp</code> might be undefined when representing
zero.)

<br><dt><code>_mp_prec</code>
<dd>The precision of the mantissa, in limbs.  In any calculation the aim is to
produce <code>_mp_prec</code> limbs of result (the most significant being non-zero).

<br><dt><code>_mp_d</code>
<dd>A pointer to the array of limbs which is the absolute value of the mantissa. 
These are stored "little endian" as per the <code>mpn</code> functions, so
<code>_mp_d[0]</code> is the least significant limb and
<code>_mp_d[ABS(_mp_size)-1]</code> the most significant.

<p>The most significant limb is always non-zero, but there are no other
restrictions on its value, in particular the highest 1 bit can be anywhere
within the limb.

<p><code>_mp_prec+1</code> limbs are allocated to <code>_mp_d</code>, the extra limb being
for convenience (see below).  There are no reallocations during a calculation,
only in a change of precision with <code>mpf_set_prec</code>.

<br><dt><code>_mp_exp</code>
<dd>The exponent, in limbs, determining the location of the implied radix point. 
Zero means the radix point is just above the most significant limb.  Positive
values mean a radix point offset towards the lower limbs and hence a value
&gt;= 1, as for example in the diagram above.  Negative exponents mean
a radix point further above the highest limb.

<p>Naturally the exponent can be any value, it doesn't have to fall within the
limbs as the diagram shows, it can be a long way above or a long way below. 
Limbs other than those included in the <code>{_mp_d,_mp_size}</code> data
are treated as zero. 
</dl>

<br><p>
<p>The following various points should be noted.

<dl>
<dt>Low Zeros
<dd>The least significant limbs <code>_mp_d[0]</code> etc can be zero, though such low
zeros can always be ignored.  Routines likely to produce low zeros check and
avoid them to save time in subsequent calculations, but for most routines
they're quite unlikely and aren't checked.

<br><dt>Mantissa Size Range
<dd>The <code>_mp_size</code> count of limbs in use can be less than <code>_mp_prec</code> if
the value can be represented in less.  This means low precision values or
small integers stored in a high precision <code>mpf_t</code> can still be operated
on efficiently.

<p><code>_mp_size</code> can also be greater than <code>_mp_prec</code>.  Firstly a value is
allowed to use all of the <code>_mp_prec+1</code> limbs available at <code>_mp_d</code>,
and secondly when <code>mpf_set_prec_raw</code> lowers <code>_mp_prec</code> it leaves
<code>_mp_size</code> unchanged and so the size can be arbitrarily bigger than
<code>_mp_prec</code>.

<br><dt>Rounding
<dd>All rounding is done on limb boundaries.  Calculating <code>_mp_prec</code> limbs
with the high non-zero will ensure the application requested minimum precision
is obtained.

<p>The use of simple "trunc" rounding towards zero is efficient, since there's
no need to examine extra limbs and increment or decrement.

<br><dt>Bit Shifts
<dd>Since the exponent is in limbs, there are no bit shifts in basic operations
like <code>mpf_add</code> and <code>mpf_mul</code>.  When differing exponents are
encountered all that's needed is to adjust pointers to line up the relevant
limbs.

<p>Of course <code>mpf_mul_2exp</code> and <code>mpf_div_2exp</code> will require bit shifts,
but the choice is between an exponent in limbs which requires shifts there, or
one in bits which requires them almost everywhere else.

<br><dt>Use of <code>_mp_prec+1</code> Limbs
<dd>The extra limb on <code>_mp_d</code> (<code>_mp_prec+1</code> rather than just
<code>_mp_prec</code>) helps when an <code>mpf</code> routine might get a carry from its
operation.  <code>mpf_add</code> for instance will do an <code>mpn_add</code> of
<code>_mp_prec</code> limbs.  If there's no carry then that's the result, but if
there is a carry then it's stored in the extra limb of space and
<code>_mp_size</code> becomes <code>_mp_prec+1</code>.

<p>Whenever <code>_mp_prec+1</code> limbs are held in a variable, the low limb is not
needed for the intended precision, only the <code>_mp_prec</code> high limbs.  But
zeroing it out or moving the rest down is unnecessary.  Subsequent routines
reading the value will simply take the high limbs they need, and this will be
<code>_mp_prec</code> if their target has that same precision.  This is no more than
a pointer adjustment, and must be checked anyway since the destination
precision can be different from the sources.

<p>Copy functions like <code>mpf_set</code> will retain a full <code>_mp_prec+1</code> limbs
if available.  This ensures that a variable which has <code>_mp_size</code> equal to
<code>_mp_prec+1</code> will get its full exact value copied.  Strictly speaking
this is unnecessary since only <code>_mp_prec</code> limbs are needed for the
application's requested precision, but it's considered that an <code>mpf_set</code>
from one variable into another of the same precision ought to produce an exact
copy.

<br><dt>Application Precisions
<dd><code>__GMPF_BITS_TO_PREC</code> converts an application requested precision to an
<code>_mp_prec</code>.  The value in bits is rounded up to a whole limb then an
extra limb is added since the most significant limb of <code>_mp_d</code> is only
non-zero and therefore might contain only one bit.

<p><code>__GMPF_PREC_TO_BITS</code> does the reverse conversion, and removes the extra
limb from <code>_mp_prec</code> before converting to bits.  The net effect of
reading back with <code>mpf_get_prec</code> is simply the precision rounded up to a
multiple of <code>mp_bits_per_limb</code>.

<p>Note that the extra limb added here for the high only being non-zero is in
addition to the extra limb allocated to <code>_mp_d</code>.  For example with a
32-bit limb, an application request for 250 bits will be rounded up to 8
limbs, then an extra added for the high being only non-zero, giving an
<code>_mp_prec</code> of 9.  <code>_mp_d</code> then gets 10 limbs allocated.  Reading
back with <code>mpf_get_prec</code> will take <code>_mp_prec</code> subtract 1 limb and
multiply by 32, giving 256 bits.

<p>Strictly speaking, the fact the high limb has at least one bit means that a
float with, say, 3 limbs of 32-bits each will be holding at least 65 bits, but
for the purposes of <code>mpf_t</code> it's considered simply to be 64 bits, a nice
multiple of the limb size. 
</dl>

<p><hr>
Node:<a name="Raw%20Output%20Internals">Raw Output Internals</a>,
Next:<a rel=next accesskey=n href="#C++%20Interface%20Internals">C++ Interface Internals</a>,
Previous:<a rel=previous accesskey=p href="#Float%20Internals">Float Internals</a>,
Up:<a rel=up accesskey=u href="#Internals">Internals</a>
<br>

<h3>Raw Output Internals</h3>

<p><code>mpz_out_raw</code> uses the following format.

<br><pre>+------+------------------------+
| size |       data bytes       |
+------+------------------------+
</pre>

<p>The size is 4 bytes written most significant byte first, being the number of
subsequent data bytes, or the twos complement negative of that when a negative
integer is represented.  The data bytes are the absolute value of the integer,
written most significant byte first.

<p>The most significant data byte is always non-zero, so the output is the same
on all systems, irrespective of limb size.

<p>In GMP 1, leading zero bytes were written to pad the data bytes to a multiple
of the limb size.  <code>mpz_inp_raw</code> will still accept this, for
compatibility.

<p>The use of "big endian" for both the size and data fields is deliberate, it
makes the data easy to read in a hex dump of a file.  Unfortunately it also
means that the limb data must be reversed when reading or writing, so neither
a big endian nor little endian system can just read and write <code>_mp_d</code>.

<p><hr>
Node:<a name="C++%20Interface%20Internals">C++ Interface Internals</a>,
Previous:<a rel=previous accesskey=p href="#Raw%20Output%20Internals">Raw Output Internals</a>,
Up:<a rel=up accesskey=u href="#Internals">Internals</a>
<br>

<h3>C++ Interface Internals</h3>

<p>A system of expression templates is used to ensure something like <code>a=b+c</code>
turns into a simple call to <code>mpz_add</code> etc.  For <code>mpf_class</code> and
<code>mpfr_class</code> the scheme also ensures the precision of the final
destination is used for any temporaries within a statement like
<code>f=w*x+y*z</code>.  These are important features which a naive implementation
cannot provide.

<p>A simplified description of the scheme follows.  The true scheme is
complicated by the fact that expressions have different return types.  For
detailed information, refer to the source code.

<p>To perform an operation, say, addition, we first define a "function object"
evaluating it,

<br><pre>struct __gmp_binary_plus
{
  static void eval(mpf_t f, mpf_t g, mpf_t h) { mpf_add(f, g, h); }
};
</pre>

<p>And an "additive expression" object,

<br><pre>__gmp_expr&lt;__gmp_binary_expr&lt;mpf_class, mpf_class, __gmp_binary_plus&gt; &gt;
operator+(const mpf_class &amp;f, const mpf_class &amp;g)
{
  return __gmp_expr
    &lt;__gmp_binary_expr&lt;mpf_class, mpf_class, __gmp_binary_plus&gt; &gt;(f, g);
}
</pre>

<p>The seemingly redundant <code>__gmp_expr&lt;__gmp_binary_expr&lt;...&gt;&gt;</code> is used to
encapsulate any possible kind of expression into a single template type.  In
fact even <code>mpf_class</code> etc are <code>typedef</code> specializations of
<code>__gmp_expr</code>.

<p>Next we define assignment of <code>__gmp_expr</code> to <code>mpf_class</code>.

<br><pre>template &lt;class T&gt;
mpf_class &amp; mpf_class::operator=(const __gmp_expr&lt;T&gt; &amp;expr)
{
  expr.eval(this-&gt;get_mpf_t(), this-&gt;precision());
  return *this;
}

template &lt;class Op&gt;
void __gmp_expr&lt;__gmp_binary_expr&lt;mpf_class, mpf_class, Op&gt; &gt;::eval
(mpf_t f, unsigned long int precision)
{
  Op::eval(f, expr.val1.get_mpf_t(), expr.val2.get_mpf_t());
}
</pre>

<p>where <code>expr.val1</code> and <code>expr.val2</code> are references to the expression's
operands (here <code>expr</code> is the <code>__gmp_binary_expr</code> stored within the
<code>__gmp_expr</code>).

<p>This way, the expression is actually evaluated only at the time of assignment,
when the required precision (that of <code>f</code>) is known.  Furthermore the
target <code>mpf_t</code> is now available, thus we can call <code>mpf_add</code> directly
with <code>f</code> as the output argument.

<p>Compound expressions are handled by defining operators taking subexpressions
as their arguments, like this:

<br><pre>template &lt;class T, class U&gt;
__gmp_expr
&lt;__gmp_binary_expr&lt;__gmp_expr&lt;T&gt;, __gmp_expr&lt;U&gt;, __gmp_binary_plus&gt; &gt;
operator+(const __gmp_expr&lt;T&gt; &amp;expr1, const __gmp_expr&lt;U&gt; &amp;expr2)
{
  return __gmp_expr
    &lt;__gmp_binary_expr&lt;__gmp_expr&lt;T&gt;, __gmp_expr&lt;U&gt;, __gmp_binary_plus&gt; &gt;
    (expr1, expr2);
}
</pre>

<p>And the corresponding specializations of <code>__gmp_expr::eval</code>:

<br><pre>template &lt;class T, class U, class Op&gt;
void __gmp_expr
&lt;__gmp_binary_expr&lt;__gmp_expr&lt;T&gt;, __gmp_expr&lt;U&gt;, Op&gt; &gt;::eval
(mpf_t f, unsigned long int precision)
{
  // declare two temporaries
  mpf_class temp1(expr.val1, precision), temp2(expr.val2, precision);
  Op::eval(f, temp1.get_mpf_t(), temp2.get_mpf_t());
}
</pre>

<p>The expression is thus recursively evaluated to any level of complexity and
all subexpressions are evaluated to the precision of <code>f</code>.

<p><hr>
Node:<a name="Contributors">Contributors</a>,
Next:<a rel=next accesskey=n href="#References">References</a>,
Previous:<a rel=previous accesskey=p href="#Internals">Internals</a>,
Up:<a rel=up accesskey=u href="#Top">Top</a>
<br>

<h2>Contributors</h2>

<p>Torbjorn Granlund wrote the original GMP library and is still developing and
maintaining it.  Several other individuals and organizations have contributed
to GMP in various ways.  Here is a list in chronological order:

<p>Gunnar Sjoedin and Hans Riesel helped with mathematical problems in early
versions of the library.

<p>Richard Stallman contributed to the interface design and revised the first
version of this manual.

<p>Brian Beuning and Doug Lea helped with testing of early versions of the
library and made creative suggestions.

<p>John Amanatides of York University in Canada contributed the function
<code>mpz_probab_prime_p</code>.

<p>Paul Zimmermann of Inria sparked the development of GMP 2, with his
comparisons between bignum packages.

<p>Ken Weber (Kent State University, Universidade Federal do Rio Grande do Sul)
contributed <code>mpz_gcd</code>, <code>mpz_divexact</code>, <code>mpn_gcd</code>, and
<code>mpn_bdivmod</code>, partially supported by CNPq (Brazil) grant 301314194-2.

<p>Per Bothner of Cygnus Support helped to set up GMP to use Cygnus' configure. 
He has also made valuable suggestions and tested numerous intermediary
releases.

<p>Joachim Hollman was involved in the design of the <code>mpf</code> interface, and in
the <code>mpz</code> design revisions for version 2.

<p>Bennet Yee contributed the initial versions of <code>mpz_jacobi</code> and
<code>mpz_legendre</code>.

<p>Andreas Schwab contributed the files <code>mpn/m68k/lshift.S</code> and
<code>mpn/m68k/rshift.S</code> (now in <code>.asm</code> form).

<p>The development of floating point functions of GNU MP 2, were supported in part
by the ESPRIT-BRA (Basic Research Activities) 6846 project POSSO (POlynomial
System SOlving).

<p>GNU MP 2 was finished and released by SWOX AB, SWEDEN, in cooperation with the
IDA Center for Computing Sciences, USA.

<p>Robert Harley of Inria, France and David Seal of ARM, England, suggested clever
improvements for population count.

<p>Robert Harley also wrote highly optimized Karatsuba and 3-way Toom
multiplication functions for GMP 3.  He also contributed the ARM assembly
code.

<p>Torsten Ekedahl of the Mathematical department of Stockholm University provided
significant inspiration during several phases of the GMP development.  His
mathematical expertise helped improve several algorithms.

<p>Paul Zimmermann wrote the Divide and Conquer division code, the REDC code, the
REDC-based mpz_powm code, the FFT multiply code, and the Karatsuba square
root.  The ECMNET project Paul is organizing was a driving force behind many
of the optimizations in GMP 3.

<p>Linus Nordberg wrote the new configure system based on autoconf and
implemented the new random functions.

<p>Kent Boortz made the Macintosh port.

<p>Kevin Ryde worked on a number of things: optimized x86 code, m4 asm macros,
parameter tuning, speed measuring, the configure system, function inlining,
divisibility tests, bit scanning, Jacobi symbols, Fibonacci and Lucas number
functions, printf and scanf functions, perl interface, demo expression parser,
the algorithms chapter in the manual, <code>gmpasm-mode.el</code>, and various
miscellaneous improvements elsewhere.

<p>Steve Root helped write the optimized alpha 21264 assembly code.

<p>Gerardo Ballabio wrote the <code>gmpxx.h</code> C++ class interface and the C++
<code>istream</code> input routines.

<p>GNU MP 4.0 was finished and released by Torbjorn Granlund and Kevin Ryde. 
Torbjorn's work was partially funded by the IDA Center for Computing Sciences,
USA.

<p>(This list is chronological, not ordered after significance.  If you have
contributed to GMP but are not listed above, please tell <a href="mailto:tege@swox.com">tege@swox.com</a>
about the omission!)

<p>Thanks goes to Hans Thorsen for donating an SGI system for the GMP test system
environment.

<p><hr>
Node:<a name="References">References</a>,
Next:<a rel=next accesskey=n href="#GNU%20Free%20Documentation%20License">GNU Free Documentation License</a>,
Previous:<a rel=previous accesskey=p href="#Contributors">Contributors</a>,
Up:<a rel=up accesskey=u href="#Top">Top</a>
<br>

<h2>References</h2>

<h3>Books</h3>

<ul>
<li>Jonathan M. Borwein and Peter B. Borwein, "Pi and the AGM: A Study in
Analytic Number Theory and Computational Complexity", Wiley, John &amp; Sons,
1998.

<li>Henri Cohen, "A Course in Computational Algebraic Number Theory", Graduate
Texts in Mathematics number 138, Springer-Verlag, 1993. 
 <a href="http://www.math.u-bordeaux.fr/~cohen">http://www.math.u-bordeaux.fr/~cohen</a>

<li>Donald E. Knuth, "The Art of Computer Programming", volume 2,
"Seminumerical Algorithms", 3rd edition, Addison-Wesley, 1998. 
 <a href="http://www-cs-faculty.stanford.edu/~knuth/taocp.html">http://www-cs-faculty.stanford.edu/~knuth/taocp.html</a>

<li>John D. Lipson, "Elements of Algebra and Algebraic Computing",
The Benjamin Cummings Publishing Company Inc, 1981.

<li>Alfred J. Menezes, Paul C. van Oorschot and Scott A. Vanstone, "Handbook of
Applied Cryptography", <a href="http://www.cacr.math.uwaterloo.ca/hac/">http://www.cacr.math.uwaterloo.ca/hac/</a>

<li>Richard M. Stallman, "Using and Porting GCC", Free Software Foundation, 1999,
available online <a href="http://www.gnu.org/software/gcc/onlinedocs/">http://www.gnu.org/software/gcc/onlinedocs/</a>, and in
the GCC package <a href="ftp://ftp.gnu.org/gnu/gcc/">ftp://ftp.gnu.org/gnu/gcc/</a>
</ul>

<h3>Papers</h3>

<ul>
<li>Christoph Burnikel and Joachim Ziegler, "Fast Recursive Division",
Max-Planck-Institut fuer Informatik Research Report MPI-I-98-1-022, 
<a href="http://data.mpi-sb.mpg.de/internet/reports.nsf/NumberView/1998-1-022">http://data.mpi-sb.mpg.de/internet/reports.nsf/NumberView/1998-1-022</a>

<li>Torbjorn Granlund and Peter L. Montgomery, "Division by Invariant Integers
using Multiplication", in Proceedings of the SIGPLAN PLDI'94 Conference, June
1994.  Also available <a href="ftp://ftp.cwi.nl/pub/pmontgom/divcnst.psa4.gz">ftp://ftp.cwi.nl/pub/pmontgom/divcnst.psa4.gz</a>
(and .psl.gz).

<li>Peter L. Montgomery, "Modular Multiplication Without Trial Division", in
Mathematics of Computation, volume 44, number 170, April 1985.

<li>Tudor Jebelean,
"An algorithm for exact division",
Journal of Symbolic Computation,
volume 15, 1993, pp. 169-180. 
Research report version available 
<a href="ftp://ftp.risc.uni-linz.ac.at/pub/techreports/1992/92-35.ps.gz">ftp://ftp.risc.uni-linz.ac.at/pub/techreports/1992/92-35.ps.gz</a>

<li>Tudor Jebelean, "Exact Division with Karatsuba Complexity - Extended
Abstract", RISC-Linz technical report 96-31, 
<a href="ftp://ftp.risc.uni-linz.ac.at/pub/techreports/1996/96-31.ps.gz">ftp://ftp.risc.uni-linz.ac.at/pub/techreports/1996/96-31.ps.gz</a>

<li>Tudor Jebelean, "Practical Integer Division with Karatsuba Complexity",
ISSAC 97, pp. 339-341.  Technical report available 
<a href="ftp://ftp.risc.uni-linz.ac.at/pub/techreports/1996/96-29.ps.gz">ftp://ftp.risc.uni-linz.ac.at/pub/techreports/1996/96-29.ps.gz</a>

<li>Tudor Jebelean, "A Generalization of the Binary GCD Algorithm", ISSAC 93,
pp. 111-116.  Technical report version available 
<a href="ftp://ftp.risc.uni-linz.ac.at/pub/techreports/1993/93-01.ps.gz">ftp://ftp.risc.uni-linz.ac.at/pub/techreports/1993/93-01.ps.gz</a>

<li>Tudor Jebelean, "A Double-Digit Lehmer-Euclid Algorithm for Finding the GCD
of Long Integers", Journal of Symbolic Computation, volume 19, 1995,
pp. 145-157.  Technical report version also available 
<a href="ftp://ftp.risc.uni-linz.ac.at/pub/techreports/1992/92-69.ps.gz">ftp://ftp.risc.uni-linz.ac.at/pub/techreports/1992/92-69.ps.gz</a>

<li>Werner Krandick and Tudor Jebelean, "Bidirectional Exact Integer Division",
Journal of Symbolic Computation, volume 21, 1996, pp. 441-455.  Early
technical report version also available
<a href="ftp://ftp.risc.uni-linz.ac.at/pub/techreports/1994/94-50.ps.gz">ftp://ftp.risc.uni-linz.ac.at/pub/techreports/1994/94-50.ps.gz</a>

<li>R. Moenck and A. Borodin, "Fast Modular Transforms via Division",
Proceedings of the 13th Annual IEEE Symposium on Switching and Automata
Theory, October 1972, pp. 90-96.  Reprinted as "Fast Modular Transforms",
Journal of Computer and System Sciences, volume 8, number 3, June 1974,
pp. 366-386.

<li>Arnold Sch&ouml;nhage and Volker Strassen, "Schnelle Multiplikation grosser
Zahlen", Computing 7, 1971, pp. 281-292.

<li>Kenneth Weber, "The accelerated integer GCD algorithm",
ACM Transactions on Mathematical Software,
volume 21, number 1, March 1995, pp. 111-122.

<li>Paul Zimmermann, "Karatsuba Square Root", INRIA Research Report 3805,
November 1999, <a href="http://www.inria.fr/RRRT/RR-3805.html">http://www.inria.fr/RRRT/RR-3805.html</a>

<li>Paul Zimmermann, "A Proof of GMP Fast Division and Square Root
Implementations", 
<a href="http://www.loria.fr/~zimmerma/papers/proof-div-sqrt.ps.gz">http://www.loria.fr/~zimmerma/papers/proof-div-sqrt.ps.gz</a>

<li>Dan Zuras, "On Squaring and Multiplying Large Integers", ARITH-11: IEEE
Symposium on Computer Arithmetic, 1993, pp. 260 to 271.  Reprinted as "More
on Multiplying and Squaring Large Integers", IEEE Transactions on Computers,
volume 43, number 8, August 1994, pp. 899-908. 
</ul>

<p><hr>
Node:<a name="GNU%20Free%20Documentation%20License">GNU Free Documentation License</a>,
Next:<a rel=next accesskey=n href="#Concept%20Index">Concept Index</a>,
Previous:<a rel=previous accesskey=p href="#References">References</a>,
Up:<a rel=up accesskey=u href="#Top">Top</a>
<br>

<h2>GNU Free Documentation License</h2>

<div align="center">Version 1.1, March 2000</div>
<br><pre>Copyright &copy; 2000 Free Software Foundation, Inc.
51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA

Everyone is permitted to copy and distribute verbatim copies
of this license document, but changing it is not allowed.
</pre>

<ol type=1 start=0>
<li>PREAMBLE

<p>The purpose of this License is to make a manual, textbook, or other
written document <dfn>free</dfn> in the sense of freedom: to assure everyone
the effective freedom to copy and redistribute it, with or without
modifying it, either commercially or noncommercially.  Secondarily,
this License preserves for the author and publisher a way to get
credit for their work, while not being considered responsible for
modifications made by others.

<p>This License is a kind of "copyleft", which means that derivative
works of the document must themselves be free in the same sense.  It
complements the GNU General Public License, which is a copyleft
license designed for free software.

<p>We have designed this License in order to use it for manuals for free
software, because free software needs free documentation: a free
program should come with manuals providing the same freedoms that the
software does.  But this License is not limited to software manuals;
it can be used for any textual work, regardless of subject matter or
whether it is published as a printed book.  We recommend this License
principally for works whose purpose is instruction or reference.

</p><li>APPLICABILITY AND DEFINITIONS

<p>This License applies to any manual or other work that contains a
notice placed by the copyright holder saying it can be distributed
under the terms of this License.  The "Document", below, refers to any
such manual or work.  Any member of the public is a licensee, and is
addressed as "you".

<p>A "Modified Version" of the Document means any work containing the
Document or a portion of it, either copied verbatim, or with
modifications and/or translated into another language.

<p>A "Secondary Section" is a named appendix or a front-matter section of
the Document that deals exclusively with the relationship of the
publishers or authors of the Document to the Document's overall subject
(or to related matters) and contains nothing that could fall directly
within that overall subject.  (For example, if the Document is in part a
textbook of mathematics, a Secondary Section may not explain any
mathematics.)  The relationship could be a matter of historical
connection with the subject or with related matters, or of legal,
commercial, philosophical, ethical or political position regarding
them.

<p>The "Invariant Sections" are certain Secondary Sections whose titles
are designated, as being those of Invariant Sections, in the notice
that says that the Document is released under this License.

<p>The "Cover Texts" are certain short passages of text that are listed,
as Front-Cover Texts or Back-Cover Texts, in the notice that says that
the Document is released under this License.

<p>A "Transparent" copy of the Document means a machine-readable copy,
represented in a format whose specification is available to the
general public, whose contents can be viewed and edited directly and
straightforwardly with generic text editors or (for images composed of
pixels) generic paint programs or (for drawings) some widely available
drawing editor, and that is suitable for input to text formatters or
for automatic translation to a variety of formats suitable for input
to text formatters.  A copy made in an otherwise Transparent file
format whose markup has been designed to thwart or discourage
subsequent modification by readers is not Transparent.  A copy that is
not "Transparent" is called "Opaque".

<p>Examples of suitable formats for Transparent copies include plain
<small>ASCII</small> without markup, Texinfo input format, LaTeX input format,
<small>SGML</small> or <small>XML</small> using a publicly available
<small>DTD</small>, and standard-conforming simple <small>HTML</small> designed
for human modification.  Opaque formats include PostScript,
<small>PDF</small>, proprietary formats that can be read and edited only by
proprietary word processors, <small>SGML</small> or <small>XML</small> for which
the <small>DTD</small> and/or processing tools are not generally available,
and the machine-generated <small>HTML</small> produced by some word
processors for output purposes only.

<p>The "Title Page" means, for a printed book, the title page itself,
plus such following pages as are needed to hold, legibly, the material
this License requires to appear in the title page.  For works in
formats which do not have any title page as such, "Title Page" means
the text near the most prominent appearance of the work's title,
preceding the beginning of the body of the text.

</p><li>VERBATIM COPYING

<p>You may copy and distribute the Document in any medium, either
commercially or noncommercially, provided that this License, the
copyright notices, and the license notice saying this License applies
to the Document are reproduced in all copies, and that you add no other
conditions whatsoever to those of this License.  You may not use
technical measures to obstruct or control the reading or further
copying of the copies you make or distribute.  However, you may accept
compensation in exchange for copies.  If you distribute a large enough
number of copies you must also follow the conditions in section 3.

<p>You may also lend copies, under the same conditions stated above, and
you may publicly display copies.

</p><li>COPYING IN QUANTITY

<p>If you publish printed copies of the Document numbering more than 100,
and the Document's license notice requires Cover Texts, you must enclose
the copies in covers that carry, clearly and legibly, all these Cover
Texts: Front-Cover Texts on the front cover, and Back-Cover Texts on
the back cover.  Both covers must also clearly and legibly identify
you as the publisher of these copies.  The front cover must present
the full title with all words of the title equally prominent and
visible.  You may add other material on the covers in addition. 
Copying with changes limited to the covers, as long as they preserve
the title of the Document and satisfy these conditions, can be treated
as verbatim copying in other respects.

<p>If the required texts for either cover are too voluminous to fit
legibly, you should put the first ones listed (as many as fit
reasonably) on the actual cover, and continue the rest onto adjacent
pages.

<p>If you publish or distribute Opaque copies of the Document numbering
more than 100, you must either include a machine-readable Transparent
copy along with each Opaque copy, or state in or with each Opaque copy
a publicly-accessible computer-network location containing a complete
Transparent copy of the Document, free of added material, which the
general network-using public has access to download anonymously at no
charge using public-standard network protocols.  If you use the latter
option, you must take reasonably prudent steps, when you begin
distribution of Opaque copies in quantity, to ensure that this
Transparent copy will remain thus accessible at the stated location
until at least one year after the last time you distribute an Opaque
copy (directly or through your agents or retailers) of that edition to
the public.

<p>It is requested, but not required, that you contact the authors of the
Document well before redistributing any large number of copies, to give
them a chance to provide you with an updated version of the Document.

</p><li>MODIFICATIONS

<p>You may copy and distribute a Modified Version of the Document under
the conditions of sections 2 and 3 above, provided that you release
the Modified Version under precisely this License, with the Modified
Version filling the role of the Document, thus licensing distribution
and modification of the Modified Version to whoever possesses a copy
of it.  In addition, you must do these things in the Modified Version:

<ol type=A start=1>
</p><li>Use in the Title Page (and on the covers, if any) a title distinct
from that of the Document, and from those of previous versions
(which should, if there were any, be listed in the History section
of the Document).  You may use the same title as a previous version
if the original publisher of that version gives permission.

<li>List on the Title Page, as authors, one or more persons or entities
responsible for authorship of the modifications in the Modified
Version, together with at least five of the principal authors of the
Document (all of its principal authors, if it has less than five).

<li>State on the Title page the name of the publisher of the
Modified Version, as the publisher.

<li>Preserve all the copyright notices of the Document.

<li>Add an appropriate copyright notice for your modifications
adjacent to the other copyright notices.

<li>Include, immediately after the copyright notices, a license notice
giving the public permission to use the Modified Version under the
terms of this License, in the form shown in the Addendum below.

<li>Preserve in that license notice the full lists of Invariant Sections
and required Cover Texts given in the Document's license notice.

<li>Include an unaltered copy of this License.

<li>Preserve the section entitled "History", and its title, and add to
it an item stating at least the title, year, new authors, and
publisher of the Modified Version as given on the Title Page.  If
there is no section entitled "History" in the Document, create one
stating the title, year, authors, and publisher of the Document as
given on its Title Page, then add an item describing the Modified
Version as stated in the previous sentence.

<li>Preserve the network location, if any, given in the Document for
public access to a Transparent copy of the Document, and likewise
the network locations given in the Document for previous versions
it was based on.  These may be placed in the "History" section. 
You may omit a network location for a work that was published at
least four years before the Document itself, or if the original
publisher of the version it refers to gives permission.

<li>In any section entitled "Acknowledgments" or "Dedications",
preserve the section's title, and preserve in the section all the
substance and tone of each of the contributor acknowledgments
and/or dedications given therein.

<li>Preserve all the Invariant Sections of the Document,
unaltered in their text and in their titles.  Section numbers
or the equivalent are not considered part of the section titles.

<li>Delete any section entitled "Endorsements".  Such a section
may not be included in the Modified Version.

<li>Do not retitle any existing section as "Endorsements"
or to conflict in title with any Invariant Section.
</ol>

<p>If the Modified Version includes new front-matter sections or
appendices that qualify as Secondary Sections and contain no material
copied from the Document, you may at your option designate some or all
of these sections as invariant.  To do this, add their titles to the
list of Invariant Sections in the Modified Version's license notice. 
These titles must be distinct from any other section titles.

<p>You may add a section entitled "Endorsements", provided it contains
nothing but endorsements of your Modified Version by various
parties--for example, statements of peer review or that the text has
been approved by an organization as the authoritative definition of a
standard.

<p>You may add a passage of up to five words as a Front-Cover Text, and a
passage of up to 25 words as a Back-Cover Text, to the end of the list
of Cover Texts in the Modified Version.  Only one passage of
Front-Cover Text and one of Back-Cover Text may be added by (or
through arrangements made by) any one entity.  If the Document already
includes a cover text for the same cover, previously added by you or
by arrangement made by the same entity you are acting on behalf of,
you may not add another; but you may replace the old one, on explicit
permission from the previous publisher that added the old one.

<p>The author(s) and publisher(s) of the Document do not by this License
give permission to use their names for publicity for or to assert or
imply endorsement of any Modified Version.

</p><li>COMBINING DOCUMENTS

<p>You may combine the Document with other documents released under this
License, under the terms defined in section 4 above for modified
versions, provided that you include in the combination all of the
Invariant Sections of all of the original documents, unmodified, and
list them all as Invariant Sections of your combined work in its
license notice.

<p>The combined work need only contain one copy of this License, and
multiple identical Invariant Sections may be replaced with a single
copy.  If there are multiple Invariant Sections with the same name but
different contents, make the title of each such section unique by
adding at the end of it, in parentheses, the name of the original
author or publisher of that section if known, or else a unique number. 
Make the same adjustment to the section titles in the list of
Invariant Sections in the license notice of the combined work.

<p>In the combination, you must combine any sections entitled "History"
in the various original documents, forming one section entitled
"History"; likewise combine any sections entitled "Acknowledgments",
and any sections entitled "Dedications".  You must delete all sections
entitled "Endorsements."

</p><li>COLLECTIONS OF DOCUMENTS

<p>You may make a collection consisting of the Document and other documents
released under this License, and replace the individual copies of this
License in the various documents with a single copy that is included in
the collection, provided that you follow the rules of this License for
verbatim copying of each of the documents in all other respects.

<p>You may extract a single document from such a collection, and distribute
it individually under this License, provided you insert a copy of this
License into the extracted document, and follow this License in all
other respects regarding verbatim copying of that document.

</p><li>AGGREGATION WITH INDEPENDENT WORKS

<p>A compilation of the Document or its derivatives with other separate
and independent documents or works, in or on a volume of a storage or
distribution medium, does not as a whole count as a Modified Version
of the Document, provided no compilation copyright is claimed for the
compilation.  Such a compilation is called an "aggregate", and this
License does not apply to the other self-contained works thus compiled
with the Document, on account of their being thus compiled, if they
are not themselves derivative works of the Document.

<p>If the Cover Text requirement of section 3 is applicable to these
copies of the Document, then if the Document is less than one quarter
of the entire aggregate, the Document's Cover Texts may be placed on
covers that surround only the Document within the aggregate. 
Otherwise they must appear on covers around the whole aggregate.

</p><li>TRANSLATION

<p>Translation is considered a kind of modification, so you may
distribute translations of the Document under the terms of section 4. 
Replacing Invariant Sections with translations requires special
permission from their copyright holders, but you may include
translations of some or all Invariant Sections in addition to the
original versions of these Invariant Sections.  You may include a
translation of this License provided that you also include the
original English version of this License.  In case of a disagreement
between the translation and the original English version of this
License, the original English version will prevail.

</p><li>TERMINATION

<p>You may not copy, modify, sublicense, or distribute the Document except
as expressly provided for under this License.  Any other attempt to
copy, modify, sublicense or distribute the Document is void, and will
automatically terminate your rights under this License.  However,
parties who have received copies, or rights, from you under this
License will not have their licenses terminated so long as such
parties remain in full compliance.

</p><li>FUTURE REVISIONS OF THIS LICENSE

<p>The Free Software Foundation may publish new, revised versions
of the GNU Free Documentation License from time to time.  Such new
versions will be similar in spirit to the present version, but may
differ in detail to address new problems or concerns.  See
<a href="http://www.gnu.org/copyleft/">http://www.gnu.org/copyleft/</a>.

<p>Each version of the License is given a distinguishing version number. 
If the Document specifies that a particular numbered version of this
License "or any later version" applies to it, you have the option of
following the terms and conditions either of that specified version or
of any later version that has been published (not as a draft) by the
Free Software Foundation.  If the Document does not specify a version
number of this License, you may choose any version ever published (not
as a draft) by the Free Software Foundation.
</ol>

<h3>ADDENDUM: How to use this License for your documents</h3>

<p>To use this License in a document you have written, include a copy of
the License in the document and put the following copyright and
license notices just after the title page:

<br><pre>  Copyright (C)  <var>year</var>  <var>your name</var>.
  Permission is granted to copy, distribute and/or modify this document
  under the terms of the GNU Free Documentation License, Version 1.1
  or any later version published by the Free Software Foundation;
  with the Invariant Sections being <var>list their titles</var>, with the
  Front-Cover Texts being <var>list</var>, and with the Back-Cover Texts being <var>list</var>.
  A copy of the license is included in the section entitled ``GNU
  Free Documentation License''.
</pre>

<p>If you have no Invariant Sections, write "with no Invariant Sections"
instead of saying which ones are invariant.  If you have no
Front-Cover Texts, write "no Front-Cover Texts" instead of
"Front-Cover Texts being <var>list</var>"; likewise for Back-Cover Texts.

<p>If your document contains nontrivial examples of program code, we
recommend releasing these examples in parallel under your choice of
free software license, such as the GNU General Public License,
to permit their use in free software.

<p><hr>
Node:<a name="Concept%20Index">Concept Index</a>,
Next:<a rel=next accesskey=n href="#Function%20Index">Function Index</a>,
Previous:<a rel=previous accesskey=p href="#GNU%20Free%20Documentation%20License">GNU Free Documentation License</a>,
Up:<a rel=up accesskey=u href="#Top">Top</a>
<br>

<h2>Concept Index</h2>

<ul compact>
<li>ABI: <a href="#ABI%20and%20ISA">ABI and ISA</a>
<li>About this manual: <a href="#Introduction%20to%20GMP">Introduction to GMP</a>
<li>Algorithms: <a href="#Algorithms">Algorithms</a>
<li><code>alloca</code>: <a href="#Build%20Options">Build Options</a>
<li>Allocation of memory: <a href="#Custom%20Allocation">Custom Allocation</a>
<li>Anonymous FTP of latest version: <a href="#Introduction%20to%20GMP">Introduction to GMP</a>
<li>Application Binary Interface: <a href="#ABI%20and%20ISA">ABI and ISA</a>
<li>Arithmetic functions: <a href="#Float%20Arithmetic">Float Arithmetic</a>, <a href="#Rational%20Arithmetic">Rational Arithmetic</a>, <a href="#Integer%20Arithmetic">Integer Arithmetic</a>
<li>Assignment functions: <a href="#Assigning%20Floats">Assigning Floats</a>, <a href="#Assigning%20Integers">Assigning Integers</a>
<li>Autoconf detections: <a href="#Autoconf">Autoconf</a>
<li>Basics: <a href="#GMP%20Basics">GMP Basics</a>
<li>Berkeley MP compatible functions: <a href="#BSD%20Compatible%20Functions">BSD Compatible Functions</a>
<li>Binomial coefficient functions: <a href="#Number%20Theoretic%20Functions">Number Theoretic Functions</a>
<li>Bit manipulation functions: <a href="#Integer%20Logic%20and%20Bit%20Fiddling">Integer Logic and Bit Fiddling</a>
<li>Bit shift left: <a href="#Integer%20Arithmetic">Integer Arithmetic</a>
<li>Bit shift right: <a href="#Integer%20Division">Integer Division</a>
<li>Bits per limb: <a href="#Useful%20Macros%20and%20Constants">Useful Macros and Constants</a>
<li>BSD MP compatible functions: <a href="#BSD%20Compatible%20Functions">BSD Compatible Functions</a>
<li>Bug reporting: <a href="#Reporting%20Bugs">Reporting Bugs</a>
<li>Build notes for binary packaging: <a href="#Notes%20for%20Package%20Builds">Notes for Package Builds</a>
<li>Build notes for particular systems: <a href="#Notes%20for%20Particular%20Systems">Notes for Particular Systems</a>
<li>Build options: <a href="#Build%20Options">Build Options</a>
<li>Build problems known: <a href="#Known%20Build%20Problems">Known Build Problems</a>
<li>Building GMP: <a href="#Installing%20GMP">Installing GMP</a>
<li>C++ Interface: <a href="#C++%20Class%20Interface">C++ Class Interface</a>
<li>C++ <code>istream</code> input: <a href="#C++%20Formatted%20Input">C++ Formatted Input</a>
<li>C++ <code>ostream</code> output: <a href="#C++%20Formatted%20Output">C++ Formatted Output</a>
<li>Comparison functions: <a href="#Float%20Comparison">Float Comparison</a>, <a href="#Comparing%20Rationals">Comparing Rationals</a>, <a href="#Integer%20Comparisons">Integer Comparisons</a>
<li>Compatibility with older versions: <a href="#Compatibility%20with%20older%20versions">Compatibility with older versions</a>
<li>Conditions for copying GNU MP: <a href="#Copying">Copying</a>
<li>Configuring GMP: <a href="#Installing%20GMP">Installing GMP</a>
<li>Constants: <a href="#Useful%20Macros%20and%20Constants">Useful Macros and Constants</a>
<li>Contributors: <a href="#Contributors">Contributors</a>
<li>Conventions for parameters: <a href="#Parameter%20Conventions">Parameter Conventions</a>
<li>Conventions for variables: <a href="#Variable%20Conventions">Variable Conventions</a>
<li>Conversion functions: <a href="#Converting%20Floats">Converting Floats</a>, <a href="#Rational%20Conversions">Rational Conversions</a>, <a href="#Converting%20Integers">Converting Integers</a>
<li>Copying conditions: <a href="#Copying">Copying</a>
<li>CPUs supported: <a href="#Introduction%20to%20GMP">Introduction to GMP</a>
<li>Custom allocation: <a href="#Custom%20Allocation">Custom Allocation</a>
<li>Debugging: <a href="#Debugging">Debugging</a>
<li>Demonstration programs: <a href="#Build%20Options">Build Options</a>
<li><code>DESTDIR</code>: <a href="#Known%20Build%20Problems">Known Build Problems</a>
<li>Division algorithms: <a href="#Division%20Algorithms">Division Algorithms</a>
<li>Division functions: <a href="#Float%20Arithmetic">Float Arithmetic</a>, <a href="#Rational%20Arithmetic">Rational Arithmetic</a>, <a href="#Integer%20Division">Integer Division</a>
<li>Efficiency: <a href="#Efficiency">Efficiency</a>
<li>Exact division functions: <a href="#Integer%20Division">Integer Division</a>
<li>Example programs: <a href="#Build%20Options">Build Options</a>
<li>Exponentiation functions: <a href="#Float%20Arithmetic">Float Arithmetic</a>, <a href="#Integer%20Exponentiation">Integer Exponentiation</a>
<li>Export: <a href="#Integer%20Import%20and%20Export">Integer Import and Export</a>
<li>Extended GCD: <a href="#Number%20Theoretic%20Functions">Number Theoretic Functions</a>
<li>Factorial functions: <a href="#Number%20Theoretic%20Functions">Number Theoretic Functions</a>
<li>FDL, GNU Free Documentation License: <a href="#GNU%20Free%20Documentation%20License">GNU Free Documentation License</a>
<li>Fibonacci sequence functions: <a href="#Number%20Theoretic%20Functions">Number Theoretic Functions</a>
<li>Float arithmetic functions: <a href="#Float%20Arithmetic">Float Arithmetic</a>
<li>Float assignment functions: <a href="#Assigning%20Floats">Assigning Floats</a>
<li>Float comparison functions: <a href="#Float%20Comparison">Float Comparison</a>
<li>Float conversion functions: <a href="#Converting%20Floats">Converting Floats</a>
<li>Float functions: <a href="#Floating-point%20Functions">Floating-point Functions</a>
<li>Float init and assign functions: <a href="#Simultaneous%20Float%20Init%20&amp;%20Assign">Simultaneous Float Init & Assign</a>
<li>Float initialization functions: <a href="#Initializing%20Floats">Initializing Floats</a>
<li>Float input and output functions: <a href="#I%2fO%20of%20Floats">I/O of Floats</a>
<li>Float miscellaneous functions: <a href="#Miscellaneous%20Float%20Functions">Miscellaneous Float Functions</a>
<li>Float sign tests: <a href="#Float%20Comparison">Float Comparison</a>
<li>Floating-point functions: <a href="#Floating-point%20Functions">Floating-point Functions</a>
<li>Floating-point number: <a href="#Nomenclature%20and%20Types">Nomenclature and Types</a>
<li>Formatted input: <a href="#Formatted%20Input">Formatted Input</a>
<li>Formatted output: <a href="#Formatted%20Output">Formatted Output</a>
<li>FTP of latest version: <a href="#Introduction%20to%20GMP">Introduction to GMP</a>
<li>Function classes: <a href="#Function%20Classes">Function Classes</a>
<li>GMP version number: <a href="#Useful%20Macros%20and%20Constants">Useful Macros and Constants</a>
<li><code>gmp.h</code>: <a href="#Headers%20and%20Libraries">Headers and Libraries</a>
<li>gmpxx.h: <a href="#C++%20Interface%20General">C++ Interface General</a>
<li>GNU Free Documentation License: <a href="#GNU%20Free%20Documentation%20License">GNU Free Documentation License</a>
<li>Greatest common divisor algorithms: <a href="#Greatest%20Common%20Divisor%20Algorithms">Greatest Common Divisor Algorithms</a>
<li>Greatest common divisor functions: <a href="#Number%20Theoretic%20Functions">Number Theoretic Functions</a>
<li>Headers: <a href="#Headers%20and%20Libraries">Headers and Libraries</a>
<li>Home page: <a href="#Introduction%20to%20GMP">Introduction to GMP</a>
<li>I/O functions: <a href="#I%2fO%20of%20Floats">I/O of Floats</a>, <a href="#I%2fO%20of%20Rationals">I/O of Rationals</a>, <a href="#I%2fO%20of%20Integers">I/O of Integers</a>
<li>Import: <a href="#Integer%20Import%20and%20Export">Integer Import and Export</a>
<li>Initialization and assignment functions: <a href="#Simultaneous%20Float%20Init%20&amp;%20Assign">Simultaneous Float Init & Assign</a>, <a href="#Initializing%20Rationals">Initializing Rationals</a>, <a href="#Simultaneous%20Integer%20Init%20&amp;%20Assign">Simultaneous Integer Init & Assign</a>
<li>Initialization functions: <a href="#Initializing%20Floats">Initializing Floats</a>, <a href="#Initializing%20Integers">Initializing Integers</a>
<li>Input functions: <a href="#I%2fO%20of%20Floats">I/O of Floats</a>, <a href="#I%2fO%20of%20Rationals">I/O of Rationals</a>, <a href="#I%2fO%20of%20Integers">I/O of Integers</a>
<li>Installing GMP: <a href="#Installing%20GMP">Installing GMP</a>
<li>Instruction Set Architecture: <a href="#ABI%20and%20ISA">ABI and ISA</a>
<li>Integer: <a href="#Nomenclature%20and%20Types">Nomenclature and Types</a>
<li>Integer arithmetic functions: <a href="#Integer%20Arithmetic">Integer Arithmetic</a>
<li>Integer assignment functions: <a href="#Assigning%20Integers">Assigning Integers</a>
<li>Integer bit manipulation functions: <a href="#Integer%20Logic%20and%20Bit%20Fiddling">Integer Logic and Bit Fiddling</a>
<li>Integer comparison functions: <a href="#Integer%20Comparisons">Integer Comparisons</a>
<li>Integer conversion functions: <a href="#Converting%20Integers">Converting Integers</a>
<li>Integer division functions: <a href="#Integer%20Division">Integer Division</a>
<li>Integer exponentiation functions: <a href="#Integer%20Exponentiation">Integer Exponentiation</a>
<li>Integer export: <a href="#Integer%20Import%20and%20Export">Integer Import and Export</a>
<li>Integer functions: <a href="#Integer%20Functions">Integer Functions</a>
<li>Integer import: <a href="#Integer%20Import%20and%20Export">Integer Import and Export</a>
<li>Integer init and assign: <a href="#Simultaneous%20Integer%20Init%20&amp;%20Assign">Simultaneous Integer Init & Assign</a>
<li>Integer initialization functions: <a href="#Initializing%20Integers">Initializing Integers</a>
<li>Integer input and output functions: <a href="#I%2fO%20of%20Integers">I/O of Integers</a>
<li>Integer miscellaneous functions: <a href="#Miscellaneous%20Integer%20Functions">Miscellaneous Integer Functions</a>
<li>Integer random number functions: <a href="#Integer%20Random%20Numbers">Integer Random Numbers</a>
<li>Integer root functions: <a href="#Integer%20Roots">Integer Roots</a>
<li>Integer sign tests: <a href="#Integer%20Comparisons">Integer Comparisons</a>
<li>Introduction: <a href="#Introduction%20to%20GMP">Introduction to GMP</a>
<li>ISA: <a href="#ABI%20and%20ISA">ABI and ISA</a>
<li><code>istream</code> input: <a href="#C++%20Formatted%20Input">C++ Formatted Input</a>
<li>Jacobi symbol functions: <a href="#Number%20Theoretic%20Functions">Number Theoretic Functions</a>
<li>Kronecker symbol functions: <a href="#Number%20Theoretic%20Functions">Number Theoretic Functions</a>
<li>Latest version of GMP: <a href="#Introduction%20to%20GMP">Introduction to GMP</a>
<li>Least common multiple functions: <a href="#Number%20Theoretic%20Functions">Number Theoretic Functions</a>
<li>Libraries: <a href="#Headers%20and%20Libraries">Headers and Libraries</a>
<li>Libtool versioning: <a href="#Notes%20for%20Package%20Builds">Notes for Package Builds</a>
<li>License conditions: <a href="#Copying">Copying</a>
<li>Limb: <a href="#Nomenclature%20and%20Types">Nomenclature and Types</a>
<li>Limb size: <a href="#Useful%20Macros%20and%20Constants">Useful Macros and Constants</a>
<li>Linking: <a href="#Headers%20and%20Libraries">Headers and Libraries</a>
<li>Logical functions: <a href="#Integer%20Logic%20and%20Bit%20Fiddling">Integer Logic and Bit Fiddling</a>
<li>Low-level functions: <a href="#Low-level%20Functions">Low-level Functions</a>
<li>Lucas number functions: <a href="#Number%20Theoretic%20Functions">Number Theoretic Functions</a>
<li>Mailing list: <a href="#Introduction%20to%20GMP">Introduction to GMP</a>
<li>Memory allocation: <a href="#Custom%20Allocation">Custom Allocation</a>
<li>Memory Management: <a href="#Memory%20Management">Memory Management</a>
<li>Miscellaneous float functions: <a href="#Miscellaneous%20Float%20Functions">Miscellaneous Float Functions</a>
<li>Miscellaneous integer functions: <a href="#Miscellaneous%20Integer%20Functions">Miscellaneous Integer Functions</a>
<li>Modular inverse functions: <a href="#Number%20Theoretic%20Functions">Number Theoretic Functions</a>
<li><code>mp.h</code>: <a href="#BSD%20Compatible%20Functions">BSD Compatible Functions</a>
<li>MPFR: <a href="#Build%20Options">Build Options</a>
<li>mpfrxx.h: <a href="#C++%20Interface%20MPFR">C++ Interface MPFR</a>
<li>Multi-threading: <a href="#Reentrancy">Reentrancy</a>
<li>Multiplication algorithms: <a href="#Multiplication%20Algorithms">Multiplication Algorithms</a>
<li>Nails: <a href="#Low-level%20Functions">Low-level Functions</a>
<li>Nomenclature: <a href="#Nomenclature%20and%20Types">Nomenclature and Types</a>
<li>Number theoretic functions: <a href="#Number%20Theoretic%20Functions">Number Theoretic Functions</a>
<li>Numerator and denominator: <a href="#Applying%20Integer%20Functions">Applying Integer Functions</a>
<li><code>ostream</code> output: <a href="#C++%20Formatted%20Output">C++ Formatted Output</a>
<li>Output functions: <a href="#I%2fO%20of%20Floats">I/O of Floats</a>, <a href="#I%2fO%20of%20Rationals">I/O of Rationals</a>, <a href="#I%2fO%20of%20Integers">I/O of Integers</a>
<li>Packaged builds: <a href="#Notes%20for%20Package%20Builds">Notes for Package Builds</a>
<li>Parameter conventions: <a href="#Parameter%20Conventions">Parameter Conventions</a>
<li>Particular systems: <a href="#Notes%20for%20Particular%20Systems">Notes for Particular Systems</a>
<li>Powering algorithms: <a href="#Powering%20Algorithms">Powering Algorithms</a>
<li>Powering functions: <a href="#Float%20Arithmetic">Float Arithmetic</a>, <a href="#Integer%20Exponentiation">Integer Exponentiation</a>
<li>Precision of floats: <a href="#Floating-point%20Functions">Floating-point Functions</a>
<li>Prime testing functions: <a href="#Number%20Theoretic%20Functions">Number Theoretic Functions</a>
<li><code>printf</code> formatted output: <a href="#Formatted%20Output">Formatted Output</a>
<li>Profiling: <a href="#Profiling">Profiling</a>
<li>Radix conversion algorithms: <a href="#Radix%20Conversion%20Algorithms">Radix Conversion Algorithms</a>
<li>Random number functions: <a href="#Random%20Number%20Functions">Random Number Functions</a>, <a href="#Integer%20Random%20Numbers">Integer Random Numbers</a>
<li>Random number seeding: <a href="#Random%20State%20Seeding">Random State Seeding</a>
<li>Random number state: <a href="#Random%20State%20Initialization">Random State Initialization</a>
<li>Rational arithmetic functions: <a href="#Rational%20Arithmetic">Rational Arithmetic</a>
<li>Rational comparison functions: <a href="#Comparing%20Rationals">Comparing Rationals</a>
<li>Rational conversion functions: <a href="#Rational%20Conversions">Rational Conversions</a>
<li>Rational init and assign: <a href="#Initializing%20Rationals">Initializing Rationals</a>
<li>Rational input and output functions: <a href="#I%2fO%20of%20Rationals">I/O of Rationals</a>
<li>Rational number: <a href="#Nomenclature%20and%20Types">Nomenclature and Types</a>
<li>Rational number functions: <a href="#Rational%20Number%20Functions">Rational Number Functions</a>
<li>Rational numerator and denominator: <a href="#Applying%20Integer%20Functions">Applying Integer Functions</a>
<li>Rational sign tests: <a href="#Comparing%20Rationals">Comparing Rationals</a>
<li>Reentrancy: <a href="#Reentrancy">Reentrancy</a>
<li>References: <a href="#References">References</a>
<li>Reporting bugs: <a href="#Reporting%20Bugs">Reporting Bugs</a>
<li>Root extraction algorithms: <a href="#Root%20Extraction%20Algorithms">Root Extraction Algorithms</a>
<li>Root extraction functions: <a href="#Float%20Arithmetic">Float Arithmetic</a>, <a href="#Integer%20Roots">Integer Roots</a>
<li><code>scanf</code> formatted input: <a href="#Formatted%20Input">Formatted Input</a>
<li>Shared library versioning: <a href="#Notes%20for%20Package%20Builds">Notes for Package Builds</a>
<li>Sign tests: <a href="#Float%20Comparison">Float Comparison</a>, <a href="#Comparing%20Rationals">Comparing Rationals</a>, <a href="#Integer%20Comparisons">Integer Comparisons</a>
<li>Stack overflow segfaults: <a href="#Build%20Options">Build Options</a>
<li>Stripped libraries: <a href="#Known%20Build%20Problems">Known Build Problems</a>
<li>Systems: <a href="#Notes%20for%20Particular%20Systems">Notes for Particular Systems</a>
<li>Thread safety: <a href="#Reentrancy">Reentrancy</a>
<li>Types: <a href="#Nomenclature%20and%20Types">Nomenclature and Types</a>
<li>Upward compatibility: <a href="#Compatibility%20with%20older%20versions">Compatibility with older versions</a>
<li>Useful macros and constants: <a href="#Useful%20Macros%20and%20Constants">Useful Macros and Constants</a>
<li>User-defined precision: <a href="#Floating-point%20Functions">Floating-point Functions</a>
<li>Variable conventions: <a href="#Variable%20Conventions">Variable Conventions</a>
<li>Version number: <a href="#Useful%20Macros%20and%20Constants">Useful Macros and Constants</a>
<li>Web page: <a href="#Introduction%20to%20GMP">Introduction to GMP</a>
</ul>
<p><hr>
Node:<a name="Function%20Index">Function Index</a>,
Previous:<a rel=previous accesskey=p href="#Concept%20Index">Concept Index</a>,
Up:<a rel=up accesskey=u href="#Top">Top</a>
<br>

<h2>Function and Type Index</h2>

<ul compact>
<li><code>*mpz_export</code>: <a href="#Integer%20Import%20and%20Export">Integer Import and Export</a>
<li><code>__GNU_MP_VERSION</code>: <a href="#Useful%20Macros%20and%20Constants">Useful Macros and Constants</a>
<li><code>__GNU_MP_VERSION_MINOR</code>: <a href="#Useful%20Macros%20and%20Constants">Useful Macros and Constants</a>
<li><code>__GNU_MP_VERSION_PATCHLEVEL</code>: <a href="#Useful%20Macros%20and%20Constants">Useful Macros and Constants</a>
<li><code>_mpz_realloc</code>: <a href="#Initializing%20Integers">Initializing Integers</a>
<li><code>abs</code>: <a href="#C++%20Interface%20Floats">C++ Interface Floats</a>, <a href="#C++%20Interface%20Rationals">C++ Interface Rationals</a>, <a href="#C++%20Interface%20Integers">C++ Interface Integers</a>
<li><code>allocate_function</code>: <a href="#Custom%20Allocation">Custom Allocation</a>
<li><code>ceil</code>: <a href="#C++%20Interface%20Floats">C++ Interface Floats</a>
<li><code>cmp</code>: <a href="#C++%20Interface%20Floats">C++ Interface Floats</a>, <a href="#C++%20Interface%20Rationals">C++ Interface Rationals</a>, <a href="#C++%20Interface%20Integers">C++ Interface Integers</a>
<li><code>deallocate_function</code>: <a href="#Custom%20Allocation">Custom Allocation</a>
<li><code>floor</code>: <a href="#C++%20Interface%20Floats">C++ Interface Floats</a>
<li><code>gcd</code>: <a href="#BSD%20Compatible%20Functions">BSD Compatible Functions</a>
<li><code>gmp_asprintf</code>: <a href="#Formatted%20Output%20Functions">Formatted Output Functions</a>
<li><code>gmp_fprintf</code>: <a href="#Formatted%20Output%20Functions">Formatted Output Functions</a>
<li><code>gmp_fscanf</code>: <a href="#Formatted%20Input%20Functions">Formatted Input Functions</a>
<li><code>GMP_LIMB_BITS</code>: <a href="#Low-level%20Functions">Low-level Functions</a>
<li><code>GMP_NAIL_BITS</code>: <a href="#Low-level%20Functions">Low-level Functions</a>
<li><code>GMP_NAIL_MASK</code>: <a href="#Low-level%20Functions">Low-level Functions</a>
<li><code>GMP_NUMB_BITS</code>: <a href="#Low-level%20Functions">Low-level Functions</a>
<li><code>GMP_NUMB_MASK</code>: <a href="#Low-level%20Functions">Low-level Functions</a>
<li><code>GMP_NUMB_MAX</code>: <a href="#Low-level%20Functions">Low-level Functions</a>
<li><code>gmp_obstack_printf</code>: <a href="#Formatted%20Output%20Functions">Formatted Output Functions</a>
<li><code>gmp_obstack_vprintf</code>: <a href="#Formatted%20Output%20Functions">Formatted Output Functions</a>
<li><code>gmp_printf</code>: <a href="#Formatted%20Output%20Functions">Formatted Output Functions</a>
<li><code>gmp_randclass</code>: <a href="#C++%20Interface%20Random%20Numbers">C++ Interface Random Numbers</a>
<li><code>gmp_randclass::get_f</code>: <a href="#C++%20Interface%20Random%20Numbers">C++ Interface Random Numbers</a>
<li><code>gmp_randclass::get_z_bits</code>: <a href="#C++%20Interface%20Random%20Numbers">C++ Interface Random Numbers</a>
<li><code>gmp_randclass::get_z_range</code>: <a href="#C++%20Interface%20Random%20Numbers">C++ Interface Random Numbers</a>
<li><code>gmp_randclass::gmp_randclass</code>: <a href="#C++%20Interface%20Random%20Numbers">C++ Interface Random Numbers</a>
<li><code>gmp_randclass::seed</code>: <a href="#C++%20Interface%20Random%20Numbers">C++ Interface Random Numbers</a>
<li><code>gmp_randclear</code>: <a href="#Random%20State%20Initialization">Random State Initialization</a>
<li><code>gmp_randinit</code>: <a href="#Random%20State%20Initialization">Random State Initialization</a>
<li><code>gmp_randinit_default</code>: <a href="#Random%20State%20Initialization">Random State Initialization</a>
<li><code>gmp_randinit_lc_2exp</code>: <a href="#Random%20State%20Initialization">Random State Initialization</a>
<li><code>gmp_randinit_lc_2exp_size</code>: <a href="#Random%20State%20Initialization">Random State Initialization</a>
<li><code>gmp_randseed</code>: <a href="#Random%20State%20Seeding">Random State Seeding</a>
<li><code>gmp_randseed_ui</code>: <a href="#Random%20State%20Seeding">Random State Seeding</a>
<li><code>gmp_scanf</code>: <a href="#Formatted%20Input%20Functions">Formatted Input Functions</a>
<li><code>gmp_snprintf</code>: <a href="#Formatted%20Output%20Functions">Formatted Output Functions</a>
<li><code>gmp_sprintf</code>: <a href="#Formatted%20Output%20Functions">Formatted Output Functions</a>
<li><code>gmp_sscanf</code>: <a href="#Formatted%20Input%20Functions">Formatted Input Functions</a>
<li><code>gmp_vasprintf</code>: <a href="#Formatted%20Output%20Functions">Formatted Output Functions</a>
<li><code>gmp_version</code>: <a href="#Useful%20Macros%20and%20Constants">Useful Macros and Constants</a>
<li><code>gmp_vfprintf</code>: <a href="#Formatted%20Output%20Functions">Formatted Output Functions</a>
<li><code>gmp_vfscanf</code>: <a href="#Formatted%20Input%20Functions">Formatted Input Functions</a>
<li><code>gmp_vprintf</code>: <a href="#Formatted%20Output%20Functions">Formatted Output Functions</a>
<li><code>gmp_vscanf</code>: <a href="#Formatted%20Input%20Functions">Formatted Input Functions</a>
<li><code>gmp_vsnprintf</code>: <a href="#Formatted%20Output%20Functions">Formatted Output Functions</a>
<li><code>gmp_vsprintf</code>: <a href="#Formatted%20Output%20Functions">Formatted Output Functions</a>
<li><code>gmp_vsscanf</code>: <a href="#Formatted%20Input%20Functions">Formatted Input Functions</a>
<li><code>hypot</code>: <a href="#C++%20Interface%20Floats">C++ Interface Floats</a>
<li><code>itom</code>: <a href="#BSD%20Compatible%20Functions">BSD Compatible Functions</a>
<li><code>madd</code>: <a href="#BSD%20Compatible%20Functions">BSD Compatible Functions</a>
<li><code>mcmp</code>: <a href="#BSD%20Compatible%20Functions">BSD Compatible Functions</a>
<li><code>mdiv</code>: <a href="#BSD%20Compatible%20Functions">BSD Compatible Functions</a>
<li><code>mfree</code>: <a href="#BSD%20Compatible%20Functions">BSD Compatible Functions</a>
<li><code>min</code>: <a href="#BSD%20Compatible%20Functions">BSD Compatible Functions</a>
<li><code>mout</code>: <a href="#BSD%20Compatible%20Functions">BSD Compatible Functions</a>
<li><code>move</code>: <a href="#BSD%20Compatible%20Functions">BSD Compatible Functions</a>
<li><code>mp_bits_per_limb</code>: <a href="#Useful%20Macros%20and%20Constants">Useful Macros and Constants</a>
<li><code><code>mp_limb_t</code></code>: <a href="#Nomenclature%20and%20Types">Nomenclature and Types</a>
<li><code>mp_set_memory_functions</code>: <a href="#Custom%20Allocation">Custom Allocation</a>
<li><code>mpf_abs</code>: <a href="#Float%20Arithmetic">Float Arithmetic</a>
<li><code>mpf_add</code>: <a href="#Float%20Arithmetic">Float Arithmetic</a>
<li><code>mpf_add_ui</code>: <a href="#Float%20Arithmetic">Float Arithmetic</a>
<li><code>mpf_ceil</code>: <a href="#Miscellaneous%20Float%20Functions">Miscellaneous Float Functions</a>
<li><code>mpf_class</code>: <a href="#C++%20Interface%20General">C++ Interface General</a>
<li><code>mpf_class::fits_sint_p</code>: <a href="#C++%20Interface%20Floats">C++ Interface Floats</a>
<li><code>mpf_class::fits_slong_p</code>: <a href="#C++%20Interface%20Floats">C++ Interface Floats</a>
<li><code>mpf_class::fits_sshort_p</code>: <a href="#C++%20Interface%20Floats">C++ Interface Floats</a>
<li><code>mpf_class::fits_uint_p</code>: <a href="#C++%20Interface%20Floats">C++ Interface Floats</a>
<li><code>mpf_class::fits_ulong_p</code>: <a href="#C++%20Interface%20Floats">C++ Interface Floats</a>
<li><code>mpf_class::fits_ushort_p</code>: <a href="#C++%20Interface%20Floats">C++ Interface Floats</a>
<li><code>mpf_class::get_d</code>: <a href="#C++%20Interface%20Floats">C++ Interface Floats</a>
<li><code>mpf_class::get_mpf_t</code>: <a href="#C++%20Interface%20General">C++ Interface General</a>
<li><code>mpf_class::get_prec</code>: <a href="#C++%20Interface%20Floats">C++ Interface Floats</a>
<li><code>mpf_class::get_si</code>: <a href="#C++%20Interface%20Floats">C++ Interface Floats</a>
<li><code>mpf_class::get_ui</code>: <a href="#C++%20Interface%20Floats">C++ Interface Floats</a>
<li><code>mpf_class::mpf_class</code>: <a href="#C++%20Interface%20Floats">C++ Interface Floats</a>
<li><code>mpf_class::set_prec</code>: <a href="#C++%20Interface%20Floats">C++ Interface Floats</a>
<li><code>mpf_class::set_prec_raw</code>: <a href="#C++%20Interface%20Floats">C++ Interface Floats</a>
<li><code>mpf_clear</code>: <a href="#Initializing%20Floats">Initializing Floats</a>
<li><code>mpf_cmp</code>: <a href="#Float%20Comparison">Float Comparison</a>
<li><code>mpf_cmp_d</code>: <a href="#Float%20Comparison">Float Comparison</a>
<li><code>mpf_cmp_si</code>: <a href="#Float%20Comparison">Float Comparison</a>
<li><code>mpf_cmp_ui</code>: <a href="#Float%20Comparison">Float Comparison</a>
<li><code>mpf_div</code>: <a href="#Float%20Arithmetic">Float Arithmetic</a>
<li><code>mpf_div_2exp</code>: <a href="#Float%20Arithmetic">Float Arithmetic</a>
<li><code>mpf_div_ui</code>: <a href="#Float%20Arithmetic">Float Arithmetic</a>
<li><code>mpf_eq</code>: <a href="#Float%20Comparison">Float Comparison</a>
<li><code>mpf_fits_sint_p</code>: <a href="#Miscellaneous%20Float%20Functions">Miscellaneous Float Functions</a>
<li><code>mpf_fits_slong_p</code>: <a href="#Miscellaneous%20Float%20Functions">Miscellaneous Float Functions</a>
<li><code>mpf_fits_sshort_p</code>: <a href="#Miscellaneous%20Float%20Functions">Miscellaneous Float Functions</a>
<li><code>mpf_fits_uint_p</code>: <a href="#Miscellaneous%20Float%20Functions">Miscellaneous Float Functions</a>
<li><code>mpf_fits_ulong_p</code>: <a href="#Miscellaneous%20Float%20Functions">Miscellaneous Float Functions</a>
<li><code>mpf_fits_ushort_p</code>: <a href="#Miscellaneous%20Float%20Functions">Miscellaneous Float Functions</a>
<li><code>mpf_floor</code>: <a href="#Miscellaneous%20Float%20Functions">Miscellaneous Float Functions</a>
<li><code>mpf_get_d</code>: <a href="#Converting%20Floats">Converting Floats</a>
<li><code>mpf_get_d_2exp</code>: <a href="#Converting%20Floats">Converting Floats</a>
<li><code>mpf_get_default_prec</code>: <a href="#Initializing%20Floats">Initializing Floats</a>
<li><code>mpf_get_prec</code>: <a href="#Initializing%20Floats">Initializing Floats</a>
<li><code>mpf_get_si</code>: <a href="#Converting%20Floats">Converting Floats</a>
<li><code>mpf_get_str</code>: <a href="#Converting%20Floats">Converting Floats</a>
<li><code>mpf_get_ui</code>: <a href="#Converting%20Floats">Converting Floats</a>
<li><code>mpf_init</code>: <a href="#Initializing%20Floats">Initializing Floats</a>
<li><code>mpf_init2</code>: <a href="#Initializing%20Floats">Initializing Floats</a>
<li><code>mpf_init_set</code>: <a href="#Simultaneous%20Float%20Init%20&amp;%20Assign">Simultaneous Float Init & Assign</a>
<li><code>mpf_init_set_d</code>: <a href="#Simultaneous%20Float%20Init%20&amp;%20Assign">Simultaneous Float Init & Assign</a>
<li><code>mpf_init_set_si</code>: <a href="#Simultaneous%20Float%20Init%20&amp;%20Assign">Simultaneous Float Init & Assign</a>
<li><code>mpf_init_set_str</code>: <a href="#Simultaneous%20Float%20Init%20&amp;%20Assign">Simultaneous Float Init & Assign</a>
<li><code>mpf_init_set_ui</code>: <a href="#Simultaneous%20Float%20Init%20&amp;%20Assign">Simultaneous Float Init & Assign</a>
<li><code>mpf_inp_str</code>: <a href="#I%2fO%20of%20Floats">I/O of Floats</a>
<li><code>mpf_integer_p</code>: <a href="#Miscellaneous%20Float%20Functions">Miscellaneous Float Functions</a>
<li><code>mpf_mul</code>: <a href="#Float%20Arithmetic">Float Arithmetic</a>
<li><code>mpf_mul_2exp</code>: <a href="#Float%20Arithmetic">Float Arithmetic</a>
<li><code>mpf_mul_ui</code>: <a href="#Float%20Arithmetic">Float Arithmetic</a>
<li><code>mpf_neg</code>: <a href="#Float%20Arithmetic">Float Arithmetic</a>
<li><code>mpf_out_str</code>: <a href="#I%2fO%20of%20Floats">I/O of Floats</a>
<li><code>mpf_pow_ui</code>: <a href="#Float%20Arithmetic">Float Arithmetic</a>
<li><code>mpf_random2</code>: <a href="#Miscellaneous%20Float%20Functions">Miscellaneous Float Functions</a>
<li><code>mpf_reldiff</code>: <a href="#Float%20Comparison">Float Comparison</a>
<li><code>mpf_set</code>: <a href="#Assigning%20Floats">Assigning Floats</a>
<li><code>mpf_set_d</code>: <a href="#Assigning%20Floats">Assigning Floats</a>
<li><code>mpf_set_default_prec</code>: <a href="#Initializing%20Floats">Initializing Floats</a>
<li><code>mpf_set_prec</code>: <a href="#Initializing%20Floats">Initializing Floats</a>
<li><code>mpf_set_prec_raw</code>: <a href="#Initializing%20Floats">Initializing Floats</a>
<li><code>mpf_set_q</code>: <a href="#Assigning%20Floats">Assigning Floats</a>
<li><code>mpf_set_si</code>: <a href="#Assigning%20Floats">Assigning Floats</a>
<li><code>mpf_set_str</code>: <a href="#Assigning%20Floats">Assigning Floats</a>
<li><code>mpf_set_ui</code>: <a href="#Assigning%20Floats">Assigning Floats</a>
<li><code>mpf_set_z</code>: <a href="#Assigning%20Floats">Assigning Floats</a>
<li><code>mpf_sgn</code>: <a href="#Float%20Comparison">Float Comparison</a>
<li><code>mpf_sqrt</code>: <a href="#Float%20Arithmetic">Float Arithmetic</a>
<li><code>mpf_sqrt_ui</code>: <a href="#Float%20Arithmetic">Float Arithmetic</a>
<li><code>mpf_sub</code>: <a href="#Float%20Arithmetic">Float Arithmetic</a>
<li><code>mpf_sub_ui</code>: <a href="#Float%20Arithmetic">Float Arithmetic</a>
<li><code>mpf_swap</code>: <a href="#Assigning%20Floats">Assigning Floats</a>
<li><code><code>mpf_t</code></code>: <a href="#Nomenclature%20and%20Types">Nomenclature and Types</a>
<li><code>mpf_trunc</code>: <a href="#Miscellaneous%20Float%20Functions">Miscellaneous Float Functions</a>
<li><code>mpf_ui_div</code>: <a href="#Float%20Arithmetic">Float Arithmetic</a>
<li><code>mpf_ui_sub</code>: <a href="#Float%20Arithmetic">Float Arithmetic</a>
<li><code>mpf_urandomb</code>: <a href="#Miscellaneous%20Float%20Functions">Miscellaneous Float Functions</a>
<li><code>mpfr_class</code>: <a href="#C++%20Interface%20MPFR">C++ Interface MPFR</a>
<li><code>mpn_add</code>: <a href="#Low-level%20Functions">Low-level Functions</a>
<li><code>mpn_add_1</code>: <a href="#Low-level%20Functions">Low-level Functions</a>
<li><code>mpn_add_n</code>: <a href="#Low-level%20Functions">Low-level Functions</a>
<li><code>mpn_addmul_1</code>: <a href="#Low-level%20Functions">Low-level Functions</a>
<li><code>mpn_bdivmod</code>: <a href="#Low-level%20Functions">Low-level Functions</a>
<li><code>mpn_cmp</code>: <a href="#Low-level%20Functions">Low-level Functions</a>
<li><code>mpn_divexact_by3</code>: <a href="#Low-level%20Functions">Low-level Functions</a>
<li><code>mpn_divexact_by3c</code>: <a href="#Low-level%20Functions">Low-level Functions</a>
<li><code>mpn_divmod</code>: <a href="#Low-level%20Functions">Low-level Functions</a>
<li><code>mpn_divmod_1</code>: <a href="#Low-level%20Functions">Low-level Functions</a>
<li><code>mpn_divrem</code>: <a href="#Low-level%20Functions">Low-level Functions</a>
<li><code>mpn_divrem_1</code>: <a href="#Low-level%20Functions">Low-level Functions</a>
<li><code>mpn_gcd</code>: <a href="#Low-level%20Functions">Low-level Functions</a>
<li><code>mpn_gcd_1</code>: <a href="#Low-level%20Functions">Low-level Functions</a>
<li><code>mpn_gcdext</code>: <a href="#Low-level%20Functions">Low-level Functions</a>
<li><code>mpn_get_str</code>: <a href="#Low-level%20Functions">Low-level Functions</a>
<li><code>mpn_hamdist</code>: <a href="#Low-level%20Functions">Low-level Functions</a>
<li><code>mpn_lshift</code>: <a href="#Low-level%20Functions">Low-level Functions</a>
<li><code>mpn_mod_1</code>: <a href="#Low-level%20Functions">Low-level Functions</a>
<li><code>mpn_mul</code>: <a href="#Low-level%20Functions">Low-level Functions</a>
<li><code>mpn_mul_1</code>: <a href="#Low-level%20Functions">Low-level Functions</a>
<li><code>mpn_mul_n</code>: <a href="#Low-level%20Functions">Low-level Functions</a>
<li><code>mpn_perfect_square_p</code>: <a href="#Low-level%20Functions">Low-level Functions</a>
<li><code>mpn_popcount</code>: <a href="#Low-level%20Functions">Low-level Functions</a>
<li><code>mpn_random</code>: <a href="#Low-level%20Functions">Low-level Functions</a>
<li><code>mpn_random2</code>: <a href="#Low-level%20Functions">Low-level Functions</a>
<li><code>mpn_rshift</code>: <a href="#Low-level%20Functions">Low-level Functions</a>
<li><code>mpn_scan0</code>: <a href="#Low-level%20Functions">Low-level Functions</a>
<li><code>mpn_scan1</code>: <a href="#Low-level%20Functions">Low-level Functions</a>
<li><code>mpn_set_str</code>: <a href="#Low-level%20Functions">Low-level Functions</a>
<li><code>mpn_sqrtrem</code>: <a href="#Low-level%20Functions">Low-level Functions</a>
<li><code>mpn_sub</code>: <a href="#Low-level%20Functions">Low-level Functions</a>
<li><code>mpn_sub_1</code>: <a href="#Low-level%20Functions">Low-level Functions</a>
<li><code>mpn_sub_n</code>: <a href="#Low-level%20Functions">Low-level Functions</a>
<li><code>mpn_submul_1</code>: <a href="#Low-level%20Functions">Low-level Functions</a>
<li><code>mpn_tdiv_qr</code>: <a href="#Low-level%20Functions">Low-level Functions</a>
<li><code>mpq_abs</code>: <a href="#Rational%20Arithmetic">Rational Arithmetic</a>
<li><code>mpq_add</code>: <a href="#Rational%20Arithmetic">Rational Arithmetic</a>
<li><code>mpq_canonicalize</code>: <a href="#Rational%20Number%20Functions">Rational Number Functions</a>
<li><code>mpq_class</code>: <a href="#C++%20Interface%20General">C++ Interface General</a>
<li><code>mpq_class::canonicalize</code>: <a href="#C++%20Interface%20Rationals">C++ Interface Rationals</a>
<li><code>mpq_class::get_d</code>: <a href="#C++%20Interface%20Rationals">C++ Interface Rationals</a>
<li><code>mpq_class::get_den</code>: <a href="#C++%20Interface%20Rationals">C++ Interface Rationals</a>
<li><code>mpq_class::get_den_mpz_t</code>: <a href="#C++%20Interface%20Rationals">C++ Interface Rationals</a>
<li><code>mpq_class::get_mpq_t</code>: <a href="#C++%20Interface%20General">C++ Interface General</a>
<li><code>mpq_class::get_num</code>: <a href="#C++%20Interface%20Rationals">C++ Interface Rationals</a>
<li><code>mpq_class::get_num_mpz_t</code>: <a href="#C++%20Interface%20Rationals">C++ Interface Rationals</a>
<li><code>mpq_class::mpq_class</code>: <a href="#C++%20Interface%20Rationals">C++ Interface Rationals</a>
<li><code>mpq_clear</code>: <a href="#Initializing%20Rationals">Initializing Rationals</a>
<li><code>mpq_cmp</code>: <a href="#Comparing%20Rationals">Comparing Rationals</a>
<li><code>mpq_cmp_si</code>: <a href="#Comparing%20Rationals">Comparing Rationals</a>
<li><code>mpq_cmp_ui</code>: <a href="#Comparing%20Rationals">Comparing Rationals</a>
<li><code>mpq_denref</code>: <a href="#Applying%20Integer%20Functions">Applying Integer Functions</a>
<li><code>mpq_div</code>: <a href="#Rational%20Arithmetic">Rational Arithmetic</a>
<li><code>mpq_div_2exp</code>: <a href="#Rational%20Arithmetic">Rational Arithmetic</a>
<li><code>mpq_equal</code>: <a href="#Comparing%20Rationals">Comparing Rationals</a>
<li><code>mpq_get_d</code>: <a href="#Rational%20Conversions">Rational Conversions</a>
<li><code>mpq_get_den</code>: <a href="#Applying%20Integer%20Functions">Applying Integer Functions</a>
<li><code>mpq_get_num</code>: <a href="#Applying%20Integer%20Functions">Applying Integer Functions</a>
<li><code>mpq_get_str</code>: <a href="#Rational%20Conversions">Rational Conversions</a>
<li><code>mpq_init</code>: <a href="#Initializing%20Rationals">Initializing Rationals</a>
<li><code>mpq_inp_str</code>: <a href="#I%2fO%20of%20Rationals">I/O of Rationals</a>
<li><code>mpq_inv</code>: <a href="#Rational%20Arithmetic">Rational Arithmetic</a>
<li><code>mpq_mul</code>: <a href="#Rational%20Arithmetic">Rational Arithmetic</a>
<li><code>mpq_mul_2exp</code>: <a href="#Rational%20Arithmetic">Rational Arithmetic</a>
<li><code>mpq_neg</code>: <a href="#Rational%20Arithmetic">Rational Arithmetic</a>
<li><code>mpq_numref</code>: <a href="#Applying%20Integer%20Functions">Applying Integer Functions</a>
<li><code>mpq_out_str</code>: <a href="#I%2fO%20of%20Rationals">I/O of Rationals</a>
<li><code>mpq_set</code>: <a href="#Initializing%20Rationals">Initializing Rationals</a>
<li><code>mpq_set_d</code>: <a href="#Rational%20Conversions">Rational Conversions</a>
<li><code>mpq_set_den</code>: <a href="#Applying%20Integer%20Functions">Applying Integer Functions</a>
<li><code>mpq_set_f</code>: <a href="#Rational%20Conversions">Rational Conversions</a>
<li><code>mpq_set_num</code>: <a href="#Applying%20Integer%20Functions">Applying Integer Functions</a>
<li><code>mpq_set_si</code>: <a href="#Initializing%20Rationals">Initializing Rationals</a>
<li><code>mpq_set_str</code>: <a href="#Initializing%20Rationals">Initializing Rationals</a>
<li><code>mpq_set_ui</code>: <a href="#Initializing%20Rationals">Initializing Rationals</a>
<li><code>mpq_set_z</code>: <a href="#Initializing%20Rationals">Initializing Rationals</a>
<li><code>mpq_sgn</code>: <a href="#Comparing%20Rationals">Comparing Rationals</a>
<li><code>mpq_sub</code>: <a href="#Rational%20Arithmetic">Rational Arithmetic</a>
<li><code>mpq_swap</code>: <a href="#Initializing%20Rationals">Initializing Rationals</a>
<li><code><code>mpq_t</code></code>: <a href="#Nomenclature%20and%20Types">Nomenclature and Types</a>
<li><code>mpz_abs</code>: <a href="#Integer%20Arithmetic">Integer Arithmetic</a>
<li><code>mpz_add</code>: <a href="#Integer%20Arithmetic">Integer Arithmetic</a>
<li><code>mpz_add_ui</code>: <a href="#Integer%20Arithmetic">Integer Arithmetic</a>
<li><code>mpz_addmul</code>: <a href="#Integer%20Arithmetic">Integer Arithmetic</a>
<li><code>mpz_addmul_ui</code>: <a href="#Integer%20Arithmetic">Integer Arithmetic</a>
<li><code>mpz_and</code>: <a href="#Integer%20Logic%20and%20Bit%20Fiddling">Integer Logic and Bit Fiddling</a>
<li><code>mpz_array_init</code>: <a href="#Initializing%20Integers">Initializing Integers</a>
<li><code>mpz_bin_ui</code>: <a href="#Number%20Theoretic%20Functions">Number Theoretic Functions</a>
<li><code>mpz_bin_uiui</code>: <a href="#Number%20Theoretic%20Functions">Number Theoretic Functions</a>
<li><code>mpz_cdiv_q</code>: <a href="#Integer%20Division">Integer Division</a>
<li><code>mpz_cdiv_q_2exp</code>: <a href="#Integer%20Division">Integer Division</a>
<li><code>mpz_cdiv_q_ui</code>: <a href="#Integer%20Division">Integer Division</a>
<li><code>mpz_cdiv_qr</code>: <a href="#Integer%20Division">Integer Division</a>
<li><code>mpz_cdiv_qr_ui</code>: <a href="#Integer%20Division">Integer Division</a>
<li><code>mpz_cdiv_r</code>: <a href="#Integer%20Division">Integer Division</a>
<li><code>mpz_cdiv_r_2exp</code>: <a href="#Integer%20Division">Integer Division</a>
<li><code>mpz_cdiv_r_ui</code>: <a href="#Integer%20Division">Integer Division</a>
<li><code>mpz_cdiv_ui</code>: <a href="#Integer%20Division">Integer Division</a>
<li><code>mpz_class</code>: <a href="#C++%20Interface%20General">C++ Interface General</a>
<li><code>mpz_class::fits_sint_p</code>: <a href="#C++%20Interface%20Integers">C++ Interface Integers</a>
<li><code>mpz_class::fits_slong_p</code>: <a href="#C++%20Interface%20Integers">C++ Interface Integers</a>
<li><code>mpz_class::fits_sshort_p</code>: <a href="#C++%20Interface%20Integers">C++ Interface Integers</a>
<li><code>mpz_class::fits_uint_p</code>: <a href="#C++%20Interface%20Integers">C++ Interface Integers</a>
<li><code>mpz_class::fits_ulong_p</code>: <a href="#C++%20Interface%20Integers">C++ Interface Integers</a>
<li><code>mpz_class::fits_ushort_p</code>: <a href="#C++%20Interface%20Integers">C++ Interface Integers</a>
<li><code>mpz_class::get_d</code>: <a href="#C++%20Interface%20Integers">C++ Interface Integers</a>
<li><code>mpz_class::get_mpz_t</code>: <a href="#C++%20Interface%20General">C++ Interface General</a>
<li><code>mpz_class::get_si</code>: <a href="#C++%20Interface%20Integers">C++ Interface Integers</a>
<li><code>mpz_class::get_ui</code>: <a href="#C++%20Interface%20Integers">C++ Interface Integers</a>
<li><code>mpz_class::mpz_class</code>: <a href="#C++%20Interface%20Integers">C++ Interface Integers</a>
<li><code>mpz_clear</code>: <a href="#Initializing%20Integers">Initializing Integers</a>
<li><code>mpz_clrbit</code>: <a href="#Integer%20Logic%20and%20Bit%20Fiddling">Integer Logic and Bit Fiddling</a>
<li><code>mpz_cmp</code>: <a href="#Integer%20Comparisons">Integer Comparisons</a>
<li><code>mpz_cmp_d</code>: <a href="#Integer%20Comparisons">Integer Comparisons</a>
<li><code>mpz_cmp_si</code>: <a href="#Integer%20Comparisons">Integer Comparisons</a>
<li><code>mpz_cmp_ui</code>: <a href="#Integer%20Comparisons">Integer Comparisons</a>
<li><code>mpz_cmpabs</code>: <a href="#Integer%20Comparisons">Integer Comparisons</a>
<li><code>mpz_cmpabs_d</code>: <a href="#Integer%20Comparisons">Integer Comparisons</a>
<li><code>mpz_cmpabs_ui</code>: <a href="#Integer%20Comparisons">Integer Comparisons</a>
<li><code>mpz_com</code>: <a href="#Integer%20Logic%20and%20Bit%20Fiddling">Integer Logic and Bit Fiddling</a>
<li><code>mpz_congruent_2exp_p</code>: <a href="#Integer%20Division">Integer Division</a>
<li><code>mpz_congruent_p</code>: <a href="#Integer%20Division">Integer Division</a>
<li><code>mpz_congruent_ui_p</code>: <a href="#Integer%20Division">Integer Division</a>
<li><code>mpz_divexact</code>: <a href="#Integer%20Division">Integer Division</a>
<li><code>mpz_divexact_ui</code>: <a href="#Integer%20Division">Integer Division</a>
<li><code>mpz_divisible_2exp_p</code>: <a href="#Integer%20Division">Integer Division</a>
<li><code>mpz_divisible_p</code>: <a href="#Integer%20Division">Integer Division</a>
<li><code>mpz_divisible_ui_p</code>: <a href="#Integer%20Division">Integer Division</a>
<li><code>mpz_even_p</code>: <a href="#Miscellaneous%20Integer%20Functions">Miscellaneous Integer Functions</a>
<li><code>mpz_fac_ui</code>: <a href="#Number%20Theoretic%20Functions">Number Theoretic Functions</a>
<li><code>mpz_fdiv_q</code>: <a href="#Integer%20Division">Integer Division</a>
<li><code>mpz_fdiv_q_2exp</code>: <a href="#Integer%20Division">Integer Division</a>
<li><code>mpz_fdiv_q_ui</code>: <a href="#Integer%20Division">Integer Division</a>
<li><code>mpz_fdiv_qr</code>: <a href="#Integer%20Division">Integer Division</a>
<li><code>mpz_fdiv_qr_ui</code>: <a href="#Integer%20Division">Integer Division</a>
<li><code>mpz_fdiv_r</code>: <a href="#Integer%20Division">Integer Division</a>
<li><code>mpz_fdiv_r_2exp</code>: <a href="#Integer%20Division">Integer Division</a>
<li><code>mpz_fdiv_r_ui</code>: <a href="#Integer%20Division">Integer Division</a>
<li><code>mpz_fdiv_ui</code>: <a href="#Integer%20Division">Integer Division</a>
<li><code>mpz_fib2_ui</code>: <a href="#Number%20Theoretic%20Functions">Number Theoretic Functions</a>
<li><code>mpz_fib_ui</code>: <a href="#Number%20Theoretic%20Functions">Number Theoretic Functions</a>
<li><code>mpz_fits_sint_p</code>: <a href="#Miscellaneous%20Integer%20Functions">Miscellaneous Integer Functions</a>
<li><code>mpz_fits_slong_p</code>: <a href="#Miscellaneous%20Integer%20Functions">Miscellaneous Integer Functions</a>
<li><code>mpz_fits_sshort_p</code>: <a href="#Miscellaneous%20Integer%20Functions">Miscellaneous Integer Functions</a>
<li><code>mpz_fits_uint_p</code>: <a href="#Miscellaneous%20Integer%20Functions">Miscellaneous Integer Functions</a>
<li><code>mpz_fits_ulong_p</code>: <a href="#Miscellaneous%20Integer%20Functions">Miscellaneous Integer Functions</a>
<li><code>mpz_fits_ushort_p</code>: <a href="#Miscellaneous%20Integer%20Functions">Miscellaneous Integer Functions</a>
<li><code>mpz_gcd</code>: <a href="#Number%20Theoretic%20Functions">Number Theoretic Functions</a>
<li><code>mpz_gcd_ui</code>: <a href="#Number%20Theoretic%20Functions">Number Theoretic Functions</a>
<li><code>mpz_gcdext</code>: <a href="#Number%20Theoretic%20Functions">Number Theoretic Functions</a>
<li><code>mpz_get_d</code>: <a href="#Converting%20Integers">Converting Integers</a>
<li><code>mpz_get_d_2exp</code>: <a href="#Converting%20Integers">Converting Integers</a>
<li><code>mpz_get_si</code>: <a href="#Converting%20Integers">Converting Integers</a>
<li><code>mpz_get_str</code>: <a href="#Converting%20Integers">Converting Integers</a>
<li><code>mpz_get_ui</code>: <a href="#Converting%20Integers">Converting Integers</a>
<li><code>mpz_getlimbn</code>: <a href="#Converting%20Integers">Converting Integers</a>
<li><code>mpz_hamdist</code>: <a href="#Integer%20Logic%20and%20Bit%20Fiddling">Integer Logic and Bit Fiddling</a>
<li><code>mpz_import</code>: <a href="#Integer%20Import%20and%20Export">Integer Import and Export</a>
<li><code>mpz_init</code>: <a href="#Initializing%20Integers">Initializing Integers</a>
<li><code>mpz_init2</code>: <a href="#Initializing%20Integers">Initializing Integers</a>
<li><code>mpz_init_set</code>: <a href="#Simultaneous%20Integer%20Init%20&amp;%20Assign">Simultaneous Integer Init & Assign</a>
<li><code>mpz_init_set_d</code>: <a href="#Simultaneous%20Integer%20Init%20&amp;%20Assign">Simultaneous Integer Init & Assign</a>
<li><code>mpz_init_set_si</code>: <a href="#Simultaneous%20Integer%20Init%20&amp;%20Assign">Simultaneous Integer Init & Assign</a>
<li><code>mpz_init_set_str</code>: <a href="#Simultaneous%20Integer%20Init%20&amp;%20Assign">Simultaneous Integer Init & Assign</a>
<li><code>mpz_init_set_ui</code>: <a href="#Simultaneous%20Integer%20Init%20&amp;%20Assign">Simultaneous Integer Init & Assign</a>
<li><code>mpz_inp_raw</code>: <a href="#I%2fO%20of%20Integers">I/O of Integers</a>
<li><code>mpz_inp_str</code>: <a href="#I%2fO%20of%20Integers">I/O of Integers</a>
<li><code>mpz_invert</code>: <a href="#Number%20Theoretic%20Functions">Number Theoretic Functions</a>
<li><code>mpz_ior</code>: <a href="#Integer%20Logic%20and%20Bit%20Fiddling">Integer Logic and Bit Fiddling</a>
<li><code>mpz_jacobi</code>: <a href="#Number%20Theoretic%20Functions">Number Theoretic Functions</a>
<li><code>mpz_kronecker</code>: <a href="#Number%20Theoretic%20Functions">Number Theoretic Functions</a>
<li><code>mpz_kronecker_si</code>: <a href="#Number%20Theoretic%20Functions">Number Theoretic Functions</a>
<li><code>mpz_kronecker_ui</code>: <a href="#Number%20Theoretic%20Functions">Number Theoretic Functions</a>
<li><code>mpz_lcm</code>: <a href="#Number%20Theoretic%20Functions">Number Theoretic Functions</a>
<li><code>mpz_lcm_ui</code>: <a href="#Number%20Theoretic%20Functions">Number Theoretic Functions</a>
<li><code>mpz_legendre</code>: <a href="#Number%20Theoretic%20Functions">Number Theoretic Functions</a>
<li><code>mpz_lucnum2_ui</code>: <a href="#Number%20Theoretic%20Functions">Number Theoretic Functions</a>
<li><code>mpz_lucnum_ui</code>: <a href="#Number%20Theoretic%20Functions">Number Theoretic Functions</a>
<li><code>mpz_mod</code>: <a href="#Integer%20Division">Integer Division</a>
<li><code>mpz_mod_ui</code>: <a href="#Integer%20Division">Integer Division</a>
<li><code>mpz_mul</code>: <a href="#Integer%20Arithmetic">Integer Arithmetic</a>
<li><code>mpz_mul_2exp</code>: <a href="#Integer%20Arithmetic">Integer Arithmetic</a>
<li><code>mpz_mul_si</code>: <a href="#Integer%20Arithmetic">Integer Arithmetic</a>
<li><code>mpz_mul_ui</code>: <a href="#Integer%20Arithmetic">Integer Arithmetic</a>
<li><code>mpz_neg</code>: <a href="#Integer%20Arithmetic">Integer Arithmetic</a>
<li><code>mpz_nextprime</code>: <a href="#Number%20Theoretic%20Functions">Number Theoretic Functions</a>
<li><code>mpz_odd_p</code>: <a href="#Miscellaneous%20Integer%20Functions">Miscellaneous Integer Functions</a>
<li><code>mpz_out_raw</code>: <a href="#I%2fO%20of%20Integers">I/O of Integers</a>
<li><code>mpz_out_str</code>: <a href="#I%2fO%20of%20Integers">I/O of Integers</a>
<li><code>mpz_perfect_power_p</code>: <a href="#Integer%20Roots">Integer Roots</a>
<li><code>mpz_perfect_square_p</code>: <a href="#Integer%20Roots">Integer Roots</a>
<li><code>mpz_popcount</code>: <a href="#Integer%20Logic%20and%20Bit%20Fiddling">Integer Logic and Bit Fiddling</a>
<li><code>mpz_pow_ui</code>: <a href="#Integer%20Exponentiation">Integer Exponentiation</a>
<li><code>mpz_powm</code>: <a href="#Integer%20Exponentiation">Integer Exponentiation</a>
<li><code>mpz_powm_ui</code>: <a href="#Integer%20Exponentiation">Integer Exponentiation</a>
<li><code>mpz_probab_prime_p</code>: <a href="#Number%20Theoretic%20Functions">Number Theoretic Functions</a>
<li><code>mpz_random</code>: <a href="#Integer%20Random%20Numbers">Integer Random Numbers</a>
<li><code>mpz_random2</code>: <a href="#Integer%20Random%20Numbers">Integer Random Numbers</a>
<li><code>mpz_realloc2</code>: <a href="#Initializing%20Integers">Initializing Integers</a>
<li><code>mpz_remove</code>: <a href="#Number%20Theoretic%20Functions">Number Theoretic Functions</a>
<li><code>mpz_root</code>: <a href="#Integer%20Roots">Integer Roots</a>
<li><code>mpz_rrandomb</code>: <a href="#Integer%20Random%20Numbers">Integer Random Numbers</a>
<li><code>mpz_scan0</code>: <a href="#Integer%20Logic%20and%20Bit%20Fiddling">Integer Logic and Bit Fiddling</a>
<li><code>mpz_scan1</code>: <a href="#Integer%20Logic%20and%20Bit%20Fiddling">Integer Logic and Bit Fiddling</a>
<li><code>mpz_set</code>: <a href="#Assigning%20Integers">Assigning Integers</a>
<li><code>mpz_set_d</code>: <a href="#Assigning%20Integers">Assigning Integers</a>
<li><code>mpz_set_f</code>: <a href="#Assigning%20Integers">Assigning Integers</a>
<li><code>mpz_set_q</code>: <a href="#Assigning%20Integers">Assigning Integers</a>
<li><code>mpz_set_si</code>: <a href="#Assigning%20Integers">Assigning Integers</a>
<li><code>mpz_set_str</code>: <a href="#Assigning%20Integers">Assigning Integers</a>
<li><code>mpz_set_ui</code>: <a href="#Assigning%20Integers">Assigning Integers</a>
<li><code>mpz_setbit</code>: <a href="#Integer%20Logic%20and%20Bit%20Fiddling">Integer Logic and Bit Fiddling</a>
<li><code>mpz_sgn</code>: <a href="#Integer%20Comparisons">Integer Comparisons</a>
<li><code>mpz_si_kronecker</code>: <a href="#Number%20Theoretic%20Functions">Number Theoretic Functions</a>
<li><code>mpz_size</code>: <a href="#Miscellaneous%20Integer%20Functions">Miscellaneous Integer Functions</a>
<li><code>mpz_sizeinbase</code>: <a href="#Miscellaneous%20Integer%20Functions">Miscellaneous Integer Functions</a>
<li><code>mpz_sqrt</code>: <a href="#Integer%20Roots">Integer Roots</a>
<li><code>mpz_sqrtrem</code>: <a href="#Integer%20Roots">Integer Roots</a>
<li><code>mpz_sub</code>: <a href="#Integer%20Arithmetic">Integer Arithmetic</a>
<li><code>mpz_sub_ui</code>: <a href="#Integer%20Arithmetic">Integer Arithmetic</a>
<li><code>mpz_submul</code>: <a href="#Integer%20Arithmetic">Integer Arithmetic</a>
<li><code>mpz_submul_ui</code>: <a href="#Integer%20Arithmetic">Integer Arithmetic</a>
<li><code>mpz_swap</code>: <a href="#Assigning%20Integers">Assigning Integers</a>
<li><code><code>mpz_t</code></code>: <a href="#Nomenclature%20and%20Types">Nomenclature and Types</a>
<li><code>mpz_tdiv_q</code>: <a href="#Integer%20Division">Integer Division</a>
<li><code>mpz_tdiv_q_2exp</code>: <a href="#Integer%20Division">Integer Division</a>
<li><code>mpz_tdiv_q_ui</code>: <a href="#Integer%20Division">Integer Division</a>
<li><code>mpz_tdiv_qr</code>: <a href="#Integer%20Division">Integer Division</a>
<li><code>mpz_tdiv_qr_ui</code>: <a href="#Integer%20Division">Integer Division</a>
<li><code>mpz_tdiv_r</code>: <a href="#Integer%20Division">Integer Division</a>
<li><code>mpz_tdiv_r_2exp</code>: <a href="#Integer%20Division">Integer Division</a>
<li><code>mpz_tdiv_r_ui</code>: <a href="#Integer%20Division">Integer Division</a>
<li><code>mpz_tdiv_ui</code>: <a href="#Integer%20Division">Integer Division</a>
<li><code>mpz_tstbit</code>: <a href="#Integer%20Logic%20and%20Bit%20Fiddling">Integer Logic and Bit Fiddling</a>
<li><code>mpz_ui_kronecker</code>: <a href="#Number%20Theoretic%20Functions">Number Theoretic Functions</a>
<li><code>mpz_ui_pow_ui</code>: <a href="#Integer%20Exponentiation">Integer Exponentiation</a>
<li><code>mpz_ui_sub</code>: <a href="#Integer%20Arithmetic">Integer Arithmetic</a>
<li><code>mpz_urandomb</code>: <a href="#Integer%20Random%20Numbers">Integer Random Numbers</a>
<li><code>mpz_urandomm</code>: <a href="#Integer%20Random%20Numbers">Integer Random Numbers</a>
<li><code>mpz_xor</code>: <a href="#Integer%20Logic%20and%20Bit%20Fiddling">Integer Logic and Bit Fiddling</a>
<li><code>msqrt</code>: <a href="#BSD%20Compatible%20Functions">BSD Compatible Functions</a>
<li><code>msub</code>: <a href="#BSD%20Compatible%20Functions">BSD Compatible Functions</a>
<li><code>mtox</code>: <a href="#BSD%20Compatible%20Functions">BSD Compatible Functions</a>
<li><code>mult</code>: <a href="#BSD%20Compatible%20Functions">BSD Compatible Functions</a>
<li><code>operator%</code>: <a href="#C++%20Interface%20Integers">C++ Interface Integers</a>
<li><code>operator/</code>: <a href="#C++%20Interface%20Integers">C++ Interface Integers</a>
<li><code>operator&lt;&lt;</code>: <a href="#C++%20Formatted%20Output">C++ Formatted Output</a>
<li><code>operator&gt;&gt;</code>: <a href="#C++%20Interface%20Rationals">C++ Interface Rationals</a>, <a href="#C++%20Formatted%20Input">C++ Formatted Input</a>
<li><code>pow</code>: <a href="#BSD%20Compatible%20Functions">BSD Compatible Functions</a>
<li><code>reallocate_function</code>: <a href="#Custom%20Allocation">Custom Allocation</a>
<li><code>rpow</code>: <a href="#BSD%20Compatible%20Functions">BSD Compatible Functions</a>
<li><code>sdiv</code>: <a href="#BSD%20Compatible%20Functions">BSD Compatible Functions</a>
<li><code>sgn</code>: <a href="#C++%20Interface%20Floats">C++ Interface Floats</a>, <a href="#C++%20Interface%20Rationals">C++ Interface Rationals</a>, <a href="#C++%20Interface%20Integers">C++ Interface Integers</a>
<li><code>sqrt</code>: <a href="#C++%20Interface%20Floats">C++ Interface Floats</a>, <a href="#C++%20Interface%20Integers">C++ Interface Integers</a>
<li><code>trunc</code>: <a href="#C++%20Interface%20Floats">C++ Interface Floats</a>
<li><code>xtom</code>: <a href="#BSD%20Compatible%20Functions">BSD Compatible Functions</a>
</ul>


</body></html>

