

<!--#include virtual="/server/header.fr.html" -->

<!-- This file is automatically generated by GNUnited Nations! -->
<title>Mes expériences avec Lisp et le développement de GNU Emacs  - Projet GNU -
Free Software Foundation (FSF)</title>

<!--#include virtual="/server/banner.fr.html" -->
<!--#include virtual="/gnu/po/rms-lisp.translist" -->
<h2>Mes expériences avec Lisp et le développement de GNU Emacs</h2>

<h3>(Transcription du discours de Richard Stallman à la conférence
internationale Lisp, le 28 octobre 2002).</h3>


<p>Comme aucun de mes discours habituels n'a à voir avec Lisp, aucun ne serait
approprié pour aujourd'hui. Donc je vais improviser. Comme j'ai fait
suffisamment de choses dans ma carrière en relation avec Lisp, je devrais
être capable de raconter quelque chose d'intéressant.</p>

<p>Ma première expérience avec Lisp a été de lire le manuel Lisp 1.5 au
lycée. C'est à ce moment-là que l'idée m'a frappé de plein fouet&nbsp;:
qu'il puisse y avoir un langage informatique comme cela. La première fois
que j'ai eu la chance de faire quelque chose avec Lisp fut quand je suis
arrivé à Harvard et que j'ai écrit un interpréteur Lisp pour le <abbr
title="Programmed Data Processor">PDP</abbr>-11. C'était une toute petite
machine, avec quelque chose comme 8 Ko de mémoire, et j'ai réussi à écrire
l'interpréteur en un millier de lignes. Cela m'a laissé un peu de place pour
quelques données. Tout cela, c'était avant que je ne voie ce qu'est un vrai
logiciel, qui fait de vraies tâches sur un système.</p>

<p>J'ai commencé à travailler sur une vraie implémentation de Lisp avec JonL
White après avoir débuté au <acronym title="Massachusetts Institute of
Technology">MIT</acronym>. J'ai été engagé au laboratoire d'intelligence
artificielle (I.A.) non pas par JonL, mais par Russ Noftsker, ce qui est
plutôt ironique vu ce qui s'est passé par la suite&nbsp;; il a vraiment dû
regretter ce jour-là.</p>

<p>Pendant les années 70, avant que ma vie ne soit politisée par des événements
horribles, je me contentais de faire une extension après l'autre pour des
programmes variés, et la plupart d'entre eux n'avaient rien à voir avec
Lisp. Mais en cours de route j'ai écrit un éditeur de texte, Emacs. L'idée
intéressante à propos d'Emacs était qu'il possédait un langage de
programmation, et que les commandes d'édition de l'utilisateur étaient
écrites dans ce langage de programmation interprété, de telle sorte que vous
pouviez charger de nouvelles commandes dans votre éditeur pendant que vous
éditiez. Vous pouviez éditer les programmes que vous utilisiez tout en
continuant à vous en servir pour l'édition. Donc, nous avions un système qui
était utile à autre chose qu'à programmer, et que vous pouviez programmer
pendant que vous l'utilisiez. Je ne sais pas si c'était le premier programme
à le faire, mais c'était certainement le premier éditeur comme ça.</p>

<p>L'idée de construire des programmes gigantesques et compliqués pour nous en
servir dans notre propre travail d'édition, et ensuite de les échanger avec
d'autres personnes, a alimenté l'esprit de coopération sans contrainte que
nous avions au labo d'<acronym title="Intelligence
Artificielle">I.A.</acronym> à ce moment-là. L'idée première était qu'on
pouvait donner une copie de n'importe quel programme qu'on possédait à celui
qui en voulait une copie. Nous partagions les programmes avec qui voulait
les utiliser, ils étaient de la connaissance, du savoir humain. Donc même
s'il n'y avait pas de pensée politique organisée liée à la manière dont nous
partagions du logiciel pour concevoir Emacs, je suis convaincu qu'il y avait
une connexion, peut-être une connexion inconsciente. Je pense que c'est la
nature de notre façon de vivre au labo d'I.A. qui à mené à Emacs et l'a fait
devenir ce qu'il était.</p>

<p>L'Emacs original ne contenait pas de Lisp. Le langage de bas niveau, le
langage non interprété, était de l'assembleur PDP-10. L'interpréteur dans
lequel nous écrivions n'était en fait pas écrit pour Emacs, il était écrit
pour <acronym title="Text Editor and COrrector">TECO</acronym>. C'était
notre éditeur de texte, et c'était un langage de programmation extrêmement
laid, le plus laid qui puisse exister. La raison en était qu'il n'était pas
conçu pour être un langage de programmation, mais pour être un langage
d'édition et de commande. Il y avait des commandes comme «&nbsp;5l&nbsp;»,
signifiant «&nbsp;avance de 5 lignes&nbsp;», ou bien «&nbsp;i&nbsp;» puis
une chaîne de caractère et Échap pour insérer cette chaîne. Vous pouviez
taper une chaîne de caractères qui était une série de commandes, ce qui
s'appelait une chaîne de commande. Vous la terminiez par Échap Échap, et
elle était exécutée.</p>

<p>Eh bien, certaines personnes voulaient étendre ce langage avec des méthodes
de programmation, donc ils en ont ajouté quelques-unes. Par exemple, l'une
des premières fut une structure de boucle, qui était &lt; &gt;. Vous pouviez
les placer autour de quelque chose, et cette chose s'exécutait en boucle. Il
y avait d'autres commandes cryptiques qui pouvaient être utilisées pour
sortir de la boucle en fonction de conditions. Pour faire Emacs, nous <a
href="#foot-7">(7)</a> avons ajouté des méthodes pour avoir des
sous-programmes avec des noms. Avant cela, c'était une sorte de Basic, et
les sous-programmes pouvaient uniquement avoir une seule lettre pour nom. Il
était difficile de faire des gros programmes avec, donc nous avons ajouté du
code pour qu'ils puissent avoir des noms plus long. En fait, il y avait des
méthodes plutôt sophistiquées&nbsp;: je pense que Lisp a hérité sa méthode
<cite>unwind-protect</cite> de <acronym>TECO</acronym>.</p>

<p>Nous avons commencé à intégrer des méthodes plutôt sophistiquées, toutes
avec la syntaxe la plus horrible que vous puissiez imaginer, et cela
marchait&nbsp;; les gens étaient capables d'écrire des programmes avec, en
tout cas. La leçon évidente était qu'un langage comme TECO, qui n'a pas été
conçu pour programmer, était la mauvaise direction. Le langage sur lequel on
construit des extensions ne devrait pas être vu en tant que langage de
programmation après coup, il devrait être <em>conçu</em> en tant que langage
de programmation. En fait, nous avons découvert que le meilleur langage de
programmation pour faire cela était Lisp.</p>

<p>C'est Bernie Greenberg qui a découvert ceci <a href="#foot-5">(5)</a>. Il a
écrit une version d'Emacs en Multics MacLisp, et il écrivait ses commandes
en MacLisp de façon très directe. L'éditeur lui-même était entièrement écrit
en Lisp. Emacs Multics fut un grand succès&nbsp;: programmer de nouvelles
commandes d'édition était si pratique que même les secrétaires dans son
bureau ont commencé à apprendre à s'en servir. Elles utilisaient un manuel
que quelqu'un avait écrit, qui montrait comment étendre Emacs, mais qui ne
disait pas qu'il s'agissait de programmation. Donc les secrétaires, qui
croyaient qu'elles ne pouvaient pas programmer, n'ont pas été
effrayées. Elles ont lu le manuel, découvert qu'elles pouvaient faire des
choses utiles, et ont appris à programmer.</p>

<p>Donc Bernie a vu qu'une application (un programme qui fait quelque chose
d'utile pour vous) qui avait Lisp à l'intérieur, et que vous pouviez étendre
en réécrivant les programmes Lisp, était vraiment une très bonne manière
pour les gens d'apprendre à programmer. Cela leur donnait la chance d'écrire
de petits programmes qui leur étaient utiles, ce qui est impossible dans la
plupart des situations. L'utilité pratique qu'ils en retiraient leur servait
d'encouragement (au stade le plus difficile) quand ils ne croyaient pas
pouvoir programmer, jusqu'à ce qu'ils arrivent au point où ils étaient
devenus programmeurs.</p>

<p>À ce moment-là, les gens ont commencé à se demander comment ils pouvaient
obtenir quelque chose de ce genre sur une plateforme sur laquelle ils ne
disposaient pas de l'implémentation des services complets de Lisp. Multics
MacLisp avait un compilateur aussi bien qu'un interpréteur (c'était un
système Lisp complet) mais les gens voulaient implémenter quelque chose
comme ça sur d'autres systèmes où ils n'avaient pas encore de compilateur
Lisp. Car sans avoir le compilateur Lisp vous ne pouviez écrire l'éditeur
entier en Lisp&nbsp;: ce serait trop lent, spécialement l'affichage, s'il
fallait faire tourner du Lisp interprété. Donc nous avons développé une
technique hybride. L'idée était d'écrire ensemble l'interpréteur Lisp et les
parties bas-niveau de l'éditeur, de telle sorte que certaines parties de
l'éditeur étaient des méthodes intégrées Lisp. C'était toutes les parties
dont nous pensions qu'elles avaient besoin d'être optimisées. C'est une
technique que nous avions déjà consciemment pratiqué dans l'Emacs original,
puisqu'il y avait certaines fonctionnalités de relativement haut niveau que
nous réimplémentions en langage machine, les transformant en primitives
TECO. Par exemple, il y avait une primitive TECO pour remplir un paragraphe
(en fait, pour faire le gros du travail de remplir un paragraphe, parce que
certaines des parties du travail les moins exigeantes en temps étaient
faites à un niveau supérieur par un programme TECO). Vous pouviez faire tout
le travail en écrivant un programme TECO, mais c'était trop lent, donc nous
l'avons optimisé en en mettant une partie en langage machine. C'est cette
idée que nous avons utilisée dans la technique hybride : la plus grosse
partie de l'éditeur serait écrite en Lisp, mais certaines parties ayant
besoin de fonctionner particulièrement rapidement seraient écrites à un
niveau inférieur.</p>

<p>C'est pourquoi, quand j'ai écrit ma deuxième implémentation d'Emacs, j'ai
suivi le même concept. Le langage de bas niveau n'était plus du langage
machine mais du C. C'était un bon langage, efficace pour des programmes
portables fonctionnant dans un système d'exploitation de type Unix. Il y
avait un interpréteur Lisp, mais j'ai implémenté des méthodes pour les
travaux d'édition spéciale directement en C&nbsp;: manipuler les piles de
l'éditeur, insérer des interlignes <cite>[leading text]</cite>, lire et
écrire des fichiers, réafficher la pile à l'écran, gérer les fenêtres de
l'éditeur.</p>

<p>Cela dit, ce n'était pas le premier Emacs écrit en C et fonctionnant sous
Unix. Le premier a été écrit par James Gosling, et était appelé GosMac. Une
chose étrange lui est arrivée. Au début, il semblait être influencé par le
même esprit de partage et de coopération que celui de l'Emacs original. J'ai
d'abord distribué l'Emacs original aux gens du MIT. Quelqu'un voulait le
porter pour le faire fonctionner sur Twenex&nbsp;: il fonctionnait à
l'origine sur l'<cite>Incompatible Timesharing System</cite><a
id="TransNote1-rev" href="#TransNote1"><sup>a</sup></a> que nous utilisions
au MIT. Ils l'ont porté sur Twenex, ce qui signifiait qu'il y avait quelques
centaines d'installations dans le monde qui pouvaient potentiellement
l'utiliser. Nous avons commencé à le leur distribuer, avec la règle que
«&nbsp;vous aviez à renvoyer toutes vos améliorations&nbsp;» pour que tout
le monde en bénéficie. Personne n'a jamais essayé de surveiller son
application, mais à ce que j'en sais les gens ont coopéré.</p>

<p>Gosling avait l'air, au début, de participer à cet esprit. Il a écrit dans
un manuel qu'il appelait le programme Emacs en espérant que d'autres dans la
communauté l'amélioreraient jusqu'à ce qu'il soit digne de ce nom. C'est la
bonne approche pour créer une communauté&nbsp;: demander aux gens de se
joindre à vous pour participer à l'amélioration du programme. Mais après
cela il a apparemment changé d'esprit, et a vendu le programme à une
entreprise.</p>

<p>À ce moment-là je travaillais sur le système GNU (un système d'exploitation
libre de type Unix que beaucoup de personnes nomment par erreur
«&nbsp;Linux&nbsp;»). Il n'y avait pas d'éditeur Emacs libre qui
fonctionnait sur Unix. J'avais par contre un ami qui avait participé au
développement de l'Emacs de Gosling. Gosling lui avait donné, par courriel,
la permission de distribuer sa propre version. Il m'a proposé d'utiliser
cette version. Puis j'ai découvert que l'Emacs de Gosling n'avait pas
réellement de Lisp. Il avait un langage de programmation connu sous le nom
de «&nbsp;mocklisp&nbsp;», qui ressemblait pour la syntaxe à Lisp, mais
n'avait pas les structures de données de Lisp. Donc les programmes n'étaient
pas des données, et des éléments vitaux de Lisp manquaient. Ses structures
de données étaient les chaînes de caractères, les nombres et quelques autres
choses spécialisées.</p>

<p>J'ai conclu que je ne pouvais pas l'utiliser et que j'avais à tout
remplacer, en commençant par écrire un vrai interpréteur Lisp. J'ai
progressivement adapté toutes les parties de l'éditeur aux structures de
données du vrai Lisp, plutôt qu'à des structures de données ad hoc, rendant
les structures de données des parties internes de l'éditeur exposables et
manipulables par les programmes Lisp des utilisateurs.</p>

<p>L'unique exception était l'affichage. Pendant longtemps, le réaffichage
était une sorte d'autre planète. L'éditeur entrait le mot pour réaffichage,
et les choses continuaient avec des structures de données très spéciales qui
n'étaient pas sûres pour l'interception des messages d'erreurs, pas sûres
pour les interruptions, et vous ne pouviez lancer aucun programme Lisp
pendant ce temps-là. Nous avons changé ça depuis&nbsp;: il est maintenant
possible de lancer du code Lisp pendant le réaffichage. C'est quelque chose
d'assez pratique.</p>

<p>Ce second programme Emacs était du «&nbsp;logiciel libre&nbsp;» dans le sens
moderne du terme&nbsp;: il faisait partie d'une campagne politique explicite
pour libérer le logiciel. L'essence de cette campagne était que n'importe
qui devrait être libre de faire les choses que nous faisions au temps du
MIT, travailler ensemble sur du logiciel et travailler avec qui voulait
travailler avec nous. C'est la base du mouvement du logiciel libre&nbsp;:
l'expérience que j'ai eue, la vie que nous avions au Labo d'I.A. du MIT, de
travailler sur du savoir, et de ne pas empêcher qui que ce soit de le
réutiliser et de le disséminer.</p>

<p>À cette époque, vous pouviez fabriquer un ordinateur dans le même ordre de
prix que d'autres qui n'étaient pas conçus pour Lisp, sauf qu'il faisait
fonctionner Lisp beaucoup plus rapidement qu'eux, avec en plus une
vérification complète de type. Les ordinateurs ordinaires vous forçaient
typiquement à choisir entre vitesse d'exécution et bonne vérification de
type. Donc oui, vous pouviez avoir un compilateur Lisp et faire fonctionner
vos programmes rapidement, mais quand ils essayaient de prendre le
«&nbsp;car&nbsp;» d'un nombre, il sortaient des résultats insensés et
finalement plantaient au bout d'un moment.</p>

<p>La machine Lisp était capable d'exécuter des instructions presque aussi vite
que ces autres machines mais, à chaque instruction, une instruction
<tt>car</tt> faisait une vérification de type ; donc quand vous essayiez
d'obtenir le «&nbsp;car&nbsp;» d'un nombre dans un programme compilé, vous
obteniez immédiatement une erreur. Nous construisions la machine et avions
un système d'exploitation Lisp pour elle. Il était presque entièrement écrit
en Lisp, les seules exceptions étant certaines parties écrites dans le
microcode. Des gens ont porté de l'intérêt à leur fabrication, ce qui
signifiait qu'ils allaient lancer une entreprise.</p>

<p>Il y avait deux idées différentes sur le type de société que ça devrait
être. Greenblatt voulait lancer ce qu'il appelait une entreprise de
«&nbsp;hacker&nbsp;». Cela signifie qu'il voulait une entreprise dirigée par
des hackers et qui fonctionnerait d'une manière favorable aux hackers. Elle
aurait également pour but de maintenir la culture du labo d'I.A <a
href="#foot-1">(1)</a>. Malheureusement, Greenblatt n'avait aucune
expérience des affaires, donc d'autres personnes dans le groupe de la
machine Lisp ont dit qu'ils doutaient qu'il puisse réussir. Ils pensaient
que son plan pour éviter les investissements extérieurs ne marcherait pas.</p>

<p>Pourquoi voulait-il éviter les investissements extérieurs&nbsp;? Parce que
lorsqu'une entreprise a des investisseurs extérieurs, ils prennent le
contrôle, et ne vous laissent pas avoir le moindre scrupule. Et finalement,
si vous avez des scrupules, ils vous remplacent également en tant que
directeur.</p>

<p>Donc Greenblatt avait l'idée qu'il trouverait un client prêt à payer
d'avance pour acheter les composants. Ils construiraient les machines et les
livreraient&nbsp;: avec le bénéfice réalisé, ils seraient en mesure
d'acheter les composants pour quelques machines de plus, de les vendre,
d'acheter des composants pour plus de machines, et caetera et caetera. Les
autres personnes dans le groupe ne pensaient pas que cela puisse
fonctionner.</p>

<p>Greenblatt a ensuite recruté Russel Noftsker, la personne qui m'avait
engagé, et qui avait entre temps quitté le Labo d'I.A. et monté une
entreprise florissante. Russel passait pour avoir des capacité pour les
affaires. Il a démontré cette capacité pour les affaires en disant aux
autres membres du groupe&nbsp;: «&nbsp;Jetons Greenblatt, oublions son idée,
et faisons une autre entreprise.&nbsp;» Poignarder dans le dos, clairement
un vrai homme d'affaires. Ces personnes décidèrent qu'elles formeraient une
société nommée Symbolics. Ils chercheraient des investissements extérieurs,
n'auraient aucun scrupule, et feraient tout leur possible pour gagner.</p>

<p>Mais Greenblatt n'a pas abandonné. Lui et les quelques personnes qui lui
étaient restées loyales décidèrent de lancer tout de même <cite>Lisp
Machines Inc.</cite> et de continuer sur leur plan original. Et devinez
quoi, ils ont réussi&nbsp;! Ils ont trouvé leur premier client et ont été
payés d'avance. Ils ont construit leurs machines, les ont vendues, et ont
construit de plus en plus de machines. Ils ont effectivement réussi alors
même qu'ils n'avaient pas l'aide de la plupart des personnes du
groupe. Symbolics a aussi eu un départ réussi, donc vous aviez deux
entreprises concurrentes de machines Lisp. Quand Symbolics a vu que LMI
n'allait pas s'écrouler, ils ont commencé à chercher des moyens de le
détruire.</p>

<p>Donc, l'abandon de notre labo fut suivi par une «&nbsp;guerre&nbsp;» dans
notre labo. L'abandon s'est fait quand Symbolics a débauché tous les
hackers, à l'exception de moi et des quelques-uns qui travaillaient à LMI à
temps partiel. Puis ils ont invoqué une règle pour éliminer les gens
travaillant à temps partiel pour le MIT, les forçant à le quitter
entièrement, ce qui m'a laissé seul. Le Labo d'I.A. était maintenant
impuissant. Et le MIT a passé un arrangement absurde avec ces deux
entreprises. C'était un contrat entre eux trois dans lequel chaque
entreprise donnait des licences pour utiliser les sources des systèmes de
machine Lisp. Ces entreprises étaient forcées de laisser le MIT utiliser
leurs modifications. Mais le contrat ne contenait rien disant que le MIT
avait le droit de les utiliser dans les systèmes de machine Lisp pour
lesquels les deux entreprises lui avaient donné des licences. Personne
n'avait imaginé que le groupe de hackers du Labo d'I.A. disparaîtrait, mais
ce fut le cas.</p>

<p> Donc Symbolics a eu une idée <a href="#foot-4">(4)</a>. Ils ont dit au
labo&nbsp;: «&nbsp;Nous continuerons à mettre à votre disposition nos
modifications du système pour votre usage, mais vous ne pouvez les utiliser
dans le système de machine Lisp du MIT. À la place, nous vous donnerons
accès au système de machine Lisp de Symbolics, et vous pourrez l'utiliser,
mais c'est tout ce que vous pourrez faire&nbsp;».</p>

<p>Ceci, en pratique, voulait dire qu'ils demandaient que nous choisissions un
camp, et utilisions soit la version du MIT, soit la version de
Symbolics. Quel que soit notre choix cela déterminait à quel système iraient
nos améliorations. Si nous travaillions et améliorions la version de
Symbolics, nous soutiendrions uniquement Symbolics. Si nous utilisions et
améliorions la version MIT du système, nous réaliserions du travail
disponible pour les deux entreprises, mais Symbolics verrait que nous
soutiendrions LMI puisque nous les aiderions à exister. Donc nous ne
pouvions plus rester neutres.</p>

<p>Jusqu'à ce moment, je n'avais pris parti pour aucune des deux entreprises,
bien que cela me rendît malheureux de voir ce qui était arrivé à notre
communauté et au logiciel. Mais maintenant, Symbolics avait soulevé la
question. Donc, dans un effort pour aider à faire continuer <cite>Lisp
Machines Inc.</cite> <a href="#foot-2">(2)</a>, j'ai commencé à dupliquer
toutes les améliorations que Symbolics avait faites au système machine
Lisp. J'ai réécrit des améliorations équivalentes moi-même (c'est-à-dire
avec mon propre code).</p>

<p>Au bout d'un moment <a href="#foot-3">(3)</a>, je suis arrivé à la
conclusion que cela irait mieux si je ne regardais même pas leur code. Quand
ils annonçaient une version bêta qui donnait les notes de versions, je
pouvais voir quelles allaient être les fonctionnalités et les implémenter
moi-même. Au moment où ils avaient une vraie version, j'avais la mienne
également.</p>

<p>De cette façon, et pendant deux ans, je les ai empêchés d'écraser <cite>Lisp
Machines Incorporated</cite>, et les deux entreprises ont continué
d'exister. Mais je ne voulais pas passer des années et des années à punir
quelqu'un, uniquement à contrer une entreprise maléfique. J'imagine qu'ils
ont été punis assez sévèrement parce qu'ils étaient bloqués avec de la
concurrence qui n'allait pas laisser tomber ni disparaître <a
href="#foot-6">(6)</a>. De toute manière, il était temps de commencer à
bâtir une nouvelle communauté pour remplacer l'autre que leurs actions et
d'autres avait rayée de la carte.</p>

<p>La communauté Lisp des années 70 n'était pas limitée au Labo d'I.A. du MIT,
et les hackers ne venaient pas tous du MIT. La guerre que Symbolics a lancée
fut ce qui anéanti (la communauté au) MIT, mais il y avait d'autres
événements en cours au même moment. Il y avait des gens qui abandonnaient la
coopération ; tout cela détruisait la communauté, et il n'en restait pas
grand chose.</p>

<p>Après avoir arrêté de punir Symbolics, il a fallu réfléchir à quoi faire
ensuite. Il fallait que je fasse un système d'exploitation libre, c'était
clair&nbsp;: la seule façon de faire travailler des gens ensemble et de les
faire partager était avec un système d'exploitation libre.</p>

<p>Au début, j'ai pensé faire un système basé sur Lisp, mais j'ai réalisé que
techniquement ce n'était pas une très bonne idée. Pour avoir quelque chose
comme le système machine Lisp, vous aviez besoin de microcode à but
spécifique. C'est ce qui rendait possible de faire fonctionner des
programmes aussi rapidement que les autres ordinateurs faisaient fonctionner
les leurs, en ayant tout de même le bénéfice de la vérification de
type. Sans cela, vous en étiez réduit à quelque chose comme les compilateurs
Lisp pour les autres machines. Les programmes seraient plus rapides, mais
instables. Ça va bien si vous faites fonctionner un programme sur un système
à partage de temps&nbsp;: si un programme plante, ce n'est pas un désastre,
c'est quelque chose que les programmes font occasionnellement. Mais cela ne
convenait pour l'écriture d'un système d'exploitation, donc j'ai rejeté
l'idée de faire un système comme la machine Lisp.</p>

<p>J'ai décidé de faire un système d'exploitation de type Unix qui aurait des
implémentations Lisp qui fonctionneraient en tant que programmes
utilisateurs. Le noyau ne serait pas écrit en Lisp, mais nous aurions
Lisp. Donc le développement de ce système d'exploitation, le système
d'exploitation GNU, est ce qui m'a amené à écrire GNU Emacs. En faisant
cela, j'ai cherché à faire le minimum d'implémentation Lisp possible. La
taille des programmes était un souci énorme.</p>

<p>Il y avait des gens à cette époque, en 1985, qui avaient des machines d'un
mégaoctet sans mémoire virtuelle. Ils voulaient pouvoir utiliser GNU Emacs,
ce qui signifie qu'il fallait que je garde le programme aussi réduit que
possible.</p>

<p>Par exemple, à ce moment-là, la seule construction de boucle était
<tt>while</tt>, qui était extrêmement simple. Il n'y avait pas de moyen de
sortir de cette boucle <tt>while</tt>, vous ne pouviez faire qu'un
<tt>catch</tt> et un <tt>throw</tt>, ou tester une variable dans la
boucle. Cela montre à quel point j'essayais de réduire le programme. Nous
n'avions pas de <tt>caar</tt>, de <tt>cadr</tt>, etc.&nbsp;: simplifier au
maximum était l'esprit de GNU Emacs, l'esprit de Emacs Lisp, depuis le
début.</p>

<p>Évidemment les machines sont plus grosses maintenant, et nous ne le faisons
plus de cette façon. Nous utilisons <tt>caar</tt> et <tt>cadr</tt>, etc., et
nous pourrions intégrer une autre construction de boucle un de ces
jours. Nous sommes favorables à l'étendre un peu maintenant, mais nous ne
voulons pas l'étendre au niveau du Common Lisp. Une chose que je n'aime pas
énormément sont les arguments mots-clefs. Il ne me semblent pas très
« Lisp »&nbsp;: je le fais de temps à autre mais le moins possible.</p>

<p>Ce n'était pas la fin de l'implication du projet GNU avec Lisp. Plus tard
vers 1995, nous pensions lancer un projet de bureau graphique. Il était
clair que pour les programmes du bureau, nous voulions un langage de
programmation afin d'en écrire une grande partie et de le rendre facilement
extensible, comme l'éditeur. La question était lequel choisir.</p>

<p>À ce moment-là, <acronym title="Tool Command Language">TCL</acronym> était
largement mis en avant pour ce genre d'applications. J'avais une très
mauvaise opinion de TCL, avant tout parce que ce n'était pas du Lisp. Cela
ressemblait un peu à Lisp, mais pas au niveau sémantique, et ce n'était pas
aussi propre. Puis quelqu'un m'a montré une publicité dans laquelle Sun
essayait de recruter quelqu'un pour travailler sur TCL afin de le rendre
«&nbsp;de facto langage d'extension standard&nbsp;» mondial. Et j'ai
pensé&nbsp;: «&nbsp;Nous devons empêcher cela.&nbsp;» Donc nous avons
commencé à faire de Scheme le langage d'extension standard pour GNU. Pas
Common Lisp parce qu'il était trop gros. L'idée était d'avoir un
interpréteur Scheme conçu pour être lié à des applications de la même
manière que TCL était lié à d'autres applications. Nous allions donc
recommander que ce soit le paquet utilisé de préférence pour les extensions
à tous les programmes GNU.</p>

<p>Il y a un avantage intéressant à utiliser pour votre langage d'extension
primaire un langage puissant, tel qu'une version de Lisp. Vous pouvez
implémenter d'autres langages en les traduisant dans votre langage
primaire. Si votre langage primaire était TCL, vous ne pourriez implémenter
facilement Lisp en le traduisant en TCL. Mais si votre langage primaire est
Lisp, il n'est pas difficile d'implémenter d'autres choses en les
traduisant. Notre idée était que si chaque application extensible acceptait
Scheme, on pourrait écrire une implémentation de TCL ou de Python ou de Perl
en Scheme, qui traduirait ce programme en Scheme. Puis vous pourriez charger
cela dans n'importe quelle application et la configurer dans votre langage
favori, et cela marcherait également avec d'autres configurations.</p>

<p>Tant que l'extensibilité des langages est faible, les utilisateurs doivent
utiliser uniquement le langage qu'on leur fournit. Ce qui signifie que les
gens qui préfèrent un langage particulier ont besoin de concourir pour le
choix des développeurs d'application&nbsp;: «&nbsp;S'il vous plaît, monsieur
le développeur d'applications, incluez mon langage dans votre application,
pas le sien.&nbsp;» Ensuite, les autres utilisateurs n'ont plus le
choix&nbsp;: quelle que soit l'application qu'ils utilisent, elle arrive
avec un langage et ils sont limités à ce langage. Mais quand vous avez un
langage puissant qui peut implémenter les autres en les traduisant, alors
vous donnez le choix aux utilisateurs et vous éliminez la guerre des
langages. Nous espérons que c'est ce que fera «&nbsp;Guile&nbsp;», notre
interpréteur Scheme. Nous avions une personne travaillant l'été dernier à
finir un traducteur de Python vers Scheme. Je ne sais pas s'il est
entièrement fini maintenant, mais si quelqu'un est intéressé par ce projet,
contactez-moi. Donc voilà notre plan pour l'avenir.</p>

<p>Je n'ai pas parlé de logiciel libre, mais laissez-moi vous dire rapidement
un petit peu ce que cela veut dire. Le logiciel libre ne se réfère pas au
prix, cela ne veut pas dire que vous l'obtiendrez gratuitement (vous pouvez
avoir à payer pour une copie, ou bien vous pouvez l'obtenir gratuitement).<a
id="TransNote2-rev" href="#TransNote2"><sup>b</sup></a> Cela signifie que
vous êtes libre en tant qu'utilisateur. La chose capitale est que vous êtes
libre d'utiliser le programme, libre d'étudier ce qu'il fait, libre de le
modifier pour l'adapter à vos besoins, libre de redistribuer des copies aux
autres et libre de publier des versions améliorées ou étendues. C'est ce que
signifie logiciel libre. Si vous utilisez des logiciels non libres, vous
perdez cette liberté capitale, donc ne le faites jamais.</p>

<p>Le but du projet GNU est de faciliter aux gens le rejet des logiciels non
libres qui dominent les utilisateurs, qui piétinent leur liberté, en mettant
à leur disposition des logiciels libres pour les remplacer. À ceux qui n'ont
pas le courage moral de rejeter les logiciels non libres quand cela signifie
quelque inconvénient pratique, nous essayons de donner une alternative libre
pour qu'ils puissent se libérer avec moins de complications et un sacrifice
moindre en termes pratiques. Plus le sacrifice est petit, mieux c'est. Nous
voulons leur faciliter la vie libre, la coopération.</p>

<p>Il s'agit de la liberté de coopérer. Nous avons l'habitude de penser à la
liberté et à la coopération avec la société comme si elles
s'opposaient. Mais elles sont dans le même camp. Avec le logiciel libre vous
êtes libre de coopérer avec d'autres personnes et êtes libre de vous aider
vous-même. Avec le logiciel non libre, quelqu'un vous domine et garde les
gens divisés. Vous n'êtes pas autorisé à partager avec eux, vous n'êtes pas
libre de coopérer avec la société ni de l'aider, pas plus que vous n'êtes
autorisé à vous aider vous-même. Divisés et impuissants, voilà l'état des
utilisateurs de logiciel non libre.</p>

<p>Nous avons produit une variété énorme de logiciels libres. Nous avons fait
ce que les gens disaient que nous n'arriverions jamais à faire ; nous avons
deux systèmes d'exploitation en logiciels libres. Nous avons de nombreuses
applications et évidemment avons encore beaucoup à faire. Donc nous avons
besoin de votre aide. J'aimerais vous demander d'être volontaire pour le
projet GNU, aidez-nous à développer le logiciel libre pour qu'il y ait plus
d'emplois. Allez voir sur <a href="/help/">http://www.gnu.org/help</a> pour
trouver des suggestions sur la manière de nous aider. Si vous voulez
commander des choses, il y a un lien pour cela sur cette page. Si vous
voulez des articles sur des questions philosophiques, allez voir dans
/philosophy. Si vous cherchez des logiciels libres, allez voir dans
/directory, qui actuellement liste environ 1900 paquets (ce qui représente
une fraction de tout le logiciel libre existant). S'il vous plaît,
écrivez-en plus et contribuez. Mon livre d'essais, <cite>Free Software and
Free Society</cite> (Logiciel libre et société libre), est en vente et peut
être acheté sur <a href="http://www.gnu.org/">www.gnu.org</a>. <cite>Happy
hacking!</cite> (Codez joyeusement&nbsp;!).</p>

<ol>
<li id="foot-1">Le plan de Greenblatt, d'après ce que j'ai compris, était d'engager les gens
du laboratoire à temps partiel, afin qu'ils puissent continuer à travailler
au Labo d'I.A. Symbolics les a engagés à temps plein à la place, donc ils
ont arrêté de travailler au MIT.</li>

<li id="foot-2">Ce n'est pas que le sort de LMI m'intéressait particulièrement, mais plutôt
que je ne voulais pas laisser Symbolics gagner grâce à son agression contre
le labo d'I.A.</li>

<li id="foot-3">Cette phrase a été mal interprétée : je n'aurais, paraît-il, jamais, à aucun
moment jeté un œil sur le code de Symbolics. En réalité, cette phrase dit
que je l'ai fait.

<p>Le code source de Symbolics était disponible au MIT, où j'étais en droit de
le lire, et au début c'est ainsi que je me suis rendu compte de leurs
changements. Mais cela signifiait que je devais faire l'effort
supplémentaire de résoudre chaque problème différemment, pour éviter de
copier le code de Symbolics. Après un moment, j'ai conclu que c'était mieux
de ne pas le regarder du tout. De cette façon, je pouvais écrire le code de
la meilleure façon, sans me soucier de ce qui était dans le code Symbolics.</p></li>

<li id="foot-4">L'arrière-pensée de ce plan, que je n'ai pas explicitée dans le discours,
est que durant cette période initiale les ex-hackers du labo d'I.A., que ce
soit chez Symbolics ou chez LMI, continuent à apporter leurs modifications
au système machine Lisp du MIT, bien que le contrat ne l'exige pas. Le plan
de Symbolics était de briser cette coopération unilatéralement.</li>

<li id="foot-5">Bernie Greenberg dit que l'implémentation de Dan Weinberg d'Emacs pour la
machine Lisp est arrivée avant l'implémentation de Greenberg pour
Multics. Je lui présente mes excuses pour cette erreur.</li>

<li id="foot-6">Symbolics s'est plaint au M.I.T. que mon travail, en contrant leur plan,
avait coûté à Symbolics un million de dollars.</li>

<li id="foot-7">Guy Steele a conçu la bibliothèque symétrique originale de commandes
d'Emacs, puis lui et moi avons commencé à implémenter Emacs (par dessus
TECO), mais après une longue session de développement conjointe, Steele a
commencé à s'éloigner, donc j'ai fini Emacs. D'autres, en particulier Eugene
C. Cicciarelli et Mike McMahon, ont par la suite contribué de manière
substantielle.</li>
</ol>


<div style="font-size: small;">

<!--TRANSLATORS: Use space (SPC) as msgstr if you don't have notes.-->
<b>Notes de relecture</b><ol id="translator-notes-alpha">
<li id="TransNote1"><cite>Incompatible Timesharing System</cite>
(ITS)&nbsp;: Système incompatible à temps partagé, conçu par l'équipe du
laboratoire d'Intelligence artificielle et nommé en opposition avec le CTS
<cite>(Compatible Time Sharing System)</cite>, système d'exploitation
utilisé précédemment au MIT. <a href="#TransNote1-rev">&#8593;</a></li>
<li id="TransNote2">En anglais, le mot <cite>free</cite> veut dire libre,
mais aussi gratuit, d'où la confusion possible. <a
href="#TransNote2-rev">&#8593;</a></li>
</ol></div>
</div>

<!--#include virtual="/server/footer.fr.html" -->
<div id="footer">

<p>
Veuillez envoyer les requêtes concernant la FSF et GNU à <a
href="mailto:gnu@gnu.org">&lt;gnu@gnu.org&gt;</a>. Il existe aussi <a
href="/contact/">d'autres moyens de contacter</a> la FSF.
<br />
Veuillez indiquer (en anglais) les liens orphelins et autres corrections ou
suggestions à <a
href="mailto:webmasters@gnu.org">&lt;webmasters@gnu.org&gt;</a>.
</p>

<p>
Veuillez consulter le <a
href="/server/standards/README.translations.html">README des traductions</a>
pour des informations sur la coordination et la soumission de traductions de
cet article.
</p>

<p>
Copyright &copy; 2003, 2007 Free Software Foundation, Inc.
</p>
<p>Cette page peut être utilisée suivant les conditions de la licence <a
rel="license"
href="http://creativecommons.org/licenses/by-nd/3.0/us/">Creative Commons
Attribution-NoDerivs 3.0 United States</a>.
</p>


<div class="translators-credits">

<!--TRANSLATORS: Use space (SPC) as msgstr if you don't want credits.-->
Traduction&nbsp;: Marc de Maillard.<br /> Révision&nbsp;: <a
href="mailto:trad-gnu&#64;april.org">trad-gnu&#64;april.org</a></div>


 <p>
<!-- timestamp start -->
Dernière mise à jour&nbsp;:

$Date: 2012/04/21 00:44:51 $

<!-- timestamp end -->
</p>
</div>

<!-- <div id="translations">
 -->
<!-- <h4>
Translations of this page</h4> -->
<!--  -->
<!-- Please keep this list alphabetical by language code. -->
<!-- Comment what the language is for each type, i.e. de is German. -->
<!-- Write the language name in its own language (Deutsch) in the text. -->
<!-- If you add a new language here, please -->
<!-- advise web-translators@gnu.org and add it to -->
<!--  - /home/www/html/server/standards/README.translations.html -->
<!--  - one of the lists under the section "Translations Underway" -->
<!--  - if there is a translation team, you also have to add an alias -->
<!--  to mail.gnu.org:/com/mailer/aliases -->
<!-- Please also check you have the language code right; see: -->
<!-- http://www.loc.gov/standards/iso639-2/php/code_list.php -->
<!-- If the 2-letter ISO 639-1 code is not available, -->
<!-- use the 3-letter ISO 639-2. -->
<!-- Please use W3C normative character entities. -->
<!--  -->
<!-- <ul class="translations-list">
 -->
<!-- English -->
<!-- <li>
<a href="/gnu/rms-lisp.html">English</a>&nbsp;[en]</li> -->
<!-- Spanish -->
<!-- <li>
<a href="/gnu/rms-lisp.es.html">espa&#x00f1;ol</a>&nbsp;[es]</li> -->
<!-- French -->
<!-- <li>
<a href="/gnu/rms-lisp.fr.html">fran&#x00e7;ais</a>&nbsp;[fr]</li> -->
<!-- </ul>
 -->
<!-- </div>
 -->
</div>
</body>
</html>
